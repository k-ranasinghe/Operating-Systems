
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020058 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020058:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002005d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002005f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020060:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020062:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020064:	66 05 00 04          	add    $0x400,%ax
c0020068:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002006a:	66 3d 00 00          	cmp    $0x0,%ax
c002006e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020070:	76 06                	jbe    c0020078 <start+0x20>
	mov $0x10000, %eax
c0020072:	66 b8 00 00          	mov    $0x0,%ax
c0020076:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020078:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002007c:	67 66 a3 5e 01       	addr16 mov %ax,0x15e
c0020081:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c0020083:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020085:	a8 02                	test   $0x2,%al
	jnz 1b
c0020087:	75 fa                	jne    c0020083 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c0020089:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c002008b:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c002008d:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c002008f:	a8 02                	test   $0x2,%al
	jnz 1b
c0020091:	75 fa                	jne    c002008d <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c0020093:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c0020095:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c0020097:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c0020099:	a8 02                	test   $0x2,%al
	jnz 1b
c002009b:	75 fa                	jne    c0020097 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c002009d:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200a2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200a5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200a8:	66 b9 00 04          	mov    $0x400,%cx
c00200ac:	00 00                	add    %al,(%eax)
	rep stosl
c00200ae:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200b1:	66 b8 07 00          	mov    $0x7,%ax
c00200b5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200b7:	66 b9 11 00          	mov    $0x11,%cx
c00200bb:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200bd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200c0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200c7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200c8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200cb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200d2:	00 e2                	add    %ah,%dl
	loop 1b
c00200d4:	eb b8                	jmp    c002008e <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200d6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200d8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200da:	66 b8 07 00          	mov    $0x7,%ax
c00200de:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c00200e0:	66 b9 00 40          	mov    $0x4000,%cx
c00200e4:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200e6:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e9:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c00200f0:	66 
	addw $4, %di
	addl $0x1000, %eax
c00200f1:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c00200f6:	e2 f1                	loop   c00200e9 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c00200f8:	66 b8 00 f0          	mov    $0xf000,%ax
c00200fc:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c00200fe:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020101:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020102:	67 66 0f 01 15       	lgdtw  (%di)
c0020107:	58                   	pop    %eax
c0020108:	01 00                	add    %eax,(%eax)
c002010a:	00 0f                	add    %cl,(%edi)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002010c:	20 c0                	and    %al,%al
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002010e:	66 0d 05 00          	or     $0x5,%ax
c0020112:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020118:	ea 1f 01 02 c0 08 00 	ljmp   $0x8,$0xc002011f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002011f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020123:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020125:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020127:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020129:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002012b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002012d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020133:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020138:	e8 79 01 00 00       	call   c00202b6 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002013d:	eb fe                	jmp    c002013d <start+0xe5>
	...

c0020140 <gdt>:
	...
c0020148:	ff                   	(bad)  
c0020149:	ff 00                	incl   (%eax)
c002014b:	00 00                	add    %al,(%eax)
c002014d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020154:	00                   	.byte 0x0
c0020155:	92                   	xchg   %eax,%edx
c0020156:	cf                   	iret   
	...

c0020158 <gdtdesc>:
c0020158:	17                   	pop    %ss
c0020159:	00 40 01             	add    %al,0x1(%eax)
c002015c:	02 c0                	add    %al,%al

c002015e <init_ram_pages>:
c002015e:	00 00                	add    %al,(%eax)
	...

c0020162 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020162:	55                   	push   %ebp
c0020163:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020165:	8b 45 08             	mov    0x8(%ebp),%eax
c0020168:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002016d:	5d                   	pop    %ebp
c002016e:	c3                   	ret    

c002016f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002016f:	55                   	push   %ebp
c0020170:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020172:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020179:	0f 97 c0             	seta   %al
}
c002017c:	5d                   	pop    %ebp
c002017d:	c3                   	ret    

c002017e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002017e:	55                   	push   %ebp
c002017f:	89 e5                	mov    %esp,%ebp
c0020181:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0020184:	8b 45 08             	mov    0x8(%ebp),%eax
c0020187:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002018c:	76 1e                	jbe    c00201ac <ptov+0x2e>
c002018e:	83 ec 0c             	sub    $0xc,%esp
c0020191:	68 20 e4 02 c0       	push   $0xc002e420
c0020196:	68 3b e4 02 c0       	push   $0xc002e43b
c002019b:	68 c8 e7 02 c0       	push   $0xc002e7c8
c00201a0:	6a 4a                	push   $0x4a
c00201a2:	68 52 e4 02 c0       	push   $0xc002e452
c00201a7:	e8 7c 93 00 00       	call   c0029528 <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00201af:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201b4:	c9                   	leave  
c00201b5:	c3                   	ret    

c00201b6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201b6:	55                   	push   %ebp
c00201b7:	89 e5                	mov    %esp,%ebp
c00201b9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201bc:	ff 75 08             	pushl  0x8(%ebp)
c00201bf:	e8 ab ff ff ff       	call   c002016f <is_kernel_vaddr>
c00201c4:	83 c4 04             	add    $0x4,%esp
c00201c7:	84 c0                	test   %al,%al
c00201c9:	75 1e                	jne    c00201e9 <vtop+0x33>
c00201cb:	83 ec 0c             	sub    $0xc,%esp
c00201ce:	68 68 e4 02 c0       	push   $0xc002e468
c00201d3:	68 3b e4 02 c0       	push   $0xc002e43b
c00201d8:	68 f0 e7 02 c0       	push   $0xc002e7f0
c00201dd:	6a 54                	push   $0x54
c00201df:	68 52 e4 02 c0       	push   $0xc002e452
c00201e4:	e8 3f 93 00 00       	call   c0029528 <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c00201e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00201ec:	05 00 00 00 40       	add    $0x40000000,%eax
}
c00201f1:	c9                   	leave  
c00201f2:	c3                   	ret    

c00201f3 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c00201f3:	55                   	push   %ebp
c00201f4:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c00201f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00201f9:	c1 e8 0c             	shr    $0xc,%eax
c00201fc:	25 ff 03 00 00       	and    $0x3ff,%eax
}
c0020201:	5d                   	pop    %ebp
c0020202:	c3                   	ret    

c0020203 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020203:	55                   	push   %ebp
c0020204:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020206:	8b 45 08             	mov    0x8(%ebp),%eax
c0020209:	c1 e8 16             	shr    $0x16,%eax
}
c002020c:	5d                   	pop    %ebp
c002020d:	c3                   	ret    

c002020e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002020e:	55                   	push   %ebp
c002020f:	89 e5                	mov    %esp,%ebp
c0020211:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020214:	ff 75 08             	pushl  0x8(%ebp)
c0020217:	e8 46 ff ff ff       	call   c0020162 <pg_ofs>
c002021c:	83 c4 04             	add    $0x4,%esp
c002021f:	85 c0                	test   %eax,%eax
c0020221:	74 1e                	je     c0020241 <pde_create+0x33>
c0020223:	83 ec 0c             	sub    $0xc,%esp
c0020226:	68 80 e4 02 c0       	push   $0xc002e480
c002022b:	68 3b e4 02 c0       	push   $0xc002e43b
c0020230:	68 d0 e7 02 c0       	push   $0xc002e7d0
c0020235:	6a 48                	push   $0x48
c0020237:	68 91 e4 02 c0       	push   $0xc002e491
c002023c:	e8 e7 92 00 00       	call   c0029528 <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020241:	83 ec 0c             	sub    $0xc,%esp
c0020244:	ff 75 08             	pushl  0x8(%ebp)
c0020247:	e8 6a ff ff ff       	call   c00201b6 <vtop>
c002024c:	83 c4 10             	add    $0x10,%esp
c002024f:	83 c8 07             	or     $0x7,%eax
}
c0020252:	c9                   	leave  
c0020253:	c3                   	ret    

c0020254 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020254:	55                   	push   %ebp
c0020255:	89 e5                	mov    %esp,%ebp
c0020257:	83 ec 18             	sub    $0x18,%esp
c002025a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002025d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020260:	ff 75 08             	pushl  0x8(%ebp)
c0020263:	e8 fa fe ff ff       	call   c0020162 <pg_ofs>
c0020268:	83 c4 04             	add    $0x4,%esp
c002026b:	85 c0                	test   %eax,%eax
c002026d:	74 1e                	je     c002028d <pte_create_kernel+0x39>
c002026f:	83 ec 0c             	sub    $0xc,%esp
c0020272:	68 a5 e4 02 c0       	push   $0xc002e4a5
c0020277:	68 3b e4 02 c0       	push   $0xc002e43b
c002027c:	68 dc e7 02 c0       	push   $0xc002e7dc
c0020281:	6a 58                	push   $0x58
c0020283:	68 91 e4 02 c0       	push   $0xc002e491
c0020288:	e8 9b 92 00 00       	call   c0029528 <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c002028d:	83 ec 0c             	sub    $0xc,%esp
c0020290:	ff 75 08             	pushl  0x8(%ebp)
c0020293:	e8 1e ff ff ff       	call   c00201b6 <vtop>
c0020298:	83 c4 10             	add    $0x10,%esp
c002029b:	89 c2                	mov    %eax,%edx
c002029d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202a1:	74 07                	je     c00202aa <pte_create_kernel+0x56>
c00202a3:	b8 02 00 00 00       	mov    $0x2,%eax
c00202a8:	eb 05                	jmp    c00202af <pte_create_kernel+0x5b>
c00202aa:	b8 00 00 00 00       	mov    $0x0,%eax
c00202af:	09 d0                	or     %edx,%eax
c00202b1:	83 c8 01             	or     $0x1,%eax
}
c00202b4:	c9                   	leave  
c00202b5:	c3                   	ret    

c00202b6 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00202b6:	55                   	push   %ebp
c00202b7:	89 e5                	mov    %esp,%ebp
c00202b9:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202bc:	e8 ae 00 00 00       	call   c002036f <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202c1:	e8 0e 02 00 00       	call   c00204d4 <read_command_line>
c00202c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202c9:	83 ec 0c             	sub    $0xc,%esp
c00202cc:	ff 75 f4             	pushl  -0xc(%ebp)
c00202cf:	e8 30 03 00 00       	call   c0020604 <parse_options>
c00202d4:	83 c4 10             	add    $0x10,%esp
c00202d7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202da:	e8 cc 05 00 00       	call   c00208ab <thread_init>
  console_init ();  
c00202df:	e8 ac b2 00 00       	call   c002b590 <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c00202e4:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00202e9:	c1 e0 0c             	shl    $0xc,%eax
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c00202ec:	c1 e8 0a             	shr    $0xa,%eax
c00202ef:	83 ec 08             	sub    $0x8,%esp
c00202f2:	50                   	push   %eax
c00202f3:	68 b8 e4 02 c0       	push   $0xc002e4b8
c00202f8:	e8 6c 6e 00 00       	call   c0027169 <printf>
c00202fd:	83 c4 10             	add    $0x10,%esp

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020300:	a1 40 68 03 c0       	mov    0xc0036840,%eax
c0020305:	83 ec 0c             	sub    $0xc,%esp
c0020308:	50                   	push   %eax
c0020309:	e8 8c 2c 00 00       	call   c0022f9a <palloc_init>
c002030e:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020311:	e8 93 30 00 00       	call   c00233a9 <malloc_init>
  paging_init ();
c0020316:	e8 7e 00 00 00       	call   c0020399 <paging_init>
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c002031b:	e8 80 10 00 00       	call   c00213a0 <intr_init>
  timer_init ();
c0020320:	e8 35 38 00 00       	call   c0023b5a <timer_init>
  kbd_init ();
c0020325:	e8 25 3e 00 00       	call   c002414f <kbd_init>
  input_init ();
c002032a:	e8 9e 60 00 00       	call   c00263cd <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c002032f:	e8 16 06 00 00       	call   c002094a <thread_start>
  serial_init_queue ();
c0020334:	e8 de 45 00 00       	call   c0024917 <serial_init_queue>
  timer_calibrate ();
c0020339:	e8 4d 38 00 00       	call   c0023b8b <timer_calibrate>
  ide_init ();
  locate_block_devices ();
  filesys_init (format_filesys);
#endif

  printf ("Boot complete.\n");
c002033e:	83 ec 0c             	sub    $0xc,%esp
c0020341:	68 db e4 02 c0       	push   $0xc002e4db
c0020346:	e8 9e b3 00 00       	call   c002b6e9 <puts>
c002034b:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c002034e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020351:	8b 00                	mov    (%eax),%eax
c0020353:	85 c0                	test   %eax,%eax
c0020355:	74 0e                	je     c0020365 <pintos_init+0xaf>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020357:	83 ec 0c             	sub    $0xc,%esp
c002035a:	ff 75 f4             	pushl  -0xc(%ebp)
c002035d:	e8 3d 04 00 00       	call   c002079f <run_actions>
c0020362:	83 c4 10             	add    $0x10,%esp
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020365:	e8 61 68 00 00       	call   c0026bcb <shutdown>
  thread_exit ();
c002036a:	e8 74 09 00 00       	call   c0020ce3 <thread_exit>

c002036f <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c002036f:	55                   	push   %ebp
c0020370:	89 e5                	mov    %esp,%ebp
c0020372:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020375:	ba 85 8c 03 c0       	mov    $0xc0038c85,%edx
c002037a:	b8 c4 70 03 c0       	mov    $0xc00370c4,%eax
c002037f:	29 c2                	sub    %eax,%edx
c0020381:	89 d0                	mov    %edx,%eax
c0020383:	83 ec 04             	sub    $0x4,%esp
c0020386:	50                   	push   %eax
c0020387:	6a 00                	push   $0x0
c0020389:	68 c4 70 03 c0       	push   $0xc00370c4
c002038e:	e8 af 85 00 00       	call   c0028942 <memset>
c0020393:	83 c4 10             	add    $0x10,%esp
}
c0020396:	90                   	nop
c0020397:	c9                   	leave  
c0020398:	c3                   	ret    

c0020399 <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c0020399:	55                   	push   %ebp
c002039a:	89 e5                	mov    %esp,%ebp
c002039c:	53                   	push   %ebx
c002039d:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203a0:	83 ec 0c             	sub    $0xc,%esp
c00203a3:	6a 03                	push   $0x3
c00203a5:	e8 6a 2d 00 00       	call   c0023114 <palloc_get_page>
c00203aa:	83 c4 10             	add    $0x10,%esp
c00203ad:	a3 80 8c 03 c0       	mov    %eax,0xc0038c80
c00203b2:	a1 80 8c 03 c0       	mov    0xc0038c80,%eax
c00203b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00203ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00203c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00203c8:	e9 df 00 00 00       	jmp    c00204ac <paging_init+0x113>
    {
      uintptr_t paddr = page * PGSIZE;
c00203cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00203d0:	c1 e0 0c             	shl    $0xc,%eax
c00203d3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c00203d6:	83 ec 0c             	sub    $0xc,%esp
c00203d9:	ff 75 e8             	pushl  -0x18(%ebp)
c00203dc:	e8 9d fd ff ff       	call   c002017e <ptov>
c00203e1:	83 c4 10             	add    $0x10,%esp
c00203e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c00203e7:	83 ec 0c             	sub    $0xc,%esp
c00203ea:	ff 75 e4             	pushl  -0x1c(%ebp)
c00203ed:	e8 11 fe ff ff       	call   c0020203 <pd_no>
c00203f2:	83 c4 10             	add    $0x10,%esp
c00203f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c00203f8:	83 ec 0c             	sub    $0xc,%esp
c00203fb:	ff 75 e4             	pushl  -0x1c(%ebp)
c00203fe:	e8 f0 fd ff ff       	call   c00201f3 <pt_no>
c0020403:	83 c4 10             	add    $0x10,%esp
c0020406:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020409:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c0020410:	72 10                	jb     c0020422 <paging_init+0x89>
c0020412:	81 7d e4 00 30 03 c0 	cmpl   $0xc0033000,-0x1c(%ebp)
c0020419:	73 07                	jae    c0020422 <paging_init+0x89>
c002041b:	b8 01 00 00 00       	mov    $0x1,%eax
c0020420:	eb 05                	jmp    c0020427 <paging_init+0x8e>
c0020422:	b8 00 00 00 00       	mov    $0x0,%eax
c0020427:	88 45 db             	mov    %al,-0x25(%ebp)
c002042a:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c002042e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020431:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020438:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002043b:	01 d0                	add    %edx,%eax
c002043d:	8b 00                	mov    (%eax),%eax
c002043f:	85 c0                	test   %eax,%eax
c0020441:	75 30                	jne    c0020473 <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020443:	83 ec 0c             	sub    $0xc,%esp
c0020446:	6a 03                	push   $0x3
c0020448:	e8 c7 2c 00 00       	call   c0023114 <palloc_get_page>
c002044d:	83 c4 10             	add    $0x10,%esp
c0020450:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c0020453:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020456:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002045d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020460:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020463:	83 ec 0c             	sub    $0xc,%esp
c0020466:	ff 75 f4             	pushl  -0xc(%ebp)
c0020469:	e8 a0 fd ff ff       	call   c002020e <pde_create>
c002046e:	83 c4 10             	add    $0x10,%esp
c0020471:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c0020473:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020476:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002047d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020480:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020483:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c0020487:	85 c0                	test   %eax,%eax
c0020489:	0f 95 c0             	setne  %al
c002048c:	83 f0 01             	xor    $0x1,%eax
c002048f:	0f b6 c0             	movzbl %al,%eax
c0020492:	83 e0 01             	and    $0x1,%eax
c0020495:	0f b6 c0             	movzbl %al,%eax
c0020498:	83 ec 08             	sub    $0x8,%esp
c002049b:	50                   	push   %eax
c002049c:	ff 75 e4             	pushl  -0x1c(%ebp)
c002049f:	e8 b0 fd ff ff       	call   c0020254 <pte_create_kernel>
c00204a4:	83 c4 10             	add    $0x10,%esp
c00204a7:	89 03                	mov    %eax,(%ebx)
  for (page = 0; page < init_ram_pages; page++)
c00204a9:	ff 45 f0             	incl   -0x10(%ebp)
c00204ac:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c00204b1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00204b4:	0f 82 13 ff ff ff    	jb     c00203cd <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00204ba:	a1 80 8c 03 c0       	mov    0xc0038c80,%eax
c00204bf:	83 ec 0c             	sub    $0xc,%esp
c00204c2:	50                   	push   %eax
c00204c3:	e8 ee fc ff ff       	call   c00201b6 <vtop>
c00204c8:	83 c4 10             	add    $0x10,%esp
c00204cb:	0f 22 d8             	mov    %eax,%cr3
}
c00204ce:	90                   	nop
c00204cf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00204d2:	c9                   	leave  
c00204d3:	c3                   	ret    

c00204d4 <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c00204d4:	55                   	push   %ebp
c00204d5:	89 e5                	mov    %esp,%ebp
c00204d7:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00204da:	83 ec 0c             	sub    $0xc,%esp
c00204dd:	68 3a 7d 00 00       	push   $0x7d3a
c00204e2:	e8 97 fc ff ff       	call   c002017e <ptov>
c00204e7:	83 c4 10             	add    $0x10,%esp
c00204ea:	8b 00                	mov    (%eax),%eax
c00204ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c00204ef:	83 ec 0c             	sub    $0xc,%esp
c00204f2:	68 3e 7d 00 00       	push   $0x7d3e
c00204f7:	e8 82 fc ff ff       	call   c002017e <ptov>
c00204fc:	83 c4 10             	add    $0x10,%esp
c00204ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c0020502:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020505:	83 e8 80             	sub    $0xffffff80,%eax
c0020508:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c002050b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020512:	eb 4e                	jmp    c0020562 <read_command_line+0x8e>
    {
      if (p >= end)
c0020514:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020517:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002051a:	72 19                	jb     c0020535 <read_command_line+0x61>
        PANIC ("command line arguments overflow");
c002051c:	68 ec e4 02 c0       	push   $0xc002e4ec
c0020521:	68 f8 e7 02 c0       	push   $0xc002e7f8
c0020526:	68 d3 00 00 00       	push   $0xd3
c002052b:	68 0c e5 02 c0       	push   $0xc002e50c
c0020530:	e8 f3 8f 00 00       	call   c0029528 <debug_panic>

      argv[i] = p;
c0020535:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020538:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002053b:	89 14 85 e0 70 03 c0 	mov    %edx,-0x3ffc8f20(,%eax,4)
      p += strnlen (p, end - p) + 1;
c0020542:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0020545:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020548:	29 c2                	sub    %eax,%edx
c002054a:	89 d0                	mov    %edx,%eax
c002054c:	83 ec 08             	sub    $0x8,%esp
c002054f:	50                   	push   %eax
c0020550:	ff 75 f4             	pushl  -0xc(%ebp)
c0020553:	e8 90 84 00 00       	call   c00289e8 <strnlen>
c0020558:	83 c4 10             	add    $0x10,%esp
c002055b:	40                   	inc    %eax
c002055c:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < argc; i++) 
c002055f:	ff 45 f0             	incl   -0x10(%ebp)
c0020562:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020565:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020568:	7c aa                	jl     c0020514 <read_command_line+0x40>
    }
  argv[argc] = NULL;
c002056a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002056d:	c7 04 85 e0 70 03 c0 	movl   $0x0,-0x3ffc8f20(,%eax,4)
c0020574:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c0020578:	83 ec 0c             	sub    $0xc,%esp
c002057b:	68 21 e5 02 c0       	push   $0xc002e521
c0020580:	e8 e4 6b 00 00       	call   c0027169 <printf>
c0020585:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c0020588:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002058f:	eb 57                	jmp    c00205e8 <read_command_line+0x114>
    if (strchr (argv[i], ' ') == NULL)
c0020591:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020594:	8b 04 85 e0 70 03 c0 	mov    -0x3ffc8f20(,%eax,4),%eax
c002059b:	83 ec 08             	sub    $0x8,%esp
c002059e:	6a 20                	push   $0x20
c00205a0:	50                   	push   %eax
c00205a1:	e8 c1 80 00 00       	call   c0028667 <strchr>
c00205a6:	83 c4 10             	add    $0x10,%esp
c00205a9:	85 c0                	test   %eax,%eax
c00205ab:	75 1d                	jne    c00205ca <read_command_line+0xf6>
      printf (" %s", argv[i]);
c00205ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205b0:	8b 04 85 e0 70 03 c0 	mov    -0x3ffc8f20(,%eax,4),%eax
c00205b7:	83 ec 08             	sub    $0x8,%esp
c00205ba:	50                   	push   %eax
c00205bb:	68 36 e5 02 c0       	push   $0xc002e536
c00205c0:	e8 a4 6b 00 00       	call   c0027169 <printf>
c00205c5:	83 c4 10             	add    $0x10,%esp
c00205c8:	eb 1b                	jmp    c00205e5 <read_command_line+0x111>
    else
      printf (" '%s'", argv[i]);
c00205ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205cd:	8b 04 85 e0 70 03 c0 	mov    -0x3ffc8f20(,%eax,4),%eax
c00205d4:	83 ec 08             	sub    $0x8,%esp
c00205d7:	50                   	push   %eax
c00205d8:	68 3a e5 02 c0       	push   $0xc002e53a
c00205dd:	e8 87 6b 00 00       	call   c0027169 <printf>
c00205e2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00205e5:	ff 45 f0             	incl   -0x10(%ebp)
c00205e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205eb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00205ee:	7c a1                	jl     c0020591 <read_command_line+0xbd>
  printf ("\n");
c00205f0:	83 ec 0c             	sub    $0xc,%esp
c00205f3:	6a 0a                	push   $0xa
c00205f5:	e8 74 b1 00 00       	call   c002b76e <putchar>
c00205fa:	83 c4 10             	add    $0x10,%esp

  return argv;
c00205fd:	b8 e0 70 03 c0       	mov    $0xc00370e0,%eax
}
c0020602:	c9                   	leave  
c0020603:	c3                   	ret    

c0020604 <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c0020604:	55                   	push   %ebp
c0020605:	89 e5                	mov    %esp,%ebp
c0020607:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c002060a:	e9 1c 01 00 00       	jmp    c002072b <parse_options+0x127>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c002060f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020612:	8b 00                	mov    (%eax),%eax
c0020614:	83 ec 04             	sub    $0x4,%esp
c0020617:	8d 55 ec             	lea    -0x14(%ebp),%edx
c002061a:	52                   	push   %edx
c002061b:	68 40 e5 02 c0       	push   $0xc002e540
c0020620:	50                   	push   %eax
c0020621:	e8 0e 82 00 00       	call   c0028834 <strtok_r>
c0020626:	83 c4 10             	add    $0x10,%esp
c0020629:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c002062c:	83 ec 04             	sub    $0x4,%esp
c002062f:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0020632:	50                   	push   %eax
c0020633:	68 42 e5 02 c0       	push   $0xc002e542
c0020638:	6a 00                	push   $0x0
c002063a:	e8 f5 81 00 00       	call   c0028834 <strtok_r>
c002063f:	83 c4 10             	add    $0x10,%esp
c0020642:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c0020645:	83 ec 08             	sub    $0x8,%esp
c0020648:	68 43 e5 02 c0       	push   $0xc002e543
c002064d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020650:	e8 10 7f 00 00       	call   c0028565 <strcmp>
c0020655:	83 c4 10             	add    $0x10,%esp
c0020658:	85 c0                	test   %eax,%eax
c002065a:	75 0a                	jne    c0020666 <parse_options+0x62>
        usage ();
c002065c:	e8 22 02 00 00       	call   c0020883 <usage>
c0020661:	e9 c1 00 00 00       	jmp    c0020727 <parse_options+0x123>
      else if (!strcmp (name, "-q"))
c0020666:	83 ec 08             	sub    $0x8,%esp
c0020669:	68 46 e5 02 c0       	push   $0xc002e546
c002066e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020671:	e8 ef 7e 00 00       	call   c0028565 <strcmp>
c0020676:	83 c4 10             	add    $0x10,%esp
c0020679:	85 c0                	test   %eax,%eax
c002067b:	75 12                	jne    c002068f <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c002067d:	83 ec 0c             	sub    $0xc,%esp
c0020680:	6a 01                	push   $0x1
c0020682:	e8 68 65 00 00       	call   c0026bef <shutdown_configure>
c0020687:	83 c4 10             	add    $0x10,%esp
c002068a:	e9 98 00 00 00       	jmp    c0020727 <parse_options+0x123>
      else if (!strcmp (name, "-r"))
c002068f:	83 ec 08             	sub    $0x8,%esp
c0020692:	68 49 e5 02 c0       	push   $0xc002e549
c0020697:	ff 75 f4             	pushl  -0xc(%ebp)
c002069a:	e8 c6 7e 00 00       	call   c0028565 <strcmp>
c002069f:	83 c4 10             	add    $0x10,%esp
c00206a2:	85 c0                	test   %eax,%eax
c00206a4:	75 0f                	jne    c00206b5 <parse_options+0xb1>
        shutdown_configure (SHUTDOWN_REBOOT);
c00206a6:	83 ec 0c             	sub    $0xc,%esp
c00206a9:	6a 02                	push   $0x2
c00206ab:	e8 3f 65 00 00       	call   c0026bef <shutdown_configure>
c00206b0:	83 c4 10             	add    $0x10,%esp
c00206b3:	eb 72                	jmp    c0020727 <parse_options+0x123>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c00206b5:	83 ec 08             	sub    $0x8,%esp
c00206b8:	68 4c e5 02 c0       	push   $0xc002e54c
c00206bd:	ff 75 f4             	pushl  -0xc(%ebp)
c00206c0:	e8 a0 7e 00 00       	call   c0028565 <strcmp>
c00206c5:	83 c4 10             	add    $0x10,%esp
c00206c8:	85 c0                	test   %eax,%eax
c00206ca:	75 1c                	jne    c00206e8 <parse_options+0xe4>
        random_init (atoi (value));
c00206cc:	83 ec 0c             	sub    $0xc,%esp
c00206cf:	ff 75 f0             	pushl  -0x10(%ebp)
c00206d2:	e8 91 78 00 00       	call   c0027f68 <atoi>
c00206d7:	83 c4 10             	add    $0x10,%esp
c00206da:	83 ec 0c             	sub    $0xc,%esp
c00206dd:	50                   	push   %eax
c00206de:	e8 28 68 00 00       	call   c0026f0b <random_init>
c00206e3:	83 c4 10             	add    $0x10,%esp
c00206e6:	eb 3f                	jmp    c0020727 <parse_options+0x123>
      else if (!strcmp (name, "-mlfqs"))
c00206e8:	83 ec 08             	sub    $0x8,%esp
c00206eb:	68 50 e5 02 c0       	push   $0xc002e550
c00206f0:	ff 75 f4             	pushl  -0xc(%ebp)
c00206f3:	e8 6d 7e 00 00       	call   c0028565 <strcmp>
c00206f8:	83 c4 10             	add    $0x10,%esp
c00206fb:	85 c0                	test   %eax,%eax
c00206fd:	75 09                	jne    c0020708 <parse_options+0x104>
        thread_mlfqs = true;
c00206ff:	c6 05 84 8c 03 c0 01 	movb   $0x1,0xc0038c84
c0020706:	eb 1f                	jmp    c0020727 <parse_options+0x123>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c0020708:	83 ec 0c             	sub    $0xc,%esp
c002070b:	ff 75 f4             	pushl  -0xc(%ebp)
c002070e:	68 58 e5 02 c0       	push   $0xc002e558
c0020713:	68 0c e8 02 c0       	push   $0xc002e80c
c0020718:	68 0c 01 00 00       	push   $0x10c
c002071d:	68 0c e5 02 c0       	push   $0xc002e50c
c0020722:	e8 01 8e 00 00       	call   c0029528 <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c0020727:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c002072b:	8b 45 08             	mov    0x8(%ebp),%eax
c002072e:	8b 00                	mov    (%eax),%eax
c0020730:	85 c0                	test   %eax,%eax
c0020732:	74 0f                	je     c0020743 <parse_options+0x13f>
c0020734:	8b 45 08             	mov    0x8(%ebp),%eax
c0020737:	8b 00                	mov    (%eax),%eax
c0020739:	8a 00                	mov    (%eax),%al
c002073b:	3c 2d                	cmp    $0x2d,%al
c002073d:	0f 84 cc fe ff ff    	je     c002060f <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c0020743:	e8 f4 61 00 00       	call   c002693c <rtc_get_time>
c0020748:	83 ec 0c             	sub    $0xc,%esp
c002074b:	50                   	push   %eax
c002074c:	e8 ba 67 00 00       	call   c0026f0b <random_init>
c0020751:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c0020754:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0020757:	c9                   	leave  
c0020758:	c3                   	ret    

c0020759 <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020759:	55                   	push   %ebp
c002075a:	89 e5                	mov    %esp,%ebp
c002075c:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c002075f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020762:	8b 40 04             	mov    0x4(%eax),%eax
c0020765:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c0020768:	83 ec 08             	sub    $0x8,%esp
c002076b:	ff 75 f4             	pushl  -0xc(%ebp)
c002076e:	68 7e e5 02 c0       	push   $0xc002e57e
c0020773:	e8 f1 69 00 00       	call   c0027169 <printf>
c0020778:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c002077b:	83 ec 0c             	sub    $0xc,%esp
c002077e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020781:	e8 b8 b0 00 00       	call   c002b83e <run_test>
c0020786:	83 c4 10             	add    $0x10,%esp
#endif
  printf ("Execution of '%s' complete.\n", task);
c0020789:	83 ec 08             	sub    $0x8,%esp
c002078c:	ff 75 f4             	pushl  -0xc(%ebp)
c002078f:	68 8f e5 02 c0       	push   $0xc002e58f
c0020794:	e8 d0 69 00 00       	call   c0027169 <printf>
c0020799:	83 c4 10             	add    $0x10,%esp
}
c002079c:	90                   	nop
c002079d:	c9                   	leave  
c002079e:	c3                   	ret    

c002079f <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c002079f:	55                   	push   %ebp
c00207a0:	89 e5                	mov    %esp,%ebp
c00207a2:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c00207a5:	e9 c9 00 00 00       	jmp    c0020873 <run_actions+0xd4>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c00207aa:	c7 45 f4 20 e8 02 c0 	movl   $0xc002e820,-0xc(%ebp)
        if (a->name == NULL)
c00207b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207b4:	8b 00                	mov    (%eax),%eax
c00207b6:	85 c0                	test   %eax,%eax
c00207b8:	75 22                	jne    c00207dc <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00207ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00207bd:	8b 00                	mov    (%eax),%eax
c00207bf:	83 ec 0c             	sub    $0xc,%esp
c00207c2:	50                   	push   %eax
c00207c3:	68 ac e5 02 c0       	push   $0xc002e5ac
c00207c8:	68 38 e8 02 c0       	push   $0xc002e838
c00207cd:	68 4e 01 00 00       	push   $0x14e
c00207d2:	68 0c e5 02 c0       	push   $0xc002e50c
c00207d7:	e8 4c 8d 00 00       	call   c0029528 <debug_panic>
        else if (!strcmp (*argv, a->name))
c00207dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207df:	8b 10                	mov    (%eax),%edx
c00207e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00207e4:	8b 00                	mov    (%eax),%eax
c00207e6:	83 ec 08             	sub    $0x8,%esp
c00207e9:	52                   	push   %edx
c00207ea:	50                   	push   %eax
c00207eb:	e8 75 7d 00 00       	call   c0028565 <strcmp>
c00207f0:	83 c4 10             	add    $0x10,%esp
c00207f3:	85 c0                	test   %eax,%eax
c00207f5:	74 06                	je     c00207fd <run_actions+0x5e>
      for (a = actions; ; a++)
c00207f7:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
        if (a->name == NULL)
c00207fb:	eb b4                	jmp    c00207b1 <run_actions+0x12>
          break;
c00207fd:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c00207fe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0020805:	eb 44                	jmp    c002084b <run_actions+0xac>
        if (argv[i] == NULL)
c0020807:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002080a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020811:	8b 45 08             	mov    0x8(%ebp),%eax
c0020814:	01 d0                	add    %edx,%eax
c0020816:	8b 00                	mov    (%eax),%eax
c0020818:	85 c0                	test   %eax,%eax
c002081a:	75 2c                	jne    c0020848 <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c002081c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002081f:	8b 40 04             	mov    0x4(%eax),%eax
c0020822:	8d 50 ff             	lea    -0x1(%eax),%edx
c0020825:	8b 45 08             	mov    0x8(%ebp),%eax
c0020828:	8b 00                	mov    (%eax),%eax
c002082a:	83 ec 08             	sub    $0x8,%esp
c002082d:	52                   	push   %edx
c002082e:	50                   	push   %eax
c002082f:	68 d4 e5 02 c0       	push   $0xc002e5d4
c0020834:	68 38 e8 02 c0       	push   $0xc002e838
c0020839:	68 55 01 00 00       	push   $0x155
c002083e:	68 0c e5 02 c0       	push   $0xc002e50c
c0020843:	e8 e0 8c 00 00       	call   c0029528 <debug_panic>
      for (i = 1; i < a->argc; i++)
c0020848:	ff 45 f0             	incl   -0x10(%ebp)
c002084b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002084e:	8b 40 04             	mov    0x4(%eax),%eax
c0020851:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0020854:	7f b1                	jg     c0020807 <run_actions+0x68>

      /* Invoke action and advance. */
      a->function (argv);
c0020856:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020859:	8b 40 08             	mov    0x8(%eax),%eax
c002085c:	83 ec 0c             	sub    $0xc,%esp
c002085f:	ff 75 08             	pushl  0x8(%ebp)
c0020862:	ff d0                	call   *%eax
c0020864:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c0020867:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002086a:	8b 40 04             	mov    0x4(%eax),%eax
c002086d:	c1 e0 02             	shl    $0x2,%eax
c0020870:	01 45 08             	add    %eax,0x8(%ebp)
  while (*argv != NULL)
c0020873:	8b 45 08             	mov    0x8(%ebp),%eax
c0020876:	8b 00                	mov    (%eax),%eax
c0020878:	85 c0                	test   %eax,%eax
c002087a:	0f 85 2a ff ff ff    	jne    c00207aa <run_actions+0xb>
    }
  
}
c0020880:	90                   	nop
c0020881:	c9                   	leave  
c0020882:	c3                   	ret    

c0020883 <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c0020883:	55                   	push   %ebp
c0020884:	89 e5                	mov    %esp,%ebp
c0020886:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020889:	83 ec 0c             	sub    $0xc,%esp
c002088c:	68 f8 e5 02 c0       	push   $0xc002e5f8
c0020891:	e8 53 ae 00 00       	call   c002b6e9 <puts>
c0020896:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c0020899:	e8 e5 63 00 00       	call   c0026c83 <shutdown_power_off>

c002089e <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c002089e:	55                   	push   %ebp
c002089f:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00208a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00208a4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00208a9:	5d                   	pop    %ebp
c00208aa:	c3                   	ret    

c00208ab <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c00208ab:	55                   	push   %ebp
c00208ac:	89 e5                	mov    %esp,%ebp
c00208ae:	53                   	push   %ebx
c00208af:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00208b2:	e8 60 0a 00 00       	call   c0021317 <intr_get_level>
c00208b7:	85 c0                	test   %eax,%eax
c00208b9:	74 1e                	je     c00208d9 <thread_init+0x2e>
c00208bb:	83 ec 0c             	sub    $0xc,%esp
c00208be:	68 44 e8 02 c0       	push   $0xc002e844
c00208c3:	68 62 e8 02 c0       	push   $0xc002e862
c00208c8:	68 04 ea 02 c0       	push   $0xc002ea04
c00208cd:	6a 5a                	push   $0x5a
c00208cf:	68 79 e8 02 c0       	push   $0xc002e879
c00208d4:	e8 4f 8c 00 00       	call   c0029528 <debug_panic>

  lock_init (&tid_lock);
c00208d9:	83 ec 0c             	sub    $0xc,%esp
c00208dc:	68 10 72 03 c0       	push   $0xc0037210
c00208e1:	e8 5d 21 00 00       	call   c0022a43 <lock_init>
c00208e6:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c00208e9:	83 ec 0c             	sub    $0xc,%esp
c00208ec:	68 e8 71 03 c0       	push   $0xc00371e8
c00208f1:	e8 a3 8e 00 00       	call   c0029799 <list_init>
c00208f6:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c00208f9:	83 ec 0c             	sub    $0xc,%esp
c00208fc:	68 f8 71 03 c0       	push   $0xc00371f8
c0020901:	e8 93 8e 00 00       	call   c0029799 <list_init>
c0020906:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020909:	e8 19 06 00 00       	call   c0020f27 <running_thread>
c002090e:	a3 0c 72 03 c0       	mov    %eax,0xc003720c
  init_thread (initial_thread, "main", PRI_DEFAULT);
c0020913:	a1 0c 72 03 c0       	mov    0xc003720c,%eax
c0020918:	83 ec 04             	sub    $0x4,%esp
c002091b:	6a 1f                	push   $0x1f
c002091d:	68 90 e8 02 c0       	push   $0xc002e890
c0020922:	50                   	push   %eax
c0020923:	e8 3e 06 00 00       	call   c0020f66 <init_thread>
c0020928:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c002092b:	a1 0c 72 03 c0       	mov    0xc003720c,%eax
c0020930:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c0020937:	8b 1d 0c 72 03 c0    	mov    0xc003720c,%ebx
c002093d:	e8 52 09 00 00       	call   c0021294 <allocate_tid>
c0020942:	89 03                	mov    %eax,(%ebx)
}
c0020944:	90                   	nop
c0020945:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0020948:	c9                   	leave  
c0020949:	c3                   	ret    

c002094a <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c002094a:	55                   	push   %ebp
c002094b:	89 e5                	mov    %esp,%ebp
c002094d:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c0020950:	83 ec 08             	sub    $0x8,%esp
c0020953:	6a 00                	push   $0x0
c0020955:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020958:	50                   	push   %eax
c0020959:	e8 2d 1e 00 00       	call   c002278b <sema_init>
c002095e:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c0020961:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020964:	50                   	push   %eax
c0020965:	68 b0 0e 02 c0       	push   $0xc0020eb0
c002096a:	6a 00                	push   $0x0
c002096c:	68 95 e8 02 c0       	push   $0xc002e895
c0020971:	e8 d4 00 00 00       	call   c0020a4a <thread_create>
c0020976:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c0020979:	e8 d0 09 00 00       	call   c002134e <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c002097e:	83 ec 0c             	sub    $0xc,%esp
c0020981:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0020984:	50                   	push   %eax
c0020985:	e8 48 1e 00 00       	call   c00227d2 <sema_down>
c002098a:	83 c4 10             	add    $0x10,%esp
}
c002098d:	90                   	nop
c002098e:	c9                   	leave  
c002098f:	c3                   	ret    

c0020990 <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c0020990:	55                   	push   %ebp
c0020991:	89 e5                	mov    %esp,%ebp
c0020993:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c0020996:	e8 c8 02 00 00       	call   c0020c63 <thread_current>
c002099b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c002099e:	a1 08 72 03 c0       	mov    0xc0037208,%eax
c00209a3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00209a6:	75 1e                	jne    c00209c6 <thread_tick+0x36>
    idle_ticks++;
c00209a8:	a1 28 72 03 c0       	mov    0xc0037228,%eax
c00209ad:	8b 15 2c 72 03 c0    	mov    0xc003722c,%edx
c00209b3:	83 c0 01             	add    $0x1,%eax
c00209b6:	83 d2 00             	adc    $0x0,%edx
c00209b9:	a3 28 72 03 c0       	mov    %eax,0xc0037228
c00209be:	89 15 2c 72 03 c0    	mov    %edx,0xc003722c
c00209c4:	eb 1c                	jmp    c00209e2 <thread_tick+0x52>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c00209c6:	a1 30 72 03 c0       	mov    0xc0037230,%eax
c00209cb:	8b 15 34 72 03 c0    	mov    0xc0037234,%edx
c00209d1:	83 c0 01             	add    $0x1,%eax
c00209d4:	83 d2 00             	adc    $0x0,%edx
c00209d7:	a3 30 72 03 c0       	mov    %eax,0xc0037230
c00209dc:	89 15 34 72 03 c0    	mov    %edx,0xc0037234

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c00209e2:	a1 40 72 03 c0       	mov    0xc0037240,%eax
c00209e7:	40                   	inc    %eax
c00209e8:	a3 40 72 03 c0       	mov    %eax,0xc0037240
c00209ed:	a1 40 72 03 c0       	mov    0xc0037240,%eax
c00209f2:	83 f8 03             	cmp    $0x3,%eax
c00209f5:	76 05                	jbe    c00209fc <thread_tick+0x6c>
    intr_yield_on_return ();
c00209f7:	e8 67 0c 00 00       	call   c0021663 <intr_yield_on_return>
}
c00209fc:	90                   	nop
c00209fd:	c9                   	leave  
c00209fe:	c3                   	ret    

c00209ff <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c00209ff:	55                   	push   %ebp
c0020a00:	89 e5                	mov    %esp,%ebp
c0020a02:	57                   	push   %edi
c0020a03:	56                   	push   %esi
c0020a04:	53                   	push   %ebx
c0020a05:	83 ec 0c             	sub    $0xc,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020a08:	8b 35 38 72 03 c0    	mov    0xc0037238,%esi
c0020a0e:	8b 3d 3c 72 03 c0    	mov    0xc003723c,%edi
c0020a14:	8b 0d 30 72 03 c0    	mov    0xc0037230,%ecx
c0020a1a:	8b 1d 34 72 03 c0    	mov    0xc0037234,%ebx
c0020a20:	a1 28 72 03 c0       	mov    0xc0037228,%eax
c0020a25:	8b 15 2c 72 03 c0    	mov    0xc003722c,%edx
c0020a2b:	83 ec 04             	sub    $0x4,%esp
c0020a2e:	57                   	push   %edi
c0020a2f:	56                   	push   %esi
c0020a30:	53                   	push   %ebx
c0020a31:	51                   	push   %ecx
c0020a32:	52                   	push   %edx
c0020a33:	50                   	push   %eax
c0020a34:	68 9c e8 02 c0       	push   $0xc002e89c
c0020a39:	e8 2b 67 00 00       	call   c0027169 <printf>
c0020a3e:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c0020a41:	90                   	nop
c0020a42:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020a45:	5b                   	pop    %ebx
c0020a46:	5e                   	pop    %esi
c0020a47:	5f                   	pop    %edi
c0020a48:	5d                   	pop    %ebp
c0020a49:	c3                   	ret    

c0020a4a <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c0020a4a:	55                   	push   %ebp
c0020a4b:	89 e5                	mov    %esp,%ebp
c0020a4d:	83 ec 28             	sub    $0x28,%esp
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);
c0020a50:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020a54:	75 21                	jne    c0020a77 <thread_create+0x2d>
c0020a56:	83 ec 0c             	sub    $0xc,%esp
c0020a59:	68 d9 e8 02 c0       	push   $0xc002e8d9
c0020a5e:	68 62 e8 02 c0       	push   $0xc002e862
c0020a63:	68 10 ea 02 c0       	push   $0xc002ea10
c0020a68:	68 af 00 00 00       	push   $0xaf
c0020a6d:	68 79 e8 02 c0       	push   $0xc002e879
c0020a72:	e8 b1 8a 00 00       	call   c0029528 <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c0020a77:	83 ec 0c             	sub    $0xc,%esp
c0020a7a:	6a 02                	push   $0x2
c0020a7c:	e8 93 26 00 00       	call   c0023114 <palloc_get_page>
c0020a81:	83 c4 10             	add    $0x10,%esp
c0020a84:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020a87:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020a8b:	75 0a                	jne    c0020a97 <thread_create+0x4d>
    return TID_ERROR;
c0020a8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020a92:	e9 aa 00 00 00       	jmp    c0020b41 <thread_create+0xf7>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0020a97:	83 ec 04             	sub    $0x4,%esp
c0020a9a:	ff 75 0c             	pushl  0xc(%ebp)
c0020a9d:	ff 75 08             	pushl  0x8(%ebp)
c0020aa0:	ff 75 f4             	pushl  -0xc(%ebp)
c0020aa3:	e8 be 04 00 00       	call   c0020f66 <init_thread>
c0020aa8:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid ();
c0020aab:	e8 e4 07 00 00       	call   c0021294 <allocate_tid>
c0020ab0:	89 c2                	mov    %eax,%edx
c0020ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ab5:	89 10                	mov    %edx,(%eax)
c0020ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020aba:	8b 00                	mov    (%eax),%eax
c0020abc:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0020abf:	83 ec 08             	sub    $0x8,%esp
c0020ac2:	6a 0c                	push   $0xc
c0020ac4:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ac7:	e8 a0 05 00 00       	call   c002106c <alloc_frame>
c0020acc:	83 c4 10             	add    $0x10,%esp
c0020acf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  kf->eip = NULL;
c0020ad2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020ad5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020adb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020ade:	8b 55 10             	mov    0x10(%ebp),%edx
c0020ae1:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020ae4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020ae7:	8b 55 14             	mov    0x14(%ebp),%edx
c0020aea:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0020aed:	83 ec 08             	sub    $0x8,%esp
c0020af0:	6a 04                	push   $0x4
c0020af2:	ff 75 f4             	pushl  -0xc(%ebp)
c0020af5:	e8 72 05 00 00       	call   c002106c <alloc_frame>
c0020afa:	83 c4 10             	add    $0x10,%esp
c0020afd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0020b00:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020b03:	c7 00 e2 0e 02 c0    	movl   $0xc0020ee2,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0020b09:	83 ec 08             	sub    $0x8,%esp
c0020b0c:	6a 1c                	push   $0x1c
c0020b0e:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b11:	e8 56 05 00 00       	call   c002106c <alloc_frame>
c0020b16:	83 c4 10             	add    $0x10,%esp
c0020b19:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  sf->eip = switch_entry;
c0020b1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b1f:	c7 40 10 ed 12 02 c0 	movl   $0xc00212ed,0x10(%eax)
  sf->ebp = 0;
c0020b26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b29:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Add to run queue. */
  thread_unblock (t);
c0020b30:	83 ec 0c             	sub    $0xc,%esp
c0020b33:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b36:	e8 79 00 00 00       	call   c0020bb4 <thread_unblock>
c0020b3b:	83 c4 10             	add    $0x10,%esp

  return tid;
c0020b3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020b41:	c9                   	leave  
c0020b42:	c3                   	ret    

c0020b43 <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0020b43:	55                   	push   %ebp
c0020b44:	89 e5                	mov    %esp,%ebp
c0020b46:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020b49:	e8 0b 0b 00 00       	call   c0021659 <intr_context>
c0020b4e:	83 f0 01             	xor    $0x1,%eax
c0020b51:	84 c0                	test   %al,%al
c0020b53:	75 21                	jne    c0020b76 <thread_block+0x33>
c0020b55:	83 ec 0c             	sub    $0xc,%esp
c0020b58:	68 ea e8 02 c0       	push   $0xc002e8ea
c0020b5d:	68 62 e8 02 c0       	push   $0xc002e862
c0020b62:	68 20 ea 02 c0       	push   $0xc002ea20
c0020b67:	68 d8 00 00 00       	push   $0xd8
c0020b6c:	68 79 e8 02 c0       	push   $0xc002e879
c0020b71:	e8 b2 89 00 00       	call   c0029528 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020b76:	e8 9c 07 00 00       	call   c0021317 <intr_get_level>
c0020b7b:	85 c0                	test   %eax,%eax
c0020b7d:	74 21                	je     c0020ba0 <thread_block+0x5d>
c0020b7f:	83 ec 0c             	sub    $0xc,%esp
c0020b82:	68 44 e8 02 c0       	push   $0xc002e844
c0020b87:	68 62 e8 02 c0       	push   $0xc002e862
c0020b8c:	68 20 ea 02 c0       	push   $0xc002ea20
c0020b91:	68 d9 00 00 00       	push   $0xd9
c0020b96:	68 79 e8 02 c0       	push   $0xc002e879
c0020b9b:	e8 88 89 00 00       	call   c0029528 <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0020ba0:	e8 be 00 00 00       	call   c0020c63 <thread_current>
c0020ba5:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020bac:	e8 11 06 00 00       	call   c00211c2 <schedule>
}
c0020bb1:	90                   	nop
c0020bb2:	c9                   	leave  
c0020bb3:	c3                   	ret    

c0020bb4 <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020bb4:	55                   	push   %ebp
c0020bb5:	89 e5                	mov    %esp,%ebp
c0020bb7:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (is_thread (t));
c0020bba:	83 ec 0c             	sub    $0xc,%esp
c0020bbd:	ff 75 08             	pushl  0x8(%ebp)
c0020bc0:	e8 7a 03 00 00       	call   c0020f3f <is_thread>
c0020bc5:	83 c4 10             	add    $0x10,%esp
c0020bc8:	84 c0                	test   %al,%al
c0020bca:	75 21                	jne    c0020bed <thread_unblock+0x39>
c0020bcc:	83 ec 0c             	sub    $0xc,%esp
c0020bcf:	68 fb e8 02 c0       	push   $0xc002e8fb
c0020bd4:	68 62 e8 02 c0       	push   $0xc002e862
c0020bd9:	68 30 ea 02 c0       	push   $0xc002ea30
c0020bde:	68 ec 00 00 00       	push   $0xec
c0020be3:	68 79 e8 02 c0       	push   $0xc002e879
c0020be8:	e8 3b 89 00 00       	call   c0029528 <debug_panic>

  old_level = intr_disable ();
c0020bed:	e8 9a 07 00 00       	call   c002138c <intr_disable>
c0020bf2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c0020bf5:	8b 45 08             	mov    0x8(%ebp),%eax
c0020bf8:	8b 40 04             	mov    0x4(%eax),%eax
c0020bfb:	83 f8 02             	cmp    $0x2,%eax
c0020bfe:	74 21                	je     c0020c21 <thread_unblock+0x6d>
c0020c00:	83 ec 0c             	sub    $0xc,%esp
c0020c03:	68 09 e9 02 c0       	push   $0xc002e909
c0020c08:	68 62 e8 02 c0       	push   $0xc002e862
c0020c0d:	68 30 ea 02 c0       	push   $0xc002ea30
c0020c12:	68 ef 00 00 00       	push   $0xef
c0020c17:	68 79 e8 02 c0       	push   $0xc002e879
c0020c1c:	e8 07 89 00 00       	call   c0029528 <debug_panic>
  list_push_back (&ready_list, &t->elem);
c0020c21:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c24:	83 c0 28             	add    $0x28,%eax
c0020c27:	83 ec 08             	sub    $0x8,%esp
c0020c2a:	50                   	push   %eax
c0020c2b:	68 e8 71 03 c0       	push   $0xc00371e8
c0020c30:	e8 44 8f 00 00       	call   c0029b79 <list_push_back>
c0020c35:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c0020c38:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c3b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level (old_level);
c0020c42:	83 ec 0c             	sub    $0xc,%esp
c0020c45:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c48:	e8 e7 06 00 00       	call   c0021334 <intr_set_level>
c0020c4d:	83 c4 10             	add    $0x10,%esp
}
c0020c50:	90                   	nop
c0020c51:	c9                   	leave  
c0020c52:	c3                   	ret    

c0020c53 <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020c53:	55                   	push   %ebp
c0020c54:	89 e5                	mov    %esp,%ebp
c0020c56:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->name;
c0020c59:	e8 05 00 00 00       	call   c0020c63 <thread_current>
c0020c5e:	83 c0 08             	add    $0x8,%eax
}
c0020c61:	c9                   	leave  
c0020c62:	c3                   	ret    

c0020c63 <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0020c63:	55                   	push   %ebp
c0020c64:	89 e5                	mov    %esp,%ebp
c0020c66:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread ();
c0020c69:	e8 b9 02 00 00       	call   c0020f27 <running_thread>
c0020c6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020c71:	83 ec 0c             	sub    $0xc,%esp
c0020c74:	ff 75 f4             	pushl  -0xc(%ebp)
c0020c77:	e8 c3 02 00 00       	call   c0020f3f <is_thread>
c0020c7c:	83 c4 10             	add    $0x10,%esp
c0020c7f:	84 c0                	test   %al,%al
c0020c81:	75 21                	jne    c0020ca4 <thread_current+0x41>
c0020c83:	83 ec 0c             	sub    $0xc,%esp
c0020c86:	68 fb e8 02 c0       	push   $0xc002e8fb
c0020c8b:	68 62 e8 02 c0       	push   $0xc002e862
c0020c90:	68 40 ea 02 c0       	push   $0xc002ea40
c0020c95:	68 09 01 00 00       	push   $0x109
c0020c9a:	68 79 e8 02 c0       	push   $0xc002e879
c0020c9f:	e8 84 88 00 00       	call   c0029528 <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020ca4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ca7:	8b 40 04             	mov    0x4(%eax),%eax
c0020caa:	85 c0                	test   %eax,%eax
c0020cac:	74 21                	je     c0020ccf <thread_current+0x6c>
c0020cae:	83 ec 0c             	sub    $0xc,%esp
c0020cb1:	68 25 e9 02 c0       	push   $0xc002e925
c0020cb6:	68 62 e8 02 c0       	push   $0xc002e862
c0020cbb:	68 40 ea 02 c0       	push   $0xc002ea40
c0020cc0:	68 0a 01 00 00       	push   $0x10a
c0020cc5:	68 79 e8 02 c0       	push   $0xc002e879
c0020cca:	e8 59 88 00 00       	call   c0029528 <debug_panic>

  return t;
c0020ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0020cd2:	c9                   	leave  
c0020cd3:	c3                   	ret    

c0020cd4 <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020cd4:	55                   	push   %ebp
c0020cd5:	89 e5                	mov    %esp,%ebp
c0020cd7:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->tid;
c0020cda:	e8 84 ff ff ff       	call   c0020c63 <thread_current>
c0020cdf:	8b 00                	mov    (%eax),%eax
}
c0020ce1:	c9                   	leave  
c0020ce2:	c3                   	ret    

c0020ce3 <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c0020ce3:	55                   	push   %ebp
c0020ce4:	89 e5                	mov    %esp,%ebp
c0020ce6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020ce9:	e8 6b 09 00 00       	call   c0021659 <intr_context>
c0020cee:	83 f0 01             	xor    $0x1,%eax
c0020cf1:	84 c0                	test   %al,%al
c0020cf3:	75 21                	jne    c0020d16 <thread_exit+0x33>
c0020cf5:	83 ec 0c             	sub    $0xc,%esp
c0020cf8:	68 ea e8 02 c0       	push   $0xc002e8ea
c0020cfd:	68 62 e8 02 c0       	push   $0xc002e862
c0020d02:	68 50 ea 02 c0       	push   $0xc002ea50
c0020d07:	68 1b 01 00 00       	push   $0x11b
c0020d0c:	68 79 e8 02 c0       	push   $0xc002e879
c0020d11:	e8 12 88 00 00       	call   c0029528 <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0020d16:	e8 71 06 00 00       	call   c002138c <intr_disable>
  list_remove (&thread_current()->allelem);
c0020d1b:	e8 43 ff ff ff       	call   c0020c63 <thread_current>
c0020d20:	83 c0 20             	add    $0x20,%eax
c0020d23:	83 ec 0c             	sub    $0xc,%esp
c0020d26:	50                   	push   %eax
c0020d27:	e8 73 8e 00 00       	call   c0029b9f <list_remove>
c0020d2c:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c0020d2f:	e8 2f ff ff ff       	call   c0020c63 <thread_current>
c0020d34:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0020d3b:	e8 82 04 00 00       	call   c00211c2 <schedule>
  NOT_REACHED ();
c0020d40:	68 44 e9 02 c0       	push   $0xc002e944
c0020d45:	68 50 ea 02 c0       	push   $0xc002ea50
c0020d4a:	68 28 01 00 00       	push   $0x128
c0020d4f:	68 79 e8 02 c0       	push   $0xc002e879
c0020d54:	e8 cf 87 00 00       	call   c0029528 <debug_panic>

c0020d59 <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0020d59:	55                   	push   %ebp
c0020d5a:	89 e5                	mov    %esp,%ebp
c0020d5c:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c0020d5f:	e8 ff fe ff ff       	call   c0020c63 <thread_current>
c0020d64:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0020d67:	e8 ed 08 00 00       	call   c0021659 <intr_context>
c0020d6c:	83 f0 01             	xor    $0x1,%eax
c0020d6f:	84 c0                	test   %al,%al
c0020d71:	75 21                	jne    c0020d94 <thread_yield+0x3b>
c0020d73:	83 ec 0c             	sub    $0xc,%esp
c0020d76:	68 ea e8 02 c0       	push   $0xc002e8ea
c0020d7b:	68 62 e8 02 c0       	push   $0xc002e862
c0020d80:	68 5c ea 02 c0       	push   $0xc002ea5c
c0020d85:	68 33 01 00 00       	push   $0x133
c0020d8a:	68 79 e8 02 c0       	push   $0xc002e879
c0020d8f:	e8 94 87 00 00       	call   c0029528 <debug_panic>

  old_level = intr_disable ();
c0020d94:	e8 f3 05 00 00       	call   c002138c <intr_disable>
c0020d99:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread) 
c0020d9c:	a1 08 72 03 c0       	mov    0xc0037208,%eax
c0020da1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020da4:	74 17                	je     c0020dbd <thread_yield+0x64>
    list_push_back (&ready_list, &cur->elem);
c0020da6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020da9:	83 c0 28             	add    $0x28,%eax
c0020dac:	83 ec 08             	sub    $0x8,%esp
c0020daf:	50                   	push   %eax
c0020db0:	68 e8 71 03 c0       	push   $0xc00371e8
c0020db5:	e8 bf 8d 00 00       	call   c0029b79 <list_push_back>
c0020dba:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0020dbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020dc0:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c0020dc7:	e8 f6 03 00 00       	call   c00211c2 <schedule>
  intr_set_level (old_level);
c0020dcc:	83 ec 0c             	sub    $0xc,%esp
c0020dcf:	ff 75 f0             	pushl  -0x10(%ebp)
c0020dd2:	e8 5d 05 00 00       	call   c0021334 <intr_set_level>
c0020dd7:	83 c4 10             	add    $0x10,%esp
}
c0020dda:	90                   	nop
c0020ddb:	c9                   	leave  
c0020ddc:	c3                   	ret    

c0020ddd <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020ddd:	55                   	push   %ebp
c0020dde:	89 e5                	mov    %esp,%ebp
c0020de0:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020de3:	e8 2f 05 00 00       	call   c0021317 <intr_get_level>
c0020de8:	85 c0                	test   %eax,%eax
c0020dea:	74 21                	je     c0020e0d <thread_foreach+0x30>
c0020dec:	83 ec 0c             	sub    $0xc,%esp
c0020def:	68 44 e8 02 c0       	push   $0xc002e844
c0020df4:	68 62 e8 02 c0       	push   $0xc002e862
c0020df9:	68 6c ea 02 c0       	push   $0xc002ea6c
c0020dfe:	68 44 01 00 00       	push   $0x144
c0020e03:	68 79 e8 02 c0       	push   $0xc002e879
c0020e08:	e8 1b 87 00 00       	call   c0029528 <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e0d:	83 ec 0c             	sub    $0xc,%esp
c0020e10:	68 f8 71 03 c0       	push   $0xc00371f8
c0020e15:	e8 d4 89 00 00       	call   c00297ee <list_begin>
c0020e1a:	83 c4 10             	add    $0x10,%esp
c0020e1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020e20:	eb 2e                	jmp    c0020e50 <thread_foreach+0x73>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0020e22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020e25:	83 c0 04             	add    $0x4,%eax
c0020e28:	83 e8 24             	sub    $0x24,%eax
c0020e2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c0020e2e:	83 ec 08             	sub    $0x8,%esp
c0020e31:	ff 75 0c             	pushl  0xc(%ebp)
c0020e34:	ff 75 f0             	pushl  -0x10(%ebp)
c0020e37:	8b 45 08             	mov    0x8(%ebp),%eax
c0020e3a:	ff d0                	call   *%eax
c0020e3c:	83 c4 10             	add    $0x10,%esp
       e = list_next (e))
c0020e3f:	83 ec 0c             	sub    $0xc,%esp
c0020e42:	ff 75 f4             	pushl  -0xc(%ebp)
c0020e45:	e8 d6 89 00 00       	call   c0029820 <list_next>
c0020e4a:	83 c4 10             	add    $0x10,%esp
c0020e4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e50:	83 ec 0c             	sub    $0xc,%esp
c0020e53:	68 f8 71 03 c0       	push   $0xc00371f8
c0020e58:	e8 0d 8a 00 00       	call   c002986a <list_end>
c0020e5d:	83 c4 10             	add    $0x10,%esp
c0020e60:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0020e63:	75 bd                	jne    c0020e22 <thread_foreach+0x45>
    }
}
c0020e65:	90                   	nop
c0020e66:	c9                   	leave  
c0020e67:	c3                   	ret    

c0020e68 <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c0020e68:	55                   	push   %ebp
c0020e69:	89 e5                	mov    %esp,%ebp
c0020e6b:	83 ec 08             	sub    $0x8,%esp
  thread_current ()->priority = new_priority;
c0020e6e:	e8 f0 fd ff ff       	call   c0020c63 <thread_current>
c0020e73:	8b 55 08             	mov    0x8(%ebp),%edx
c0020e76:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c0020e79:	90                   	nop
c0020e7a:	c9                   	leave  
c0020e7b:	c3                   	ret    

c0020e7c <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c0020e7c:	55                   	push   %ebp
c0020e7d:	89 e5                	mov    %esp,%ebp
c0020e7f:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->priority;
c0020e82:	e8 dc fd ff ff       	call   c0020c63 <thread_current>
c0020e87:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0020e8a:	c9                   	leave  
c0020e8b:	c3                   	ret    

c0020e8c <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c0020e8c:	55                   	push   %ebp
c0020e8d:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
}
c0020e8f:	90                   	nop
c0020e90:	5d                   	pop    %ebp
c0020e91:	c3                   	ret    

c0020e92 <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0020e92:	55                   	push   %ebp
c0020e93:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020e95:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020e9a:	5d                   	pop    %ebp
c0020e9b:	c3                   	ret    

c0020e9c <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0020e9c:	55                   	push   %ebp
c0020e9d:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020e9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020ea4:	5d                   	pop    %ebp
c0020ea5:	c3                   	ret    

c0020ea6 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c0020ea6:	55                   	push   %ebp
c0020ea7:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020ea9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020eae:	5d                   	pop    %ebp
c0020eaf:	c3                   	ret    

c0020eb0 <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c0020eb0:	55                   	push   %ebp
c0020eb1:	89 e5                	mov    %esp,%ebp
c0020eb3:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c0020eb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0020eb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c0020ebc:	e8 a2 fd ff ff       	call   c0020c63 <thread_current>
c0020ec1:	a3 08 72 03 c0       	mov    %eax,0xc0037208
  sema_up (idle_started);
c0020ec6:	83 ec 0c             	sub    $0xc,%esp
c0020ec9:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ecc:	e8 0b 1a 00 00       	call   c00228dc <sema_up>
c0020ed1:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c0020ed4:	e8 b3 04 00 00       	call   c002138c <intr_disable>
      thread_block ();
c0020ed9:	e8 65 fc ff ff       	call   c0020b43 <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c0020ede:	fb                   	sti    
c0020edf:	f4                   	hlt    
      intr_disable ();
c0020ee0:	eb f2                	jmp    c0020ed4 <idle+0x24>

c0020ee2 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c0020ee2:	55                   	push   %ebp
c0020ee3:	89 e5                	mov    %esp,%ebp
c0020ee5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (function != NULL);
c0020ee8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020eec:	75 21                	jne    c0020f0f <kernel_thread+0x2d>
c0020eee:	83 ec 0c             	sub    $0xc,%esp
c0020ef1:	68 d9 e8 02 c0       	push   $0xc002e8d9
c0020ef6:	68 62 e8 02 c0       	push   $0xc002e862
c0020efb:	68 7c ea 02 c0       	push   $0xc002ea7c
c0020f00:	68 a5 01 00 00       	push   $0x1a5
c0020f05:	68 79 e8 02 c0       	push   $0xc002e879
c0020f0a:	e8 19 86 00 00       	call   c0029528 <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c0020f0f:	e8 3a 04 00 00       	call   c002134e <intr_enable>
  function (aux);       /* Execute the thread function. */
c0020f14:	83 ec 0c             	sub    $0xc,%esp
c0020f17:	ff 75 0c             	pushl  0xc(%ebp)
c0020f1a:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f1d:	ff d0                	call   *%eax
c0020f1f:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c0020f22:	e8 bc fd ff ff       	call   c0020ce3 <thread_exit>

c0020f27 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0020f27:	55                   	push   %ebp
c0020f28:	89 e5                	mov    %esp,%ebp
c0020f2a:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c0020f2d:	89 e0                	mov    %esp,%eax
c0020f2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c0020f32:	ff 75 fc             	pushl  -0x4(%ebp)
c0020f35:	e8 64 f9 ff ff       	call   c002089e <pg_round_down>
c0020f3a:	83 c4 04             	add    $0x4,%esp
}
c0020f3d:	c9                   	leave  
c0020f3e:	c3                   	ret    

c0020f3f <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c0020f3f:	55                   	push   %ebp
c0020f40:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c0020f42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f46:	74 14                	je     c0020f5c <is_thread+0x1d>
c0020f48:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f4b:	8b 40 30             	mov    0x30(%eax),%eax
c0020f4e:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0020f53:	75 07                	jne    c0020f5c <is_thread+0x1d>
c0020f55:	b8 01 00 00 00       	mov    $0x1,%eax
c0020f5a:	eb 05                	jmp    c0020f61 <is_thread+0x22>
c0020f5c:	b8 00 00 00 00       	mov    $0x0,%eax
c0020f61:	83 e0 01             	and    $0x1,%eax
}
c0020f64:	5d                   	pop    %ebp
c0020f65:	c3                   	ret    

c0020f66 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0020f66:	55                   	push   %ebp
c0020f67:	89 e5                	mov    %esp,%ebp
c0020f69:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (t != NULL);
c0020f6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0020f70:	75 21                	jne    c0020f93 <init_thread+0x2d>
c0020f72:	83 ec 0c             	sub    $0xc,%esp
c0020f75:	68 66 e9 02 c0       	push   $0xc002e966
c0020f7a:	68 62 e8 02 c0       	push   $0xc002e862
c0020f7f:	68 8c ea 02 c0       	push   $0xc002ea8c
c0020f84:	68 c8 01 00 00       	push   $0x1c8
c0020f89:	68 79 e8 02 c0       	push   $0xc002e879
c0020f8e:	e8 95 85 00 00       	call   c0029528 <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c0020f93:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020f97:	78 06                	js     c0020f9f <init_thread+0x39>
c0020f99:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c0020f9d:	7e 21                	jle    c0020fc0 <init_thread+0x5a>
c0020f9f:	83 ec 0c             	sub    $0xc,%esp
c0020fa2:	68 70 e9 02 c0       	push   $0xc002e970
c0020fa7:	68 62 e8 02 c0       	push   $0xc002e862
c0020fac:	68 8c ea 02 c0       	push   $0xc002ea8c
c0020fb1:	68 c9 01 00 00       	push   $0x1c9
c0020fb6:	68 79 e8 02 c0       	push   $0xc002e879
c0020fbb:	e8 68 85 00 00       	call   c0029528 <debug_panic>
  ASSERT (name != NULL);
c0020fc0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0020fc4:	75 21                	jne    c0020fe7 <init_thread+0x81>
c0020fc6:	83 ec 0c             	sub    $0xc,%esp
c0020fc9:	68 9b e9 02 c0       	push   $0xc002e99b
c0020fce:	68 62 e8 02 c0       	push   $0xc002e862
c0020fd3:	68 8c ea 02 c0       	push   $0xc002ea8c
c0020fd8:	68 ca 01 00 00       	push   $0x1ca
c0020fdd:	68 79 e8 02 c0       	push   $0xc002e879
c0020fe2:	e8 41 85 00 00       	call   c0029528 <debug_panic>

  memset (t, 0, sizeof *t);
c0020fe7:	83 ec 04             	sub    $0x4,%esp
c0020fea:	6a 34                	push   $0x34
c0020fec:	6a 00                	push   $0x0
c0020fee:	ff 75 08             	pushl  0x8(%ebp)
c0020ff1:	e8 4c 79 00 00       	call   c0028942 <memset>
c0020ff6:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c0020ff9:	8b 45 08             	mov    0x8(%ebp),%eax
c0020ffc:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c0021003:	8b 45 08             	mov    0x8(%ebp),%eax
c0021006:	83 c0 08             	add    $0x8,%eax
c0021009:	83 ec 04             	sub    $0x4,%esp
c002100c:	6a 10                	push   $0x10
c002100e:	ff 75 0c             	pushl  0xc(%ebp)
c0021011:	50                   	push   %eax
c0021012:	e8 fe 79 00 00       	call   c0028a15 <strlcpy>
c0021017:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c002101a:	8b 45 08             	mov    0x8(%ebp),%eax
c002101d:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0021023:	8b 45 08             	mov    0x8(%ebp),%eax
c0021026:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c0021029:	8b 45 08             	mov    0x8(%ebp),%eax
c002102c:	8b 55 10             	mov    0x10(%ebp),%edx
c002102f:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021032:	8b 45 08             	mov    0x8(%ebp),%eax
c0021035:	c7 40 30 4b bf 6a cd 	movl   $0xcd6abf4b,0x30(%eax)

  old_level = intr_disable ();
c002103c:	e8 4b 03 00 00       	call   c002138c <intr_disable>
c0021041:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_push_back (&all_list, &t->allelem);
c0021044:	8b 45 08             	mov    0x8(%ebp),%eax
c0021047:	83 c0 20             	add    $0x20,%eax
c002104a:	83 ec 08             	sub    $0x8,%esp
c002104d:	50                   	push   %eax
c002104e:	68 f8 71 03 c0       	push   $0xc00371f8
c0021053:	e8 21 8b 00 00       	call   c0029b79 <list_push_back>
c0021058:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c002105b:	83 ec 0c             	sub    $0xc,%esp
c002105e:	ff 75 f4             	pushl  -0xc(%ebp)
c0021061:	e8 ce 02 00 00       	call   c0021334 <intr_set_level>
c0021066:	83 c4 10             	add    $0x10,%esp
}
c0021069:	90                   	nop
c002106a:	c9                   	leave  
c002106b:	c3                   	ret    

c002106c <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c002106c:	55                   	push   %ebp
c002106d:	89 e5                	mov    %esp,%ebp
c002106f:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c0021072:	ff 75 08             	pushl  0x8(%ebp)
c0021075:	e8 c5 fe ff ff       	call   c0020f3f <is_thread>
c002107a:	83 c4 04             	add    $0x4,%esp
c002107d:	84 c0                	test   %al,%al
c002107f:	75 21                	jne    c00210a2 <alloc_frame+0x36>
c0021081:	83 ec 0c             	sub    $0xc,%esp
c0021084:	68 fb e8 02 c0       	push   $0xc002e8fb
c0021089:	68 62 e8 02 c0       	push   $0xc002e862
c002108e:	68 98 ea 02 c0       	push   $0xc002ea98
c0021093:	68 de 01 00 00       	push   $0x1de
c0021098:	68 79 e8 02 c0       	push   $0xc002e879
c002109d:	e8 86 84 00 00       	call   c0029528 <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c00210a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00210a5:	83 e0 03             	and    $0x3,%eax
c00210a8:	85 c0                	test   %eax,%eax
c00210aa:	74 21                	je     c00210cd <alloc_frame+0x61>
c00210ac:	83 ec 0c             	sub    $0xc,%esp
c00210af:	68 a8 e9 02 c0       	push   $0xc002e9a8
c00210b4:	68 62 e8 02 c0       	push   $0xc002e862
c00210b9:	68 98 ea 02 c0       	push   $0xc002ea98
c00210be:	68 df 01 00 00       	push   $0x1df
c00210c3:	68 79 e8 02 c0       	push   $0xc002e879
c00210c8:	e8 5b 84 00 00       	call   c0029528 <debug_panic>

  t->stack -= size;
c00210cd:	8b 45 08             	mov    0x8(%ebp),%eax
c00210d0:	8b 40 18             	mov    0x18(%eax),%eax
c00210d3:	8b 55 0c             	mov    0xc(%ebp),%edx
c00210d6:	f7 da                	neg    %edx
c00210d8:	01 c2                	add    %eax,%edx
c00210da:	8b 45 08             	mov    0x8(%ebp),%eax
c00210dd:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c00210e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00210e3:	8b 40 18             	mov    0x18(%eax),%eax
}
c00210e6:	c9                   	leave  
c00210e7:	c3                   	ret    

c00210e8 <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c00210e8:	55                   	push   %ebp
c00210e9:	89 e5                	mov    %esp,%ebp
c00210eb:	83 ec 08             	sub    $0x8,%esp
  if (list_empty (&ready_list))
c00210ee:	83 ec 0c             	sub    $0xc,%esp
c00210f1:	68 e8 71 03 c0       	push   $0xc00371e8
c00210f6:	e8 25 8c 00 00       	call   c0029d20 <list_empty>
c00210fb:	83 c4 10             	add    $0x10,%esp
c00210fe:	84 c0                	test   %al,%al
c0021100:	74 07                	je     c0021109 <next_thread_to_run+0x21>
    return idle_thread;
c0021102:	a1 08 72 03 c0       	mov    0xc0037208,%eax
c0021107:	eb 16                	jmp    c002111f <next_thread_to_run+0x37>
  else
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0021109:	83 ec 0c             	sub    $0xc,%esp
c002110c:	68 e8 71 03 c0       	push   $0xc00371e8
c0021111:	e8 e2 8a 00 00       	call   c0029bf8 <list_pop_front>
c0021116:	83 c4 10             	add    $0x10,%esp
c0021119:	83 c0 04             	add    $0x4,%eax
c002111c:	83 e8 2c             	sub    $0x2c,%eax
}
c002111f:	c9                   	leave  
c0021120:	c3                   	ret    

c0021121 <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c0021121:	55                   	push   %ebp
c0021122:	89 e5                	mov    %esp,%ebp
c0021124:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c0021127:	e8 fb fd ff ff       	call   c0020f27 <running_thread>
c002112c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c002112f:	e8 e3 01 00 00       	call   c0021317 <intr_get_level>
c0021134:	85 c0                	test   %eax,%eax
c0021136:	74 21                	je     c0021159 <thread_schedule_tail+0x38>
c0021138:	83 ec 0c             	sub    $0xc,%esp
c002113b:	68 44 e8 02 c0       	push   $0xc002e844
c0021140:	68 62 e8 02 c0       	push   $0xc002e862
c0021145:	68 a4 ea 02 c0       	push   $0xc002eaa4
c002114a:	68 08 02 00 00       	push   $0x208
c002114f:	68 79 e8 02 c0       	push   $0xc002e879
c0021154:	e8 cf 83 00 00       	call   c0029528 <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c0021159:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002115c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c0021163:	c7 05 40 72 03 c0 00 	movl   $0x0,0xc0037240
c002116a:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c002116d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021171:	74 4c                	je     c00211bf <thread_schedule_tail+0x9e>
c0021173:	8b 45 08             	mov    0x8(%ebp),%eax
c0021176:	8b 40 04             	mov    0x4(%eax),%eax
c0021179:	83 f8 03             	cmp    $0x3,%eax
c002117c:	75 41                	jne    c00211bf <thread_schedule_tail+0x9e>
c002117e:	a1 0c 72 03 c0       	mov    0xc003720c,%eax
c0021183:	39 45 08             	cmp    %eax,0x8(%ebp)
c0021186:	74 37                	je     c00211bf <thread_schedule_tail+0x9e>
    {
      ASSERT (prev != cur);
c0021188:	8b 45 08             	mov    0x8(%ebp),%eax
c002118b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002118e:	75 21                	jne    c00211b1 <thread_schedule_tail+0x90>
c0021190:	83 ec 0c             	sub    $0xc,%esp
c0021193:	68 c6 e9 02 c0       	push   $0xc002e9c6
c0021198:	68 62 e8 02 c0       	push   $0xc002e862
c002119d:	68 a4 ea 02 c0       	push   $0xc002eaa4
c00211a2:	68 1c 02 00 00       	push   $0x21c
c00211a7:	68 79 e8 02 c0       	push   $0xc002e879
c00211ac:	e8 77 83 00 00       	call   c0029528 <debug_panic>
      palloc_free_page (prev);
c00211b1:	83 ec 0c             	sub    $0xc,%esp
c00211b4:	ff 75 08             	pushl  0x8(%ebp)
c00211b7:	e8 b0 20 00 00       	call   c002326c <palloc_free_page>
c00211bc:	83 c4 10             	add    $0x10,%esp
    }
}
c00211bf:	90                   	nop
c00211c0:	c9                   	leave  
c00211c1:	c3                   	ret    

c00211c2 <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c00211c2:	55                   	push   %ebp
c00211c3:	89 e5                	mov    %esp,%ebp
c00211c5:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c00211c8:	e8 5a fd ff ff       	call   c0020f27 <running_thread>
c00211cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c00211d0:	e8 13 ff ff ff       	call   c00210e8 <next_thread_to_run>
c00211d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c00211d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c00211df:	e8 33 01 00 00       	call   c0021317 <intr_get_level>
c00211e4:	85 c0                	test   %eax,%eax
c00211e6:	74 21                	je     c0021209 <schedule+0x47>
c00211e8:	83 ec 0c             	sub    $0xc,%esp
c00211eb:	68 44 e8 02 c0       	push   $0xc002e844
c00211f0:	68 62 e8 02 c0       	push   $0xc002e862
c00211f5:	68 bc ea 02 c0       	push   $0xc002eabc
c00211fa:	68 2f 02 00 00       	push   $0x22f
c00211ff:	68 79 e8 02 c0       	push   $0xc002e879
c0021204:	e8 1f 83 00 00       	call   c0029528 <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0021209:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002120c:	8b 40 04             	mov    0x4(%eax),%eax
c002120f:	85 c0                	test   %eax,%eax
c0021211:	75 21                	jne    c0021234 <schedule+0x72>
c0021213:	83 ec 0c             	sub    $0xc,%esp
c0021216:	68 d2 e9 02 c0       	push   $0xc002e9d2
c002121b:	68 62 e8 02 c0       	push   $0xc002e862
c0021220:	68 bc ea 02 c0       	push   $0xc002eabc
c0021225:	68 30 02 00 00       	push   $0x230
c002122a:	68 79 e8 02 c0       	push   $0xc002e879
c002122f:	e8 f4 82 00 00       	call   c0029528 <debug_panic>
  ASSERT (is_thread (next));
c0021234:	83 ec 0c             	sub    $0xc,%esp
c0021237:	ff 75 ec             	pushl  -0x14(%ebp)
c002123a:	e8 00 fd ff ff       	call   c0020f3f <is_thread>
c002123f:	83 c4 10             	add    $0x10,%esp
c0021242:	84 c0                	test   %al,%al
c0021244:	75 21                	jne    c0021267 <schedule+0xa5>
c0021246:	83 ec 0c             	sub    $0xc,%esp
c0021249:	68 f0 e9 02 c0       	push   $0xc002e9f0
c002124e:	68 62 e8 02 c0       	push   $0xc002e862
c0021253:	68 bc ea 02 c0       	push   $0xc002eabc
c0021258:	68 31 02 00 00       	push   $0x231
c002125d:	68 79 e8 02 c0       	push   $0xc002e879
c0021262:	e8 c1 82 00 00       	call   c0029528 <debug_panic>

  if (cur != next)
c0021267:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002126a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002126d:	74 14                	je     c0021283 <schedule+0xc1>
    prev = switch_threads (cur, next);
c002126f:	83 ec 08             	sub    $0x8,%esp
c0021272:	ff 75 ec             	pushl  -0x14(%ebp)
c0021275:	ff 75 f0             	pushl  -0x10(%ebp)
c0021278:	e8 53 00 00 00       	call   c00212d0 <switch_threads>
c002127d:	83 c4 10             	add    $0x10,%esp
c0021280:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c0021283:	83 ec 0c             	sub    $0xc,%esp
c0021286:	ff 75 f4             	pushl  -0xc(%ebp)
c0021289:	e8 93 fe ff ff       	call   c0021121 <thread_schedule_tail>
c002128e:	83 c4 10             	add    $0x10,%esp
}
c0021291:	90                   	nop
c0021292:	c9                   	leave  
c0021293:	c3                   	ret    

c0021294 <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c0021294:	55                   	push   %ebp
c0021295:	89 e5                	mov    %esp,%ebp
c0021297:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c002129a:	83 ec 0c             	sub    $0xc,%esp
c002129d:	68 10 72 03 c0       	push   $0xc0037210
c00212a2:	e8 e9 17 00 00       	call   c0022a90 <lock_acquire>
c00212a7:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c00212aa:	a1 48 68 03 c0       	mov    0xc0036848,%eax
c00212af:	8d 50 01             	lea    0x1(%eax),%edx
c00212b2:	89 15 48 68 03 c0    	mov    %edx,0xc0036848
c00212b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c00212bb:	83 ec 0c             	sub    $0xc,%esp
c00212be:	68 10 72 03 c0       	push   $0xc0037210
c00212c3:	e8 08 19 00 00       	call   c0022bd0 <lock_release>
c00212c8:	83 c4 10             	add    $0x10,%esp

  return tid;
c00212cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00212ce:	c9                   	leave  
c00212cf:	c3                   	ret    

c00212d0 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c00212d0:	53                   	push   %ebx
	pushl %ebp
c00212d1:	55                   	push   %ebp
	pushl %esi
c00212d2:	56                   	push   %esi
	pushl %edi
c00212d3:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c00212d4:	8b 15 44 68 03 c0    	mov    0xc0036844,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c00212da:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c00212de:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c00212e1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c00212e5:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c00212e8:	5f                   	pop    %edi
	popl %esi
c00212e9:	5e                   	pop    %esi
	popl %ebp
c00212ea:	5d                   	pop    %ebp
	popl %ebx
c00212eb:	5b                   	pop    %ebx
        ret
c00212ec:	c3                   	ret    

c00212ed <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c00212ed:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c00212f0:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c00212f1:	e8 2b fe ff ff       	call   c0021121 <thread_schedule_tail>
	addl $4, %esp
c00212f6:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c00212f9:	c3                   	ret    

c00212fa <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c00212fa:	55                   	push   %ebp
c00212fb:	89 e5                	mov    %esp,%ebp
c00212fd:	83 ec 08             	sub    $0x8,%esp
c0021300:	8b 45 08             	mov    0x8(%ebp),%eax
c0021303:	8b 55 0c             	mov    0xc(%ebp),%edx
c0021306:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c002130a:	88 55 f8             	mov    %dl,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002130d:	8a 45 f8             	mov    -0x8(%ebp),%al
c0021310:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0021313:	ee                   	out    %al,(%dx)
}
c0021314:	90                   	nop
c0021315:	c9                   	leave  
c0021316:	c3                   	ret    

c0021317 <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c0021317:	55                   	push   %ebp
c0021318:	89 e5                	mov    %esp,%ebp
c002131a:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c002131d:	9c                   	pushf  
c002131e:	58                   	pop    %eax
c002131f:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021322:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0021325:	25 00 02 00 00       	and    $0x200,%eax
c002132a:	85 c0                	test   %eax,%eax
c002132c:	0f 95 c0             	setne  %al
c002132f:	0f b6 c0             	movzbl %al,%eax
}
c0021332:	c9                   	leave  
c0021333:	c3                   	ret    

c0021334 <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c0021334:	55                   	push   %ebp
c0021335:	89 e5                	mov    %esp,%ebp
c0021337:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c002133a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c002133e:	75 07                	jne    c0021347 <intr_set_level+0x13>
c0021340:	e8 09 00 00 00       	call   c002134e <intr_enable>
c0021345:	eb 05                	jmp    c002134c <intr_set_level+0x18>
c0021347:	e8 40 00 00 00       	call   c002138c <intr_disable>
}
c002134c:	c9                   	leave  
c002134d:	c3                   	ret    

c002134e <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c002134e:	55                   	push   %ebp
c002134f:	89 e5                	mov    %esp,%ebp
c0021351:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c0021354:	e8 be ff ff ff       	call   c0021317 <intr_get_level>
c0021359:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c002135c:	e8 f8 02 00 00       	call   c0021659 <intr_context>
c0021361:	83 f0 01             	xor    $0x1,%eax
c0021364:	84 c0                	test   %al,%al
c0021366:	75 1e                	jne    c0021386 <intr_enable+0x38>
c0021368:	83 ec 0c             	sub    $0xc,%esp
c002136b:	68 c8 ea 02 c0       	push   $0xc002eac8
c0021370:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021375:	68 d8 ee 02 c0       	push   $0xc002eed8
c002137a:	6a 5b                	push   $0x5b
c002137c:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021381:	e8 a2 81 00 00       	call   c0029528 <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c0021386:	fb                   	sti    

  return old_level;
c0021387:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002138a:	c9                   	leave  
c002138b:	c3                   	ret    

c002138c <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c002138c:	55                   	push   %ebp
c002138d:	89 e5                	mov    %esp,%ebp
c002138f:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c0021392:	e8 80 ff ff ff       	call   c0021317 <intr_get_level>
c0021397:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c002139a:	fa                   	cli    

  return old_level;
c002139b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002139e:	c9                   	leave  
c002139f:	c3                   	ret    

c00213a0 <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c00213a0:	55                   	push   %ebp
c00213a1:	89 e5                	mov    %esp,%ebp
c00213a3:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c00213a6:	e8 f2 02 00 00       	call   c002169d <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c00213ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00213b2:	eb 2c                	jmp    c00213e0 <intr_init+0x40>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c00213b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00213b7:	8b 04 85 4c 68 03 c0 	mov    -0x3ffc97b4(,%eax,4),%eax
c00213be:	83 ec 08             	sub    $0x8,%esp
c00213c1:	6a 00                	push   $0x0
c00213c3:	50                   	push   %eax
c00213c4:	e8 ce 04 00 00       	call   c0021897 <make_intr_gate>
c00213c9:	83 c4 10             	add    $0x10,%esp
c00213cc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00213cf:	89 04 cd 60 72 03 c0 	mov    %eax,-0x3ffc8da0(,%ecx,8)
c00213d6:	89 14 cd 64 72 03 c0 	mov    %edx,-0x3ffc8d9c(,%ecx,8)
  for (i = 0; i < INTR_CNT; i++)
c00213dd:	ff 45 f4             	incl   -0xc(%ebp)
c00213e0:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c00213e7:	7e cb                	jle    c00213b4 <intr_init+0x14>

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c00213e9:	83 ec 08             	sub    $0x8,%esp
c00213ec:	68 60 72 03 c0       	push   $0xc0037260
c00213f1:	68 ff 07 00 00       	push   $0x7ff
c00213f6:	e8 d2 04 00 00       	call   c00218cd <make_idtr_operand>
c00213fb:	83 c4 10             	add    $0x10,%esp
c00213fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0021401:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021404:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021408:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002140f:	eb 11                	jmp    c0021422 <intr_init+0x82>
    intr_names[i] = "unknown";
c0021411:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021414:	c7 04 85 60 7e 03 c0 	movl   $0xc002eb0a,-0x3ffc81a0(,%eax,4)
c002141b:	0a eb 02 c0 
  for (i = 0; i < INTR_CNT; i++)
c002141f:	ff 45 f4             	incl   -0xc(%ebp)
c0021422:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021429:	7e e6                	jle    c0021411 <intr_init+0x71>
  intr_names[0] = "#DE Divide Error";
c002142b:	c7 05 60 7e 03 c0 12 	movl   $0xc002eb12,0xc0037e60
c0021432:	eb 02 c0 
  intr_names[1] = "#DB Debug Exception";
c0021435:	c7 05 64 7e 03 c0 23 	movl   $0xc002eb23,0xc0037e64
c002143c:	eb 02 c0 
  intr_names[2] = "NMI Interrupt";
c002143f:	c7 05 68 7e 03 c0 37 	movl   $0xc002eb37,0xc0037e68
c0021446:	eb 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c0021449:	c7 05 6c 7e 03 c0 45 	movl   $0xc002eb45,0xc0037e6c
c0021450:	eb 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c0021453:	c7 05 70 7e 03 c0 5e 	movl   $0xc002eb5e,0xc0037e70
c002145a:	eb 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c002145d:	c7 05 74 7e 03 c0 78 	movl   $0xc002eb78,0xc0037e74
c0021464:	eb 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c0021467:	c7 05 78 7e 03 c0 9b 	movl   $0xc002eb9b,0xc0037e78
c002146e:	eb 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c0021471:	c7 05 7c 7e 03 c0 b8 	movl   $0xc002ebb8,0xc0037e7c
c0021478:	eb 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c002147b:	c7 05 80 7e 03 c0 db 	movl   $0xc002ebdb,0xc0037e80
c0021482:	eb 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c0021485:	c7 05 84 7e 03 c0 f6 	movl   $0xc002ebf6,0xc0037e84
c002148c:	eb 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c002148f:	c7 05 88 7e 03 c0 12 	movl   $0xc002ec12,0xc0037e88
c0021496:	ec 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c0021499:	c7 05 8c 7e 03 c0 2c 	movl   $0xc002ec2c,0xc0037e8c
c00214a0:	ec 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c00214a3:	c7 05 90 7e 03 c0 44 	movl   $0xc002ec44,0xc0037e90
c00214aa:	ec 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c00214ad:	c7 05 94 7e 03 c0 60 	movl   $0xc002ec60,0xc0037e94
c00214b4:	ec 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c00214b7:	c7 05 98 7e 03 c0 81 	movl   $0xc002ec81,0xc0037e98
c00214be:	ec 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c00214c1:	c7 05 a0 7e 03 c0 9c 	movl   $0xc002ec9c,0xc0037ea0
c00214c8:	ec 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c00214cb:	c7 05 a4 7e 03 c0 bd 	movl   $0xc002ecbd,0xc0037ea4
c00214d2:	ec 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c00214d5:	c7 05 a8 7e 03 c0 db 	movl   $0xc002ecdb,0xc0037ea8
c00214dc:	ec 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c00214df:	c7 05 ac 7e 03 c0 f8 	movl   $0xc002ecf8,0xc0037eac
c00214e6:	ec 02 c0 
}
c00214e9:	90                   	nop
c00214ea:	c9                   	leave  
c00214eb:	c3                   	ret    

c00214ec <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c00214ec:	55                   	push   %ebp
c00214ed:	89 e5                	mov    %esp,%ebp
c00214ef:	53                   	push   %ebx
c00214f0:	83 ec 14             	sub    $0x14,%esp
c00214f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00214f6:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c00214f9:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00214fd:	8b 04 85 60 7a 03 c0 	mov    -0x3ffc85a0(,%eax,4),%eax
c0021504:	85 c0                	test   %eax,%eax
c0021506:	74 21                	je     c0021529 <register_handler+0x3d>
c0021508:	83 ec 0c             	sub    $0xc,%esp
c002150b:	68 1a ed 02 c0       	push   $0xc002ed1a
c0021510:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021515:	68 e4 ee 02 c0       	push   $0xc002eee4
c002151a:	68 a8 00 00 00       	push   $0xa8
c002151f:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021524:	e8 ff 7f 00 00       	call   c0029528 <debug_panic>
  if (level == INTR_ON)
c0021529:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c002152d:	75 2e                	jne    c002155d <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c002152f:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021533:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021537:	8b 04 85 4c 68 03 c0 	mov    -0x3ffc97b4(,%eax,4),%eax
c002153e:	83 ec 08             	sub    $0x8,%esp
c0021541:	ff 75 0c             	pushl  0xc(%ebp)
c0021544:	50                   	push   %eax
c0021545:	e8 68 03 00 00       	call   c00218b2 <make_trap_gate>
c002154a:	83 c4 10             	add    $0x10,%esp
c002154d:	89 04 dd 60 72 03 c0 	mov    %eax,-0x3ffc8da0(,%ebx,8)
c0021554:	89 14 dd 64 72 03 c0 	mov    %edx,-0x3ffc8d9c(,%ebx,8)
c002155b:	eb 2c                	jmp    c0021589 <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c002155d:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c0021561:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021565:	8b 04 85 4c 68 03 c0 	mov    -0x3ffc97b4(,%eax,4),%eax
c002156c:	83 ec 08             	sub    $0x8,%esp
c002156f:	ff 75 0c             	pushl  0xc(%ebp)
c0021572:	50                   	push   %eax
c0021573:	e8 1f 03 00 00       	call   c0021897 <make_intr_gate>
c0021578:	83 c4 10             	add    $0x10,%esp
c002157b:	89 04 dd 60 72 03 c0 	mov    %eax,-0x3ffc8da0(,%ebx,8)
c0021582:	89 14 dd 64 72 03 c0 	mov    %edx,-0x3ffc8d9c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c0021589:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002158d:	8b 55 14             	mov    0x14(%ebp),%edx
c0021590:	89 14 85 60 7a 03 c0 	mov    %edx,-0x3ffc85a0(,%eax,4)
  intr_names[vec_no] = name;
c0021597:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002159b:	8b 55 18             	mov    0x18(%ebp),%edx
c002159e:	89 14 85 60 7e 03 c0 	mov    %edx,-0x3ffc81a0(,%eax,4)
}
c00215a5:	90                   	nop
c00215a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00215a9:	c9                   	leave  
c00215aa:	c3                   	ret    

c00215ab <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c00215ab:	55                   	push   %ebp
c00215ac:	89 e5                	mov    %esp,%ebp
c00215ae:	83 ec 18             	sub    $0x18,%esp
c00215b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00215b4:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c00215b7:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c00215bb:	76 06                	jbe    c00215c3 <intr_register_ext+0x18>
c00215bd:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c00215c1:	76 21                	jbe    c00215e4 <intr_register_ext+0x39>
c00215c3:	83 ec 0c             	sub    $0xc,%esp
c00215c6:	68 38 ed 02 c0       	push   $0xc002ed38
c00215cb:	68 d9 ea 02 c0       	push   $0xc002ead9
c00215d0:	68 f8 ee 02 c0       	push   $0xc002eef8
c00215d5:	68 b8 00 00 00       	push   $0xb8
c00215da:	68 f0 ea 02 c0       	push   $0xc002eaf0
c00215df:	e8 44 7f 00 00       	call   c0029528 <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c00215e4:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00215e8:	83 ec 0c             	sub    $0xc,%esp
c00215eb:	ff 75 10             	pushl  0x10(%ebp)
c00215ee:	ff 75 0c             	pushl  0xc(%ebp)
c00215f1:	6a 00                	push   $0x0
c00215f3:	6a 00                	push   $0x0
c00215f5:	50                   	push   %eax
c00215f6:	e8 f1 fe ff ff       	call   c00214ec <register_handler>
c00215fb:	83 c4 20             	add    $0x20,%esp
}
c00215fe:	90                   	nop
c00215ff:	c9                   	leave  
c0021600:	c3                   	ret    

c0021601 <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c0021601:	55                   	push   %ebp
c0021602:	89 e5                	mov    %esp,%ebp
c0021604:	83 ec 18             	sub    $0x18,%esp
c0021607:	8b 45 08             	mov    0x8(%ebp),%eax
c002160a:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c002160d:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021611:	76 27                	jbe    c002163a <intr_register_int+0x39>
c0021613:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021617:	77 21                	ja     c002163a <intr_register_int+0x39>
c0021619:	83 ec 0c             	sub    $0xc,%esp
c002161c:	68 5c ed 02 c0       	push   $0xc002ed5c
c0021621:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021626:	68 0c ef 02 c0       	push   $0xc002ef0c
c002162b:	68 cd 00 00 00       	push   $0xcd
c0021630:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021635:	e8 ee 7e 00 00       	call   c0029528 <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c002163a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002163e:	83 ec 0c             	sub    $0xc,%esp
c0021641:	ff 75 18             	pushl  0x18(%ebp)
c0021644:	ff 75 14             	pushl  0x14(%ebp)
c0021647:	ff 75 10             	pushl  0x10(%ebp)
c002164a:	ff 75 0c             	pushl  0xc(%ebp)
c002164d:	50                   	push   %eax
c002164e:	e8 99 fe ff ff       	call   c00214ec <register_handler>
c0021653:	83 c4 20             	add    $0x20,%esp
}
c0021656:	90                   	nop
c0021657:	c9                   	leave  
c0021658:	c3                   	ret    

c0021659 <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c0021659:	55                   	push   %ebp
c002165a:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c002165c:	a0 60 86 03 c0       	mov    0xc0038660,%al
}
c0021661:	5d                   	pop    %ebp
c0021662:	c3                   	ret    

c0021663 <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c0021663:	55                   	push   %ebp
c0021664:	89 e5                	mov    %esp,%ebp
c0021666:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c0021669:	e8 eb ff ff ff       	call   c0021659 <intr_context>
c002166e:	84 c0                	test   %al,%al
c0021670:	75 21                	jne    c0021693 <intr_yield_on_return+0x30>
c0021672:	83 ec 0c             	sub    $0xc,%esp
c0021675:	68 7b ed 02 c0       	push   $0xc002ed7b
c002167a:	68 d9 ea 02 c0       	push   $0xc002ead9
c002167f:	68 20 ef 02 c0       	push   $0xc002ef20
c0021684:	68 e0 00 00 00       	push   $0xe0
c0021689:	68 f0 ea 02 c0       	push   $0xc002eaf0
c002168e:	e8 95 7e 00 00       	call   c0029528 <debug_panic>
  yield_on_return = true;
c0021693:	c6 05 61 86 03 c0 01 	movb   $0x1,0xc0038661
}
c002169a:	90                   	nop
c002169b:	c9                   	leave  
c002169c:	c3                   	ret    

c002169d <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c002169d:	55                   	push   %ebp
c002169e:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c00216a0:	68 ff 00 00 00       	push   $0xff
c00216a5:	6a 21                	push   $0x21
c00216a7:	e8 4e fc ff ff       	call   c00212fa <outb>
c00216ac:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c00216af:	68 ff 00 00 00       	push   $0xff
c00216b4:	68 a1 00 00 00       	push   $0xa1
c00216b9:	e8 3c fc ff ff       	call   c00212fa <outb>
c00216be:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c00216c1:	6a 11                	push   $0x11
c00216c3:	6a 20                	push   $0x20
c00216c5:	e8 30 fc ff ff       	call   c00212fa <outb>
c00216ca:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c00216cd:	6a 20                	push   $0x20
c00216cf:	6a 21                	push   $0x21
c00216d1:	e8 24 fc ff ff       	call   c00212fa <outb>
c00216d6:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c00216d9:	6a 04                	push   $0x4
c00216db:	6a 21                	push   $0x21
c00216dd:	e8 18 fc ff ff       	call   c00212fa <outb>
c00216e2:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c00216e5:	6a 01                	push   $0x1
c00216e7:	6a 21                	push   $0x21
c00216e9:	e8 0c fc ff ff       	call   c00212fa <outb>
c00216ee:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c00216f1:	6a 11                	push   $0x11
c00216f3:	68 a0 00 00 00       	push   $0xa0
c00216f8:	e8 fd fb ff ff       	call   c00212fa <outb>
c00216fd:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c0021700:	6a 28                	push   $0x28
c0021702:	68 a1 00 00 00       	push   $0xa1
c0021707:	e8 ee fb ff ff       	call   c00212fa <outb>
c002170c:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c002170f:	6a 02                	push   $0x2
c0021711:	68 a1 00 00 00       	push   $0xa1
c0021716:	e8 df fb ff ff       	call   c00212fa <outb>
c002171b:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c002171e:	6a 01                	push   $0x1
c0021720:	68 a1 00 00 00       	push   $0xa1
c0021725:	e8 d0 fb ff ff       	call   c00212fa <outb>
c002172a:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c002172d:	6a 00                	push   $0x0
c002172f:	6a 21                	push   $0x21
c0021731:	e8 c4 fb ff ff       	call   c00212fa <outb>
c0021736:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c0021739:	6a 00                	push   $0x0
c002173b:	68 a1 00 00 00       	push   $0xa1
c0021740:	e8 b5 fb ff ff       	call   c00212fa <outb>
c0021745:	83 c4 08             	add    $0x8,%esp
}
c0021748:	90                   	nop
c0021749:	c9                   	leave  
c002174a:	c3                   	ret    

c002174b <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c002174b:	55                   	push   %ebp
c002174c:	89 e5                	mov    %esp,%ebp
c002174e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c0021751:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0021755:	7e 06                	jle    c002175d <pic_end_of_interrupt+0x12>
c0021757:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c002175b:	7e 21                	jle    c002177e <pic_end_of_interrupt+0x33>
c002175d:	83 ec 0c             	sub    $0xc,%esp
c0021760:	68 8b ed 02 c0       	push   $0xc002ed8b
c0021765:	68 d9 ea 02 c0       	push   $0xc002ead9
c002176a:	68 38 ef 02 c0       	push   $0xc002ef38
c002176f:	68 0b 01 00 00       	push   $0x10b
c0021774:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021779:	e8 aa 7d 00 00       	call   c0029528 <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c002177e:	83 ec 08             	sub    $0x8,%esp
c0021781:	6a 20                	push   $0x20
c0021783:	6a 20                	push   $0x20
c0021785:	e8 70 fb ff ff       	call   c00212fa <outb>
c002178a:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c002178d:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c0021791:	7e 12                	jle    c00217a5 <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c0021793:	83 ec 08             	sub    $0x8,%esp
c0021796:	6a 20                	push   $0x20
c0021798:	68 a0 00 00 00       	push   $0xa0
c002179d:	e8 58 fb ff ff       	call   c00212fa <outb>
c00217a2:	83 c4 10             	add    $0x10,%esp
}
c00217a5:	90                   	nop
c00217a6:	c9                   	leave  
c00217a7:	c3                   	ret    

c00217a8 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c00217a8:	55                   	push   %ebp
c00217a9:	89 e5                	mov    %esp,%ebp
c00217ab:	57                   	push   %edi
c00217ac:	56                   	push   %esi
c00217ad:	53                   	push   %ebx
c00217ae:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c00217b1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00217b5:	75 21                	jne    c00217d8 <make_gate+0x30>
c00217b7:	83 ec 0c             	sub    $0xc,%esp
c00217ba:	68 a5 ed 02 c0       	push   $0xc002eda5
c00217bf:	68 d9 ea 02 c0       	push   $0xc002ead9
c00217c4:	68 50 ef 02 c0       	push   $0xc002ef50
c00217c9:	68 2a 01 00 00       	push   $0x12a
c00217ce:	68 f0 ea 02 c0       	push   $0xc002eaf0
c00217d3:	e8 50 7d 00 00       	call   c0029528 <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c00217d8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00217dc:	78 06                	js     c00217e4 <make_gate+0x3c>
c00217de:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c00217e2:	7e 21                	jle    c0021805 <make_gate+0x5d>
c00217e4:	83 ec 0c             	sub    $0xc,%esp
c00217e7:	68 b6 ed 02 c0       	push   $0xc002edb6
c00217ec:	68 d9 ea 02 c0       	push   $0xc002ead9
c00217f1:	68 50 ef 02 c0       	push   $0xc002ef50
c00217f6:	68 2b 01 00 00       	push   $0x12b
c00217fb:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021800:	e8 23 7d 00 00       	call   c0029528 <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021805:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0021809:	78 06                	js     c0021811 <make_gate+0x69>
c002180b:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c002180f:	7e 21                	jle    c0021832 <make_gate+0x8a>
c0021811:	83 ec 0c             	sub    $0xc,%esp
c0021814:	68 cb ed 02 c0       	push   $0xc002edcb
c0021819:	68 d9 ea 02 c0       	push   $0xc002ead9
c002181e:	68 50 ef 02 c0       	push   $0xc002ef50
c0021823:	68 2c 01 00 00       	push   $0x12c
c0021828:	68 f0 ea 02 c0       	push   $0xc002eaf0
c002182d:	e8 f6 7c 00 00       	call   c0029528 <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c0021832:	8b 45 08             	mov    0x8(%ebp),%eax
c0021835:	0f b7 c0             	movzwl %ax,%eax
c0021838:	0d 00 00 08 00       	or     $0x80000,%eax
c002183d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c0021840:	8b 45 08             	mov    0x8(%ebp),%eax
c0021843:	25 00 00 ff ff       	and    $0xffff0000,%eax
c0021848:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c002184a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002184d:	c1 e0 0d             	shl    $0xd,%eax
c0021850:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c0021852:	8b 45 10             	mov    0x10(%ebp),%eax
c0021855:	c1 e0 08             	shl    $0x8,%eax
c0021858:	09 d0                	or     %edx,%eax
  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c002185a:	80 cc 80             	or     $0x80,%ah
c002185d:	89 45 e0             	mov    %eax,-0x20(%ebp)

  return e0 | ((uint64_t) e1 << 32);
c0021860:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c0021863:	bf 00 00 00 00       	mov    $0x0,%edi
c0021868:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002186b:	ba 00 00 00 00       	mov    $0x0,%edx
c0021870:	89 c2                	mov    %eax,%edx
c0021872:	b8 00 00 00 00       	mov    $0x0,%eax
c0021877:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002187a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c002187d:	89 f0                	mov    %esi,%eax
c002187f:	0b 45 d0             	or     -0x30(%ebp),%eax
c0021882:	89 c1                	mov    %eax,%ecx
c0021884:	89 f8                	mov    %edi,%eax
c0021886:	0b 45 d4             	or     -0x2c(%ebp),%eax
c0021889:	89 c3                	mov    %eax,%ebx
c002188b:	89 c8                	mov    %ecx,%eax
c002188d:	89 da                	mov    %ebx,%edx
}
c002188f:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0021892:	5b                   	pop    %ebx
c0021893:	5e                   	pop    %esi
c0021894:	5f                   	pop    %edi
c0021895:	5d                   	pop    %ebp
c0021896:	c3                   	ret    

c0021897 <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c0021897:	55                   	push   %ebp
c0021898:	89 e5                	mov    %esp,%ebp
c002189a:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c002189d:	83 ec 04             	sub    $0x4,%esp
c00218a0:	6a 0e                	push   $0xe
c00218a2:	ff 75 0c             	pushl  0xc(%ebp)
c00218a5:	ff 75 08             	pushl  0x8(%ebp)
c00218a8:	e8 fb fe ff ff       	call   c00217a8 <make_gate>
c00218ad:	83 c4 10             	add    $0x10,%esp
}
c00218b0:	c9                   	leave  
c00218b1:	c3                   	ret    

c00218b2 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c00218b2:	55                   	push   %ebp
c00218b3:	89 e5                	mov    %esp,%ebp
c00218b5:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c00218b8:	83 ec 04             	sub    $0x4,%esp
c00218bb:	6a 0f                	push   $0xf
c00218bd:	ff 75 0c             	pushl  0xc(%ebp)
c00218c0:	ff 75 08             	pushl  0x8(%ebp)
c00218c3:	e8 e0 fe ff ff       	call   c00217a8 <make_gate>
c00218c8:	83 c4 10             	add    $0x10,%esp
}
c00218cb:	c9                   	leave  
c00218cc:	c3                   	ret    

c00218cd <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c00218cd:	55                   	push   %ebp
c00218ce:	89 e5                	mov    %esp,%ebp
c00218d0:	57                   	push   %edi
c00218d1:	56                   	push   %esi
c00218d2:	53                   	push   %ebx
c00218d3:	83 ec 14             	sub    $0x14,%esp
c00218d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00218d9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c00218dd:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00218e1:	89 c6                	mov    %eax,%esi
c00218e3:	bf 00 00 00 00       	mov    $0x0,%edi
c00218e8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00218eb:	ba 00 00 00 00       	mov    $0x0,%edx
c00218f0:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c00218f4:	c1 e0 10             	shl    $0x10,%eax
c00218f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00218fa:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00218fd:	89 f0                	mov    %esi,%eax
c00218ff:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021902:	89 c1                	mov    %eax,%ecx
c0021904:	89 f8                	mov    %edi,%eax
c0021906:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0021909:	89 c3                	mov    %eax,%ebx
c002190b:	89 c8                	mov    %ecx,%eax
c002190d:	89 da                	mov    %ebx,%edx
}
c002190f:	83 c4 14             	add    $0x14,%esp
c0021912:	5b                   	pop    %ebx
c0021913:	5e                   	pop    %esi
c0021914:	5f                   	pop    %edi
c0021915:	5d                   	pop    %ebp
c0021916:	c3                   	ret    

c0021917 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021917:	55                   	push   %ebp
c0021918:	89 e5                	mov    %esp,%ebp
c002191a:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c002191d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021920:	8b 40 30             	mov    0x30(%eax),%eax
c0021923:	83 f8 1f             	cmp    $0x1f,%eax
c0021926:	76 12                	jbe    c002193a <intr_handler+0x23>
c0021928:	8b 45 08             	mov    0x8(%ebp),%eax
c002192b:	8b 40 30             	mov    0x30(%eax),%eax
c002192e:	83 f8 2f             	cmp    $0x2f,%eax
c0021931:	77 07                	ja     c002193a <intr_handler+0x23>
c0021933:	b8 01 00 00 00       	mov    $0x1,%eax
c0021938:	eb 05                	jmp    c002193f <intr_handler+0x28>
c002193a:	b8 00 00 00 00       	mov    $0x0,%eax
c002193f:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021942:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c0021946:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c002194a:	74 65                	je     c00219b1 <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c002194c:	e8 c6 f9 ff ff       	call   c0021317 <intr_get_level>
c0021951:	85 c0                	test   %eax,%eax
c0021953:	74 21                	je     c0021976 <intr_handler+0x5f>
c0021955:	83 ec 0c             	sub    $0xc,%esp
c0021958:	68 e3 ed 02 c0       	push   $0xc002ede3
c002195d:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021962:	68 5c ef 02 c0       	push   $0xc002ef5c
c0021967:	68 65 01 00 00       	push   $0x165
c002196c:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021971:	e8 b2 7b 00 00       	call   c0029528 <debug_panic>
      ASSERT (!intr_context ());
c0021976:	e8 de fc ff ff       	call   c0021659 <intr_context>
c002197b:	83 f0 01             	xor    $0x1,%eax
c002197e:	84 c0                	test   %al,%al
c0021980:	75 21                	jne    c00219a3 <intr_handler+0x8c>
c0021982:	83 ec 0c             	sub    $0xc,%esp
c0021985:	68 c8 ea 02 c0       	push   $0xc002eac8
c002198a:	68 d9 ea 02 c0       	push   $0xc002ead9
c002198f:	68 5c ef 02 c0       	push   $0xc002ef5c
c0021994:	68 66 01 00 00       	push   $0x166
c0021999:	68 f0 ea 02 c0       	push   $0xc002eaf0
c002199e:	e8 85 7b 00 00       	call   c0029528 <debug_panic>

      in_external_intr = true;
c00219a3:	c6 05 60 86 03 c0 01 	movb   $0x1,0xc0038660
      yield_on_return = false;
c00219aa:	c6 05 61 86 03 c0 00 	movb   $0x0,0xc0038661
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c00219b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00219b4:	8b 40 30             	mov    0x30(%eax),%eax
c00219b7:	8b 04 85 60 7a 03 c0 	mov    -0x3ffc85a0(,%eax,4),%eax
c00219be:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c00219c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00219c5:	74 10                	je     c00219d7 <intr_handler+0xc0>
    handler (frame);
c00219c7:	83 ec 0c             	sub    $0xc,%esp
c00219ca:	ff 75 08             	pushl  0x8(%ebp)
c00219cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00219d0:	ff d0                	call   *%eax
c00219d2:	83 c4 10             	add    $0x10,%esp
c00219d5:	eb 24                	jmp    c00219fb <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c00219d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00219da:	8b 40 30             	mov    0x30(%eax),%eax
c00219dd:	83 f8 27             	cmp    $0x27,%eax
c00219e0:	74 19                	je     c00219fb <intr_handler+0xe4>
c00219e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00219e5:	8b 40 30             	mov    0x30(%eax),%eax
c00219e8:	83 f8 2f             	cmp    $0x2f,%eax
c00219eb:	74 0e                	je     c00219fb <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c00219ed:	83 ec 0c             	sub    $0xc,%esp
c00219f0:	ff 75 08             	pushl  0x8(%ebp)
c00219f3:	e8 87 00 00 00       	call   c0021a7f <unexpected_interrupt>
c00219f8:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c00219fb:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c00219ff:	74 7b                	je     c0021a7c <intr_handler+0x165>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021a01:	e8 11 f9 ff ff       	call   c0021317 <intr_get_level>
c0021a06:	85 c0                	test   %eax,%eax
c0021a08:	74 21                	je     c0021a2b <intr_handler+0x114>
c0021a0a:	83 ec 0c             	sub    $0xc,%esp
c0021a0d:	68 e3 ed 02 c0       	push   $0xc002ede3
c0021a12:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021a17:	68 5c ef 02 c0       	push   $0xc002ef5c
c0021a1c:	68 7c 01 00 00       	push   $0x17c
c0021a21:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021a26:	e8 fd 7a 00 00       	call   c0029528 <debug_panic>
      ASSERT (intr_context ());
c0021a2b:	e8 29 fc ff ff       	call   c0021659 <intr_context>
c0021a30:	84 c0                	test   %al,%al
c0021a32:	75 21                	jne    c0021a55 <intr_handler+0x13e>
c0021a34:	83 ec 0c             	sub    $0xc,%esp
c0021a37:	68 7b ed 02 c0       	push   $0xc002ed7b
c0021a3c:	68 d9 ea 02 c0       	push   $0xc002ead9
c0021a41:	68 5c ef 02 c0       	push   $0xc002ef5c
c0021a46:	68 7d 01 00 00       	push   $0x17d
c0021a4b:	68 f0 ea 02 c0       	push   $0xc002eaf0
c0021a50:	e8 d3 7a 00 00       	call   c0029528 <debug_panic>

      in_external_intr = false;
c0021a55:	c6 05 60 86 03 c0 00 	movb   $0x0,0xc0038660
      pic_end_of_interrupt (frame->vec_no); 
c0021a5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a5f:	8b 40 30             	mov    0x30(%eax),%eax
c0021a62:	83 ec 0c             	sub    $0xc,%esp
c0021a65:	50                   	push   %eax
c0021a66:	e8 e0 fc ff ff       	call   c002174b <pic_end_of_interrupt>
c0021a6b:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0021a6e:	a0 61 86 03 c0       	mov    0xc0038661,%al
c0021a73:	84 c0                	test   %al,%al
c0021a75:	74 05                	je     c0021a7c <intr_handler+0x165>
        thread_yield (); 
c0021a77:	e8 dd f2 ff ff       	call   c0020d59 <thread_yield>
    }
}
c0021a7c:	90                   	nop
c0021a7d:	c9                   	leave  
c0021a7e:	c3                   	ret    

c0021a7f <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0021a7f:	55                   	push   %ebp
c0021a80:	89 e5                	mov    %esp,%ebp
c0021a82:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021a85:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a88:	8b 40 30             	mov    0x30(%eax),%eax
c0021a8b:	8b 14 85 60 82 03 c0 	mov    -0x3ffc7da0(,%eax,4),%edx
c0021a92:	42                   	inc    %edx
c0021a93:	89 14 85 60 82 03 c0 	mov    %edx,-0x3ffc7da0(,%eax,4)
c0021a9a:	8b 04 85 60 82 03 c0 	mov    -0x3ffc7da0(,%eax,4),%eax
c0021aa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021aa7:	48                   	dec    %eax
c0021aa8:	23 45 f4             	and    -0xc(%ebp),%eax
c0021aab:	85 c0                	test   %eax,%eax
c0021aad:	75 25                	jne    c0021ad4 <unexpected_interrupt+0x55>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c0021aaf:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ab2:	8b 40 30             	mov    0x30(%eax),%eax
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021ab5:	8b 14 85 60 7e 03 c0 	mov    -0x3ffc81a0(,%eax,4),%edx
c0021abc:	8b 45 08             	mov    0x8(%ebp),%eax
c0021abf:	8b 40 30             	mov    0x30(%eax),%eax
c0021ac2:	83 ec 04             	sub    $0x4,%esp
c0021ac5:	52                   	push   %edx
c0021ac6:	50                   	push   %eax
c0021ac7:	68 04 ee 02 c0       	push   $0xc002ee04
c0021acc:	e8 98 56 00 00       	call   c0027169 <printf>
c0021ad1:	83 c4 10             	add    $0x10,%esp
}
c0021ad4:	90                   	nop
c0021ad5:	c9                   	leave  
c0021ad6:	c3                   	ret    

c0021ad7 <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021ad7:	55                   	push   %ebp
c0021ad8:	89 e5                	mov    %esp,%ebp
c0021ada:	53                   	push   %ebx
c0021adb:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021ade:	0f 20 d0             	mov    %cr2,%eax
c0021ae1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021ae4:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ae7:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021aea:	8b 45 08             	mov    0x8(%ebp),%eax
c0021aed:	8b 40 30             	mov    0x30(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021af0:	8b 14 85 60 7e 03 c0 	mov    -0x3ffc81a0(,%eax,4),%edx
c0021af7:	8b 45 08             	mov    0x8(%ebp),%eax
c0021afa:	8b 40 30             	mov    0x30(%eax),%eax
c0021afd:	51                   	push   %ecx
c0021afe:	52                   	push   %edx
c0021aff:	50                   	push   %eax
c0021b00:	68 28 ee 02 c0       	push   $0xc002ee28
c0021b05:	e8 5f 56 00 00       	call   c0027169 <printf>
c0021b0a:	83 c4 10             	add    $0x10,%esp
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021b0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b10:	8b 40 34             	mov    0x34(%eax),%eax
c0021b13:	83 ec 04             	sub    $0x4,%esp
c0021b16:	50                   	push   %eax
c0021b17:	ff 75 f4             	pushl  -0xc(%ebp)
c0021b1a:	68 48 ee 02 c0       	push   $0xc002ee48
c0021b1f:	e8 45 56 00 00       	call   c0027169 <printf>
c0021b24:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021b27:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b2a:	8b 58 14             	mov    0x14(%eax),%ebx
c0021b2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b30:	8b 48 18             	mov    0x18(%eax),%ecx
c0021b33:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b36:	8b 50 10             	mov    0x10(%eax),%edx
c0021b39:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b3c:	8b 40 1c             	mov    0x1c(%eax),%eax
c0021b3f:	83 ec 0c             	sub    $0xc,%esp
c0021b42:	53                   	push   %ebx
c0021b43:	51                   	push   %ecx
c0021b44:	52                   	push   %edx
c0021b45:	50                   	push   %eax
c0021b46:	68 60 ee 02 c0       	push   $0xc002ee60
c0021b4b:	e8 19 56 00 00       	call   c0027169 <printf>
c0021b50:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021b53:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b56:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0021b59:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b5c:	8b 40 48             	mov    0x48(%eax),%eax
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021b5f:	89 c3                	mov    %eax,%ebx
c0021b61:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b64:	8b 10                	mov    (%eax),%edx
c0021b66:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b69:	8b 40 04             	mov    0x4(%eax),%eax
c0021b6c:	83 ec 0c             	sub    $0xc,%esp
c0021b6f:	51                   	push   %ecx
c0021b70:	53                   	push   %ebx
c0021b71:	52                   	push   %edx
c0021b72:	50                   	push   %eax
c0021b73:	68 88 ee 02 c0       	push   $0xc002ee88
c0021b78:	e8 ec 55 00 00       	call   c0027169 <printf>
c0021b7d:	83 c4 20             	add    $0x20,%esp
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0021b80:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b83:	8b 40 4c             	mov    0x4c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021b86:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c0021b89:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b8c:	8b 40 28             	mov    0x28(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021b8f:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0021b92:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b95:	8b 40 2c             	mov    0x2c(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021b98:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c0021b9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b9e:	8b 40 40             	mov    0x40(%eax),%eax
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021ba1:	0f b7 c0             	movzwl %ax,%eax
c0021ba4:	83 ec 0c             	sub    $0xc,%esp
c0021ba7:	53                   	push   %ebx
c0021ba8:	51                   	push   %ecx
c0021ba9:	52                   	push   %edx
c0021baa:	50                   	push   %eax
c0021bab:	68 b0 ee 02 c0       	push   $0xc002eeb0
c0021bb0:	e8 b4 55 00 00       	call   c0027169 <printf>
c0021bb5:	83 c4 20             	add    $0x20,%esp
}
c0021bb8:	90                   	nop
c0021bb9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021bbc:	c9                   	leave  
c0021bbd:	c3                   	ret    

c0021bbe <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c0021bbe:	55                   	push   %ebp
c0021bbf:	89 e5                	mov    %esp,%ebp
c0021bc1:	83 ec 04             	sub    $0x4,%esp
c0021bc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bc7:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c0021bca:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0021bce:	8b 04 85 60 7e 03 c0 	mov    -0x3ffc81a0(,%eax,4),%eax
}
c0021bd5:	c9                   	leave  
c0021bd6:	c3                   	ret    

c0021bd7 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021bd7:	1e                   	push   %ds
	pushl %es
c0021bd8:	06                   	push   %es
	pushl %fs
c0021bd9:	0f a0                	push   %fs
	pushl %gs
c0021bdb:	0f a8                	push   %gs
	pushal
c0021bdd:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021bde:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021bdf:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021be4:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021be6:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021be8:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021bec:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021bed:	e8 25 fd ff ff       	call   c0021917 <intr_handler>
	addl $4, %esp
c0021bf2:	83 c4 04             	add    $0x4,%esp

c0021bf5 <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021bf5:	61                   	popa   
	popl %gs
c0021bf6:	0f a9                	pop    %gs
	popl %fs
c0021bf8:	0f a1                	pop    %fs
	popl %es
c0021bfa:	07                   	pop    %es
	popl %ds
c0021bfb:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021bfc:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021bff:	cf                   	iret   

c0021c00 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021c00:	55                   	push   %ebp
c0021c01:	6a 00                	push   $0x0
c0021c03:	6a 00                	push   $0x0
c0021c05:	eb d0                	jmp    c0021bd7 <intr_entry>

c0021c07 <intr01_stub>:
c0021c07:	55                   	push   %ebp
c0021c08:	6a 00                	push   $0x0
c0021c0a:	6a 01                	push   $0x1
c0021c0c:	eb c9                	jmp    c0021bd7 <intr_entry>

c0021c0e <intr02_stub>:
c0021c0e:	55                   	push   %ebp
c0021c0f:	6a 00                	push   $0x0
c0021c11:	6a 02                	push   $0x2
c0021c13:	eb c2                	jmp    c0021bd7 <intr_entry>

c0021c15 <intr03_stub>:
c0021c15:	55                   	push   %ebp
c0021c16:	6a 00                	push   $0x0
c0021c18:	6a 03                	push   $0x3
c0021c1a:	eb bb                	jmp    c0021bd7 <intr_entry>

c0021c1c <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021c1c:	55                   	push   %ebp
c0021c1d:	6a 00                	push   $0x0
c0021c1f:	6a 04                	push   $0x4
c0021c21:	eb b4                	jmp    c0021bd7 <intr_entry>

c0021c23 <intr05_stub>:
c0021c23:	55                   	push   %ebp
c0021c24:	6a 00                	push   $0x0
c0021c26:	6a 05                	push   $0x5
c0021c28:	eb ad                	jmp    c0021bd7 <intr_entry>

c0021c2a <intr06_stub>:
c0021c2a:	55                   	push   %ebp
c0021c2b:	6a 00                	push   $0x0
c0021c2d:	6a 06                	push   $0x6
c0021c2f:	eb a6                	jmp    c0021bd7 <intr_entry>

c0021c31 <intr07_stub>:
c0021c31:	55                   	push   %ebp
c0021c32:	6a 00                	push   $0x0
c0021c34:	6a 07                	push   $0x7
c0021c36:	eb 9f                	jmp    c0021bd7 <intr_entry>

c0021c38 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021c38:	ff 34 24             	pushl  (%esp)
c0021c3b:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c3f:	6a 08                	push   $0x8
c0021c41:	eb 94                	jmp    c0021bd7 <intr_entry>

c0021c43 <intr09_stub>:
c0021c43:	55                   	push   %ebp
c0021c44:	6a 00                	push   $0x0
c0021c46:	6a 09                	push   $0x9
c0021c48:	eb 8d                	jmp    c0021bd7 <intr_entry>

c0021c4a <intr0a_stub>:
c0021c4a:	ff 34 24             	pushl  (%esp)
c0021c4d:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c51:	6a 0a                	push   $0xa
c0021c53:	eb 82                	jmp    c0021bd7 <intr_entry>

c0021c55 <intr0b_stub>:
c0021c55:	ff 34 24             	pushl  (%esp)
c0021c58:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c5c:	6a 0b                	push   $0xb
c0021c5e:	e9 74 ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021c63 <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021c63:	55                   	push   %ebp
c0021c64:	6a 00                	push   $0x0
c0021c66:	6a 0c                	push   $0xc
c0021c68:	e9 6a ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021c6d <intr0d_stub>:
c0021c6d:	ff 34 24             	pushl  (%esp)
c0021c70:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c74:	6a 0d                	push   $0xd
c0021c76:	e9 5c ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021c7b <intr0e_stub>:
c0021c7b:	ff 34 24             	pushl  (%esp)
c0021c7e:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021c82:	6a 0e                	push   $0xe
c0021c84:	e9 4e ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021c89 <intr0f_stub>:
c0021c89:	55                   	push   %ebp
c0021c8a:	6a 00                	push   $0x0
c0021c8c:	6a 0f                	push   $0xf
c0021c8e:	e9 44 ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021c93 <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021c93:	55                   	push   %ebp
c0021c94:	6a 00                	push   $0x0
c0021c96:	6a 10                	push   $0x10
c0021c98:	e9 3a ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021c9d <intr11_stub>:
c0021c9d:	ff 34 24             	pushl  (%esp)
c0021ca0:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021ca4:	6a 11                	push   $0x11
c0021ca6:	e9 2c ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021cab <intr12_stub>:
c0021cab:	55                   	push   %ebp
c0021cac:	6a 00                	push   $0x0
c0021cae:	6a 12                	push   $0x12
c0021cb0:	e9 22 ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021cb5 <intr13_stub>:
c0021cb5:	55                   	push   %ebp
c0021cb6:	6a 00                	push   $0x0
c0021cb8:	6a 13                	push   $0x13
c0021cba:	e9 18 ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021cbf <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021cbf:	55                   	push   %ebp
c0021cc0:	6a 00                	push   $0x0
c0021cc2:	6a 14                	push   $0x14
c0021cc4:	e9 0e ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021cc9 <intr15_stub>:
c0021cc9:	55                   	push   %ebp
c0021cca:	6a 00                	push   $0x0
c0021ccc:	6a 15                	push   $0x15
c0021cce:	e9 04 ff ff ff       	jmp    c0021bd7 <intr_entry>

c0021cd3 <intr16_stub>:
c0021cd3:	55                   	push   %ebp
c0021cd4:	6a 00                	push   $0x0
c0021cd6:	6a 16                	push   $0x16
c0021cd8:	e9 fa fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021cdd <intr17_stub>:
c0021cdd:	55                   	push   %ebp
c0021cde:	6a 00                	push   $0x0
c0021ce0:	6a 17                	push   $0x17
c0021ce2:	e9 f0 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021ce7 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021ce7:	ff 34 24             	pushl  (%esp)
c0021cea:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021cee:	6a 18                	push   $0x18
c0021cf0:	e9 e2 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021cf5 <intr19_stub>:
c0021cf5:	55                   	push   %ebp
c0021cf6:	6a 00                	push   $0x0
c0021cf8:	6a 19                	push   $0x19
c0021cfa:	e9 d8 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021cff <intr1a_stub>:
c0021cff:	ff 34 24             	pushl  (%esp)
c0021d02:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d06:	6a 1a                	push   $0x1a
c0021d08:	e9 ca fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d0d <intr1b_stub>:
c0021d0d:	ff 34 24             	pushl  (%esp)
c0021d10:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d14:	6a 1b                	push   $0x1b
c0021d16:	e9 bc fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d1b <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021d1b:	55                   	push   %ebp
c0021d1c:	6a 00                	push   $0x0
c0021d1e:	6a 1c                	push   $0x1c
c0021d20:	e9 b2 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d25 <intr1d_stub>:
c0021d25:	ff 34 24             	pushl  (%esp)
c0021d28:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d2c:	6a 1d                	push   $0x1d
c0021d2e:	e9 a4 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d33 <intr1e_stub>:
c0021d33:	ff 34 24             	pushl  (%esp)
c0021d36:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021d3a:	6a 1e                	push   $0x1e
c0021d3c:	e9 96 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d41 <intr1f_stub>:
c0021d41:	55                   	push   %ebp
c0021d42:	6a 00                	push   $0x0
c0021d44:	6a 1f                	push   $0x1f
c0021d46:	e9 8c fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d4b <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021d4b:	55                   	push   %ebp
c0021d4c:	6a 00                	push   $0x0
c0021d4e:	6a 20                	push   $0x20
c0021d50:	e9 82 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d55 <intr21_stub>:
c0021d55:	55                   	push   %ebp
c0021d56:	6a 00                	push   $0x0
c0021d58:	6a 21                	push   $0x21
c0021d5a:	e9 78 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d5f <intr22_stub>:
c0021d5f:	55                   	push   %ebp
c0021d60:	6a 00                	push   $0x0
c0021d62:	6a 22                	push   $0x22
c0021d64:	e9 6e fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d69 <intr23_stub>:
c0021d69:	55                   	push   %ebp
c0021d6a:	6a 00                	push   $0x0
c0021d6c:	6a 23                	push   $0x23
c0021d6e:	e9 64 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d73 <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0021d73:	55                   	push   %ebp
c0021d74:	6a 00                	push   $0x0
c0021d76:	6a 24                	push   $0x24
c0021d78:	e9 5a fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d7d <intr25_stub>:
c0021d7d:	55                   	push   %ebp
c0021d7e:	6a 00                	push   $0x0
c0021d80:	6a 25                	push   $0x25
c0021d82:	e9 50 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d87 <intr26_stub>:
c0021d87:	55                   	push   %ebp
c0021d88:	6a 00                	push   $0x0
c0021d8a:	6a 26                	push   $0x26
c0021d8c:	e9 46 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d91 <intr27_stub>:
c0021d91:	55                   	push   %ebp
c0021d92:	6a 00                	push   $0x0
c0021d94:	6a 27                	push   $0x27
c0021d96:	e9 3c fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021d9b <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0021d9b:	55                   	push   %ebp
c0021d9c:	6a 00                	push   $0x0
c0021d9e:	6a 28                	push   $0x28
c0021da0:	e9 32 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021da5 <intr29_stub>:
c0021da5:	55                   	push   %ebp
c0021da6:	6a 00                	push   $0x0
c0021da8:	6a 29                	push   $0x29
c0021daa:	e9 28 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021daf <intr2a_stub>:
c0021daf:	55                   	push   %ebp
c0021db0:	6a 00                	push   $0x0
c0021db2:	6a 2a                	push   $0x2a
c0021db4:	e9 1e fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021db9 <intr2b_stub>:
c0021db9:	55                   	push   %ebp
c0021dba:	6a 00                	push   $0x0
c0021dbc:	6a 2b                	push   $0x2b
c0021dbe:	e9 14 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021dc3 <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0021dc3:	55                   	push   %ebp
c0021dc4:	6a 00                	push   $0x0
c0021dc6:	6a 2c                	push   $0x2c
c0021dc8:	e9 0a fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021dcd <intr2d_stub>:
c0021dcd:	55                   	push   %ebp
c0021dce:	6a 00                	push   $0x0
c0021dd0:	6a 2d                	push   $0x2d
c0021dd2:	e9 00 fe ff ff       	jmp    c0021bd7 <intr_entry>

c0021dd7 <intr2e_stub>:
c0021dd7:	55                   	push   %ebp
c0021dd8:	6a 00                	push   $0x0
c0021dda:	6a 2e                	push   $0x2e
c0021ddc:	e9 f6 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021de1 <intr2f_stub>:
c0021de1:	55                   	push   %ebp
c0021de2:	6a 00                	push   $0x0
c0021de4:	6a 2f                	push   $0x2f
c0021de6:	e9 ec fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021deb <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0021deb:	55                   	push   %ebp
c0021dec:	6a 00                	push   $0x0
c0021dee:	6a 30                	push   $0x30
c0021df0:	e9 e2 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021df5 <intr31_stub>:
c0021df5:	55                   	push   %ebp
c0021df6:	6a 00                	push   $0x0
c0021df8:	6a 31                	push   $0x31
c0021dfa:	e9 d8 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021dff <intr32_stub>:
c0021dff:	55                   	push   %ebp
c0021e00:	6a 00                	push   $0x0
c0021e02:	6a 32                	push   $0x32
c0021e04:	e9 ce fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e09 <intr33_stub>:
c0021e09:	55                   	push   %ebp
c0021e0a:	6a 00                	push   $0x0
c0021e0c:	6a 33                	push   $0x33
c0021e0e:	e9 c4 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e13 <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0021e13:	55                   	push   %ebp
c0021e14:	6a 00                	push   $0x0
c0021e16:	6a 34                	push   $0x34
c0021e18:	e9 ba fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e1d <intr35_stub>:
c0021e1d:	55                   	push   %ebp
c0021e1e:	6a 00                	push   $0x0
c0021e20:	6a 35                	push   $0x35
c0021e22:	e9 b0 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e27 <intr36_stub>:
c0021e27:	55                   	push   %ebp
c0021e28:	6a 00                	push   $0x0
c0021e2a:	6a 36                	push   $0x36
c0021e2c:	e9 a6 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e31 <intr37_stub>:
c0021e31:	55                   	push   %ebp
c0021e32:	6a 00                	push   $0x0
c0021e34:	6a 37                	push   $0x37
c0021e36:	e9 9c fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e3b <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0021e3b:	55                   	push   %ebp
c0021e3c:	6a 00                	push   $0x0
c0021e3e:	6a 38                	push   $0x38
c0021e40:	e9 92 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e45 <intr39_stub>:
c0021e45:	55                   	push   %ebp
c0021e46:	6a 00                	push   $0x0
c0021e48:	6a 39                	push   $0x39
c0021e4a:	e9 88 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e4f <intr3a_stub>:
c0021e4f:	55                   	push   %ebp
c0021e50:	6a 00                	push   $0x0
c0021e52:	6a 3a                	push   $0x3a
c0021e54:	e9 7e fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e59 <intr3b_stub>:
c0021e59:	55                   	push   %ebp
c0021e5a:	6a 00                	push   $0x0
c0021e5c:	6a 3b                	push   $0x3b
c0021e5e:	e9 74 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e63 <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0021e63:	55                   	push   %ebp
c0021e64:	6a 00                	push   $0x0
c0021e66:	6a 3c                	push   $0x3c
c0021e68:	e9 6a fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e6d <intr3d_stub>:
c0021e6d:	55                   	push   %ebp
c0021e6e:	6a 00                	push   $0x0
c0021e70:	6a 3d                	push   $0x3d
c0021e72:	e9 60 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e77 <intr3e_stub>:
c0021e77:	55                   	push   %ebp
c0021e78:	6a 00                	push   $0x0
c0021e7a:	6a 3e                	push   $0x3e
c0021e7c:	e9 56 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e81 <intr3f_stub>:
c0021e81:	55                   	push   %ebp
c0021e82:	6a 00                	push   $0x0
c0021e84:	6a 3f                	push   $0x3f
c0021e86:	e9 4c fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e8b <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0021e8b:	55                   	push   %ebp
c0021e8c:	6a 00                	push   $0x0
c0021e8e:	6a 40                	push   $0x40
c0021e90:	e9 42 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e95 <intr41_stub>:
c0021e95:	55                   	push   %ebp
c0021e96:	6a 00                	push   $0x0
c0021e98:	6a 41                	push   $0x41
c0021e9a:	e9 38 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021e9f <intr42_stub>:
c0021e9f:	55                   	push   %ebp
c0021ea0:	6a 00                	push   $0x0
c0021ea2:	6a 42                	push   $0x42
c0021ea4:	e9 2e fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021ea9 <intr43_stub>:
c0021ea9:	55                   	push   %ebp
c0021eaa:	6a 00                	push   $0x0
c0021eac:	6a 43                	push   $0x43
c0021eae:	e9 24 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021eb3 <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c0021eb3:	55                   	push   %ebp
c0021eb4:	6a 00                	push   $0x0
c0021eb6:	6a 44                	push   $0x44
c0021eb8:	e9 1a fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021ebd <intr45_stub>:
c0021ebd:	55                   	push   %ebp
c0021ebe:	6a 00                	push   $0x0
c0021ec0:	6a 45                	push   $0x45
c0021ec2:	e9 10 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021ec7 <intr46_stub>:
c0021ec7:	55                   	push   %ebp
c0021ec8:	6a 00                	push   $0x0
c0021eca:	6a 46                	push   $0x46
c0021ecc:	e9 06 fd ff ff       	jmp    c0021bd7 <intr_entry>

c0021ed1 <intr47_stub>:
c0021ed1:	55                   	push   %ebp
c0021ed2:	6a 00                	push   $0x0
c0021ed4:	6a 47                	push   $0x47
c0021ed6:	e9 fc fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021edb <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0021edb:	55                   	push   %ebp
c0021edc:	6a 00                	push   $0x0
c0021ede:	6a 48                	push   $0x48
c0021ee0:	e9 f2 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021ee5 <intr49_stub>:
c0021ee5:	55                   	push   %ebp
c0021ee6:	6a 00                	push   $0x0
c0021ee8:	6a 49                	push   $0x49
c0021eea:	e9 e8 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021eef <intr4a_stub>:
c0021eef:	55                   	push   %ebp
c0021ef0:	6a 00                	push   $0x0
c0021ef2:	6a 4a                	push   $0x4a
c0021ef4:	e9 de fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021ef9 <intr4b_stub>:
c0021ef9:	55                   	push   %ebp
c0021efa:	6a 00                	push   $0x0
c0021efc:	6a 4b                	push   $0x4b
c0021efe:	e9 d4 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f03 <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c0021f03:	55                   	push   %ebp
c0021f04:	6a 00                	push   $0x0
c0021f06:	6a 4c                	push   $0x4c
c0021f08:	e9 ca fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f0d <intr4d_stub>:
c0021f0d:	55                   	push   %ebp
c0021f0e:	6a 00                	push   $0x0
c0021f10:	6a 4d                	push   $0x4d
c0021f12:	e9 c0 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f17 <intr4e_stub>:
c0021f17:	55                   	push   %ebp
c0021f18:	6a 00                	push   $0x0
c0021f1a:	6a 4e                	push   $0x4e
c0021f1c:	e9 b6 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f21 <intr4f_stub>:
c0021f21:	55                   	push   %ebp
c0021f22:	6a 00                	push   $0x0
c0021f24:	6a 4f                	push   $0x4f
c0021f26:	e9 ac fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f2b <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0021f2b:	55                   	push   %ebp
c0021f2c:	6a 00                	push   $0x0
c0021f2e:	6a 50                	push   $0x50
c0021f30:	e9 a2 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f35 <intr51_stub>:
c0021f35:	55                   	push   %ebp
c0021f36:	6a 00                	push   $0x0
c0021f38:	6a 51                	push   $0x51
c0021f3a:	e9 98 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f3f <intr52_stub>:
c0021f3f:	55                   	push   %ebp
c0021f40:	6a 00                	push   $0x0
c0021f42:	6a 52                	push   $0x52
c0021f44:	e9 8e fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f49 <intr53_stub>:
c0021f49:	55                   	push   %ebp
c0021f4a:	6a 00                	push   $0x0
c0021f4c:	6a 53                	push   $0x53
c0021f4e:	e9 84 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f53 <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c0021f53:	55                   	push   %ebp
c0021f54:	6a 00                	push   $0x0
c0021f56:	6a 54                	push   $0x54
c0021f58:	e9 7a fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f5d <intr55_stub>:
c0021f5d:	55                   	push   %ebp
c0021f5e:	6a 00                	push   $0x0
c0021f60:	6a 55                	push   $0x55
c0021f62:	e9 70 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f67 <intr56_stub>:
c0021f67:	55                   	push   %ebp
c0021f68:	6a 00                	push   $0x0
c0021f6a:	6a 56                	push   $0x56
c0021f6c:	e9 66 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f71 <intr57_stub>:
c0021f71:	55                   	push   %ebp
c0021f72:	6a 00                	push   $0x0
c0021f74:	6a 57                	push   $0x57
c0021f76:	e9 5c fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f7b <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0021f7b:	55                   	push   %ebp
c0021f7c:	6a 00                	push   $0x0
c0021f7e:	6a 58                	push   $0x58
c0021f80:	e9 52 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f85 <intr59_stub>:
c0021f85:	55                   	push   %ebp
c0021f86:	6a 00                	push   $0x0
c0021f88:	6a 59                	push   $0x59
c0021f8a:	e9 48 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f8f <intr5a_stub>:
c0021f8f:	55                   	push   %ebp
c0021f90:	6a 00                	push   $0x0
c0021f92:	6a 5a                	push   $0x5a
c0021f94:	e9 3e fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021f99 <intr5b_stub>:
c0021f99:	55                   	push   %ebp
c0021f9a:	6a 00                	push   $0x0
c0021f9c:	6a 5b                	push   $0x5b
c0021f9e:	e9 34 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021fa3 <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c0021fa3:	55                   	push   %ebp
c0021fa4:	6a 00                	push   $0x0
c0021fa6:	6a 5c                	push   $0x5c
c0021fa8:	e9 2a fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021fad <intr5d_stub>:
c0021fad:	55                   	push   %ebp
c0021fae:	6a 00                	push   $0x0
c0021fb0:	6a 5d                	push   $0x5d
c0021fb2:	e9 20 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021fb7 <intr5e_stub>:
c0021fb7:	55                   	push   %ebp
c0021fb8:	6a 00                	push   $0x0
c0021fba:	6a 5e                	push   $0x5e
c0021fbc:	e9 16 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021fc1 <intr5f_stub>:
c0021fc1:	55                   	push   %ebp
c0021fc2:	6a 00                	push   $0x0
c0021fc4:	6a 5f                	push   $0x5f
c0021fc6:	e9 0c fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021fcb <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0021fcb:	55                   	push   %ebp
c0021fcc:	6a 00                	push   $0x0
c0021fce:	6a 60                	push   $0x60
c0021fd0:	e9 02 fc ff ff       	jmp    c0021bd7 <intr_entry>

c0021fd5 <intr61_stub>:
c0021fd5:	55                   	push   %ebp
c0021fd6:	6a 00                	push   $0x0
c0021fd8:	6a 61                	push   $0x61
c0021fda:	e9 f8 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0021fdf <intr62_stub>:
c0021fdf:	55                   	push   %ebp
c0021fe0:	6a 00                	push   $0x0
c0021fe2:	6a 62                	push   $0x62
c0021fe4:	e9 ee fb ff ff       	jmp    c0021bd7 <intr_entry>

c0021fe9 <intr63_stub>:
c0021fe9:	55                   	push   %ebp
c0021fea:	6a 00                	push   $0x0
c0021fec:	6a 63                	push   $0x63
c0021fee:	e9 e4 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0021ff3 <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c0021ff3:	55                   	push   %ebp
c0021ff4:	6a 00                	push   $0x0
c0021ff6:	6a 64                	push   $0x64
c0021ff8:	e9 da fb ff ff       	jmp    c0021bd7 <intr_entry>

c0021ffd <intr65_stub>:
c0021ffd:	55                   	push   %ebp
c0021ffe:	6a 00                	push   $0x0
c0022000:	6a 65                	push   $0x65
c0022002:	e9 d0 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022007 <intr66_stub>:
c0022007:	55                   	push   %ebp
c0022008:	6a 00                	push   $0x0
c002200a:	6a 66                	push   $0x66
c002200c:	e9 c6 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022011 <intr67_stub>:
c0022011:	55                   	push   %ebp
c0022012:	6a 00                	push   $0x0
c0022014:	6a 67                	push   $0x67
c0022016:	e9 bc fb ff ff       	jmp    c0021bd7 <intr_entry>

c002201b <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c002201b:	55                   	push   %ebp
c002201c:	6a 00                	push   $0x0
c002201e:	6a 68                	push   $0x68
c0022020:	e9 b2 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022025 <intr69_stub>:
c0022025:	55                   	push   %ebp
c0022026:	6a 00                	push   $0x0
c0022028:	6a 69                	push   $0x69
c002202a:	e9 a8 fb ff ff       	jmp    c0021bd7 <intr_entry>

c002202f <intr6a_stub>:
c002202f:	55                   	push   %ebp
c0022030:	6a 00                	push   $0x0
c0022032:	6a 6a                	push   $0x6a
c0022034:	e9 9e fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022039 <intr6b_stub>:
c0022039:	55                   	push   %ebp
c002203a:	6a 00                	push   $0x0
c002203c:	6a 6b                	push   $0x6b
c002203e:	e9 94 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022043 <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c0022043:	55                   	push   %ebp
c0022044:	6a 00                	push   $0x0
c0022046:	6a 6c                	push   $0x6c
c0022048:	e9 8a fb ff ff       	jmp    c0021bd7 <intr_entry>

c002204d <intr6d_stub>:
c002204d:	55                   	push   %ebp
c002204e:	6a 00                	push   $0x0
c0022050:	6a 6d                	push   $0x6d
c0022052:	e9 80 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022057 <intr6e_stub>:
c0022057:	55                   	push   %ebp
c0022058:	6a 00                	push   $0x0
c002205a:	6a 6e                	push   $0x6e
c002205c:	e9 76 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022061 <intr6f_stub>:
c0022061:	55                   	push   %ebp
c0022062:	6a 00                	push   $0x0
c0022064:	6a 6f                	push   $0x6f
c0022066:	e9 6c fb ff ff       	jmp    c0021bd7 <intr_entry>

c002206b <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c002206b:	55                   	push   %ebp
c002206c:	6a 00                	push   $0x0
c002206e:	6a 70                	push   $0x70
c0022070:	e9 62 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022075 <intr71_stub>:
c0022075:	55                   	push   %ebp
c0022076:	6a 00                	push   $0x0
c0022078:	6a 71                	push   $0x71
c002207a:	e9 58 fb ff ff       	jmp    c0021bd7 <intr_entry>

c002207f <intr72_stub>:
c002207f:	55                   	push   %ebp
c0022080:	6a 00                	push   $0x0
c0022082:	6a 72                	push   $0x72
c0022084:	e9 4e fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022089 <intr73_stub>:
c0022089:	55                   	push   %ebp
c002208a:	6a 00                	push   $0x0
c002208c:	6a 73                	push   $0x73
c002208e:	e9 44 fb ff ff       	jmp    c0021bd7 <intr_entry>

c0022093 <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c0022093:	55                   	push   %ebp
c0022094:	6a 00                	push   $0x0
c0022096:	6a 74                	push   $0x74
c0022098:	e9 3a fb ff ff       	jmp    c0021bd7 <intr_entry>

c002209d <intr75_stub>:
c002209d:	55                   	push   %ebp
c002209e:	6a 00                	push   $0x0
c00220a0:	6a 75                	push   $0x75
c00220a2:	e9 30 fb ff ff       	jmp    c0021bd7 <intr_entry>

c00220a7 <intr76_stub>:
c00220a7:	55                   	push   %ebp
c00220a8:	6a 00                	push   $0x0
c00220aa:	6a 76                	push   $0x76
c00220ac:	e9 26 fb ff ff       	jmp    c0021bd7 <intr_entry>

c00220b1 <intr77_stub>:
c00220b1:	55                   	push   %ebp
c00220b2:	6a 00                	push   $0x0
c00220b4:	6a 77                	push   $0x77
c00220b6:	e9 1c fb ff ff       	jmp    c0021bd7 <intr_entry>

c00220bb <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c00220bb:	55                   	push   %ebp
c00220bc:	6a 00                	push   $0x0
c00220be:	6a 78                	push   $0x78
c00220c0:	e9 12 fb ff ff       	jmp    c0021bd7 <intr_entry>

c00220c5 <intr79_stub>:
c00220c5:	55                   	push   %ebp
c00220c6:	6a 00                	push   $0x0
c00220c8:	6a 79                	push   $0x79
c00220ca:	e9 08 fb ff ff       	jmp    c0021bd7 <intr_entry>

c00220cf <intr7a_stub>:
c00220cf:	55                   	push   %ebp
c00220d0:	6a 00                	push   $0x0
c00220d2:	6a 7a                	push   $0x7a
c00220d4:	e9 fe fa ff ff       	jmp    c0021bd7 <intr_entry>

c00220d9 <intr7b_stub>:
c00220d9:	55                   	push   %ebp
c00220da:	6a 00                	push   $0x0
c00220dc:	6a 7b                	push   $0x7b
c00220de:	e9 f4 fa ff ff       	jmp    c0021bd7 <intr_entry>

c00220e3 <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c00220e3:	55                   	push   %ebp
c00220e4:	6a 00                	push   $0x0
c00220e6:	6a 7c                	push   $0x7c
c00220e8:	e9 ea fa ff ff       	jmp    c0021bd7 <intr_entry>

c00220ed <intr7d_stub>:
c00220ed:	55                   	push   %ebp
c00220ee:	6a 00                	push   $0x0
c00220f0:	6a 7d                	push   $0x7d
c00220f2:	e9 e0 fa ff ff       	jmp    c0021bd7 <intr_entry>

c00220f7 <intr7e_stub>:
c00220f7:	55                   	push   %ebp
c00220f8:	6a 00                	push   $0x0
c00220fa:	6a 7e                	push   $0x7e
c00220fc:	e9 d6 fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022101 <intr7f_stub>:
c0022101:	55                   	push   %ebp
c0022102:	6a 00                	push   $0x0
c0022104:	6a 7f                	push   $0x7f
c0022106:	e9 cc fa ff ff       	jmp    c0021bd7 <intr_entry>

c002210b <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c002210b:	55                   	push   %ebp
c002210c:	6a 00                	push   $0x0
c002210e:	68 80 00 00 00       	push   $0x80
c0022113:	e9 bf fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022118 <intr81_stub>:
c0022118:	55                   	push   %ebp
c0022119:	6a 00                	push   $0x0
c002211b:	68 81 00 00 00       	push   $0x81
c0022120:	e9 b2 fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022125 <intr82_stub>:
c0022125:	55                   	push   %ebp
c0022126:	6a 00                	push   $0x0
c0022128:	68 82 00 00 00       	push   $0x82
c002212d:	e9 a5 fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022132 <intr83_stub>:
c0022132:	55                   	push   %ebp
c0022133:	6a 00                	push   $0x0
c0022135:	68 83 00 00 00       	push   $0x83
c002213a:	e9 98 fa ff ff       	jmp    c0021bd7 <intr_entry>

c002213f <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c002213f:	55                   	push   %ebp
c0022140:	6a 00                	push   $0x0
c0022142:	68 84 00 00 00       	push   $0x84
c0022147:	e9 8b fa ff ff       	jmp    c0021bd7 <intr_entry>

c002214c <intr85_stub>:
c002214c:	55                   	push   %ebp
c002214d:	6a 00                	push   $0x0
c002214f:	68 85 00 00 00       	push   $0x85
c0022154:	e9 7e fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022159 <intr86_stub>:
c0022159:	55                   	push   %ebp
c002215a:	6a 00                	push   $0x0
c002215c:	68 86 00 00 00       	push   $0x86
c0022161:	e9 71 fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022166 <intr87_stub>:
c0022166:	55                   	push   %ebp
c0022167:	6a 00                	push   $0x0
c0022169:	68 87 00 00 00       	push   $0x87
c002216e:	e9 64 fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022173 <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022173:	55                   	push   %ebp
c0022174:	6a 00                	push   $0x0
c0022176:	68 88 00 00 00       	push   $0x88
c002217b:	e9 57 fa ff ff       	jmp    c0021bd7 <intr_entry>

c0022180 <intr89_stub>:
c0022180:	55                   	push   %ebp
c0022181:	6a 00                	push   $0x0
c0022183:	68 89 00 00 00       	push   $0x89
c0022188:	e9 4a fa ff ff       	jmp    c0021bd7 <intr_entry>

c002218d <intr8a_stub>:
c002218d:	55                   	push   %ebp
c002218e:	6a 00                	push   $0x0
c0022190:	68 8a 00 00 00       	push   $0x8a
c0022195:	e9 3d fa ff ff       	jmp    c0021bd7 <intr_entry>

c002219a <intr8b_stub>:
c002219a:	55                   	push   %ebp
c002219b:	6a 00                	push   $0x0
c002219d:	68 8b 00 00 00       	push   $0x8b
c00221a2:	e9 30 fa ff ff       	jmp    c0021bd7 <intr_entry>

c00221a7 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c00221a7:	55                   	push   %ebp
c00221a8:	6a 00                	push   $0x0
c00221aa:	68 8c 00 00 00       	push   $0x8c
c00221af:	e9 23 fa ff ff       	jmp    c0021bd7 <intr_entry>

c00221b4 <intr8d_stub>:
c00221b4:	55                   	push   %ebp
c00221b5:	6a 00                	push   $0x0
c00221b7:	68 8d 00 00 00       	push   $0x8d
c00221bc:	e9 16 fa ff ff       	jmp    c0021bd7 <intr_entry>

c00221c1 <intr8e_stub>:
c00221c1:	55                   	push   %ebp
c00221c2:	6a 00                	push   $0x0
c00221c4:	68 8e 00 00 00       	push   $0x8e
c00221c9:	e9 09 fa ff ff       	jmp    c0021bd7 <intr_entry>

c00221ce <intr8f_stub>:
c00221ce:	55                   	push   %ebp
c00221cf:	6a 00                	push   $0x0
c00221d1:	68 8f 00 00 00       	push   $0x8f
c00221d6:	e9 fc f9 ff ff       	jmp    c0021bd7 <intr_entry>

c00221db <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c00221db:	55                   	push   %ebp
c00221dc:	6a 00                	push   $0x0
c00221de:	68 90 00 00 00       	push   $0x90
c00221e3:	e9 ef f9 ff ff       	jmp    c0021bd7 <intr_entry>

c00221e8 <intr91_stub>:
c00221e8:	55                   	push   %ebp
c00221e9:	6a 00                	push   $0x0
c00221eb:	68 91 00 00 00       	push   $0x91
c00221f0:	e9 e2 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c00221f5 <intr92_stub>:
c00221f5:	55                   	push   %ebp
c00221f6:	6a 00                	push   $0x0
c00221f8:	68 92 00 00 00       	push   $0x92
c00221fd:	e9 d5 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022202 <intr93_stub>:
c0022202:	55                   	push   %ebp
c0022203:	6a 00                	push   $0x0
c0022205:	68 93 00 00 00       	push   $0x93
c002220a:	e9 c8 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c002220f <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c002220f:	55                   	push   %ebp
c0022210:	6a 00                	push   $0x0
c0022212:	68 94 00 00 00       	push   $0x94
c0022217:	e9 bb f9 ff ff       	jmp    c0021bd7 <intr_entry>

c002221c <intr95_stub>:
c002221c:	55                   	push   %ebp
c002221d:	6a 00                	push   $0x0
c002221f:	68 95 00 00 00       	push   $0x95
c0022224:	e9 ae f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022229 <intr96_stub>:
c0022229:	55                   	push   %ebp
c002222a:	6a 00                	push   $0x0
c002222c:	68 96 00 00 00       	push   $0x96
c0022231:	e9 a1 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022236 <intr97_stub>:
c0022236:	55                   	push   %ebp
c0022237:	6a 00                	push   $0x0
c0022239:	68 97 00 00 00       	push   $0x97
c002223e:	e9 94 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022243 <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022243:	55                   	push   %ebp
c0022244:	6a 00                	push   $0x0
c0022246:	68 98 00 00 00       	push   $0x98
c002224b:	e9 87 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022250 <intr99_stub>:
c0022250:	55                   	push   %ebp
c0022251:	6a 00                	push   $0x0
c0022253:	68 99 00 00 00       	push   $0x99
c0022258:	e9 7a f9 ff ff       	jmp    c0021bd7 <intr_entry>

c002225d <intr9a_stub>:
c002225d:	55                   	push   %ebp
c002225e:	6a 00                	push   $0x0
c0022260:	68 9a 00 00 00       	push   $0x9a
c0022265:	e9 6d f9 ff ff       	jmp    c0021bd7 <intr_entry>

c002226a <intr9b_stub>:
c002226a:	55                   	push   %ebp
c002226b:	6a 00                	push   $0x0
c002226d:	68 9b 00 00 00       	push   $0x9b
c0022272:	e9 60 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022277 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022277:	55                   	push   %ebp
c0022278:	6a 00                	push   $0x0
c002227a:	68 9c 00 00 00       	push   $0x9c
c002227f:	e9 53 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022284 <intr9d_stub>:
c0022284:	55                   	push   %ebp
c0022285:	6a 00                	push   $0x0
c0022287:	68 9d 00 00 00       	push   $0x9d
c002228c:	e9 46 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c0022291 <intr9e_stub>:
c0022291:	55                   	push   %ebp
c0022292:	6a 00                	push   $0x0
c0022294:	68 9e 00 00 00       	push   $0x9e
c0022299:	e9 39 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c002229e <intr9f_stub>:
c002229e:	55                   	push   %ebp
c002229f:	6a 00                	push   $0x0
c00222a1:	68 9f 00 00 00       	push   $0x9f
c00222a6:	e9 2c f9 ff ff       	jmp    c0021bd7 <intr_entry>

c00222ab <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c00222ab:	55                   	push   %ebp
c00222ac:	6a 00                	push   $0x0
c00222ae:	68 a0 00 00 00       	push   $0xa0
c00222b3:	e9 1f f9 ff ff       	jmp    c0021bd7 <intr_entry>

c00222b8 <intra1_stub>:
c00222b8:	55                   	push   %ebp
c00222b9:	6a 00                	push   $0x0
c00222bb:	68 a1 00 00 00       	push   $0xa1
c00222c0:	e9 12 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c00222c5 <intra2_stub>:
c00222c5:	55                   	push   %ebp
c00222c6:	6a 00                	push   $0x0
c00222c8:	68 a2 00 00 00       	push   $0xa2
c00222cd:	e9 05 f9 ff ff       	jmp    c0021bd7 <intr_entry>

c00222d2 <intra3_stub>:
c00222d2:	55                   	push   %ebp
c00222d3:	6a 00                	push   $0x0
c00222d5:	68 a3 00 00 00       	push   $0xa3
c00222da:	e9 f8 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00222df <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c00222df:	55                   	push   %ebp
c00222e0:	6a 00                	push   $0x0
c00222e2:	68 a4 00 00 00       	push   $0xa4
c00222e7:	e9 eb f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00222ec <intra5_stub>:
c00222ec:	55                   	push   %ebp
c00222ed:	6a 00                	push   $0x0
c00222ef:	68 a5 00 00 00       	push   $0xa5
c00222f4:	e9 de f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00222f9 <intra6_stub>:
c00222f9:	55                   	push   %ebp
c00222fa:	6a 00                	push   $0x0
c00222fc:	68 a6 00 00 00       	push   $0xa6
c0022301:	e9 d1 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022306 <intra7_stub>:
c0022306:	55                   	push   %ebp
c0022307:	6a 00                	push   $0x0
c0022309:	68 a7 00 00 00       	push   $0xa7
c002230e:	e9 c4 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022313 <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022313:	55                   	push   %ebp
c0022314:	6a 00                	push   $0x0
c0022316:	68 a8 00 00 00       	push   $0xa8
c002231b:	e9 b7 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022320 <intra9_stub>:
c0022320:	55                   	push   %ebp
c0022321:	6a 00                	push   $0x0
c0022323:	68 a9 00 00 00       	push   $0xa9
c0022328:	e9 aa f8 ff ff       	jmp    c0021bd7 <intr_entry>

c002232d <intraa_stub>:
c002232d:	55                   	push   %ebp
c002232e:	6a 00                	push   $0x0
c0022330:	68 aa 00 00 00       	push   $0xaa
c0022335:	e9 9d f8 ff ff       	jmp    c0021bd7 <intr_entry>

c002233a <intrab_stub>:
c002233a:	55                   	push   %ebp
c002233b:	6a 00                	push   $0x0
c002233d:	68 ab 00 00 00       	push   $0xab
c0022342:	e9 90 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022347 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022347:	55                   	push   %ebp
c0022348:	6a 00                	push   $0x0
c002234a:	68 ac 00 00 00       	push   $0xac
c002234f:	e9 83 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022354 <intrad_stub>:
c0022354:	55                   	push   %ebp
c0022355:	6a 00                	push   $0x0
c0022357:	68 ad 00 00 00       	push   $0xad
c002235c:	e9 76 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022361 <intrae_stub>:
c0022361:	55                   	push   %ebp
c0022362:	6a 00                	push   $0x0
c0022364:	68 ae 00 00 00       	push   $0xae
c0022369:	e9 69 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c002236e <intraf_stub>:
c002236e:	55                   	push   %ebp
c002236f:	6a 00                	push   $0x0
c0022371:	68 af 00 00 00       	push   $0xaf
c0022376:	e9 5c f8 ff ff       	jmp    c0021bd7 <intr_entry>

c002237b <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c002237b:	55                   	push   %ebp
c002237c:	6a 00                	push   $0x0
c002237e:	68 b0 00 00 00       	push   $0xb0
c0022383:	e9 4f f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022388 <intrb1_stub>:
c0022388:	55                   	push   %ebp
c0022389:	6a 00                	push   $0x0
c002238b:	68 b1 00 00 00       	push   $0xb1
c0022390:	e9 42 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c0022395 <intrb2_stub>:
c0022395:	55                   	push   %ebp
c0022396:	6a 00                	push   $0x0
c0022398:	68 b2 00 00 00       	push   $0xb2
c002239d:	e9 35 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00223a2 <intrb3_stub>:
c00223a2:	55                   	push   %ebp
c00223a3:	6a 00                	push   $0x0
c00223a5:	68 b3 00 00 00       	push   $0xb3
c00223aa:	e9 28 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00223af <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c00223af:	55                   	push   %ebp
c00223b0:	6a 00                	push   $0x0
c00223b2:	68 b4 00 00 00       	push   $0xb4
c00223b7:	e9 1b f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00223bc <intrb5_stub>:
c00223bc:	55                   	push   %ebp
c00223bd:	6a 00                	push   $0x0
c00223bf:	68 b5 00 00 00       	push   $0xb5
c00223c4:	e9 0e f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00223c9 <intrb6_stub>:
c00223c9:	55                   	push   %ebp
c00223ca:	6a 00                	push   $0x0
c00223cc:	68 b6 00 00 00       	push   $0xb6
c00223d1:	e9 01 f8 ff ff       	jmp    c0021bd7 <intr_entry>

c00223d6 <intrb7_stub>:
c00223d6:	55                   	push   %ebp
c00223d7:	6a 00                	push   $0x0
c00223d9:	68 b7 00 00 00       	push   $0xb7
c00223de:	e9 f4 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c00223e3 <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c00223e3:	55                   	push   %ebp
c00223e4:	6a 00                	push   $0x0
c00223e6:	68 b8 00 00 00       	push   $0xb8
c00223eb:	e9 e7 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c00223f0 <intrb9_stub>:
c00223f0:	55                   	push   %ebp
c00223f1:	6a 00                	push   $0x0
c00223f3:	68 b9 00 00 00       	push   $0xb9
c00223f8:	e9 da f7 ff ff       	jmp    c0021bd7 <intr_entry>

c00223fd <intrba_stub>:
c00223fd:	55                   	push   %ebp
c00223fe:	6a 00                	push   $0x0
c0022400:	68 ba 00 00 00       	push   $0xba
c0022405:	e9 cd f7 ff ff       	jmp    c0021bd7 <intr_entry>

c002240a <intrbb_stub>:
c002240a:	55                   	push   %ebp
c002240b:	6a 00                	push   $0x0
c002240d:	68 bb 00 00 00       	push   $0xbb
c0022412:	e9 c0 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c0022417 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022417:	55                   	push   %ebp
c0022418:	6a 00                	push   $0x0
c002241a:	68 bc 00 00 00       	push   $0xbc
c002241f:	e9 b3 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c0022424 <intrbd_stub>:
c0022424:	55                   	push   %ebp
c0022425:	6a 00                	push   $0x0
c0022427:	68 bd 00 00 00       	push   $0xbd
c002242c:	e9 a6 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c0022431 <intrbe_stub>:
c0022431:	55                   	push   %ebp
c0022432:	6a 00                	push   $0x0
c0022434:	68 be 00 00 00       	push   $0xbe
c0022439:	e9 99 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c002243e <intrbf_stub>:
c002243e:	55                   	push   %ebp
c002243f:	6a 00                	push   $0x0
c0022441:	68 bf 00 00 00       	push   $0xbf
c0022446:	e9 8c f7 ff ff       	jmp    c0021bd7 <intr_entry>

c002244b <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c002244b:	55                   	push   %ebp
c002244c:	6a 00                	push   $0x0
c002244e:	68 c0 00 00 00       	push   $0xc0
c0022453:	e9 7f f7 ff ff       	jmp    c0021bd7 <intr_entry>

c0022458 <intrc1_stub>:
c0022458:	55                   	push   %ebp
c0022459:	6a 00                	push   $0x0
c002245b:	68 c1 00 00 00       	push   $0xc1
c0022460:	e9 72 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c0022465 <intrc2_stub>:
c0022465:	55                   	push   %ebp
c0022466:	6a 00                	push   $0x0
c0022468:	68 c2 00 00 00       	push   $0xc2
c002246d:	e9 65 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c0022472 <intrc3_stub>:
c0022472:	55                   	push   %ebp
c0022473:	6a 00                	push   $0x0
c0022475:	68 c3 00 00 00       	push   $0xc3
c002247a:	e9 58 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c002247f <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c002247f:	55                   	push   %ebp
c0022480:	6a 00                	push   $0x0
c0022482:	68 c4 00 00 00       	push   $0xc4
c0022487:	e9 4b f7 ff ff       	jmp    c0021bd7 <intr_entry>

c002248c <intrc5_stub>:
c002248c:	55                   	push   %ebp
c002248d:	6a 00                	push   $0x0
c002248f:	68 c5 00 00 00       	push   $0xc5
c0022494:	e9 3e f7 ff ff       	jmp    c0021bd7 <intr_entry>

c0022499 <intrc6_stub>:
c0022499:	55                   	push   %ebp
c002249a:	6a 00                	push   $0x0
c002249c:	68 c6 00 00 00       	push   $0xc6
c00224a1:	e9 31 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c00224a6 <intrc7_stub>:
c00224a6:	55                   	push   %ebp
c00224a7:	6a 00                	push   $0x0
c00224a9:	68 c7 00 00 00       	push   $0xc7
c00224ae:	e9 24 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c00224b3 <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c00224b3:	55                   	push   %ebp
c00224b4:	6a 00                	push   $0x0
c00224b6:	68 c8 00 00 00       	push   $0xc8
c00224bb:	e9 17 f7 ff ff       	jmp    c0021bd7 <intr_entry>

c00224c0 <intrc9_stub>:
c00224c0:	55                   	push   %ebp
c00224c1:	6a 00                	push   $0x0
c00224c3:	68 c9 00 00 00       	push   $0xc9
c00224c8:	e9 0a f7 ff ff       	jmp    c0021bd7 <intr_entry>

c00224cd <intrca_stub>:
c00224cd:	55                   	push   %ebp
c00224ce:	6a 00                	push   $0x0
c00224d0:	68 ca 00 00 00       	push   $0xca
c00224d5:	e9 fd f6 ff ff       	jmp    c0021bd7 <intr_entry>

c00224da <intrcb_stub>:
c00224da:	55                   	push   %ebp
c00224db:	6a 00                	push   $0x0
c00224dd:	68 cb 00 00 00       	push   $0xcb
c00224e2:	e9 f0 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c00224e7 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c00224e7:	55                   	push   %ebp
c00224e8:	6a 00                	push   $0x0
c00224ea:	68 cc 00 00 00       	push   $0xcc
c00224ef:	e9 e3 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c00224f4 <intrcd_stub>:
c00224f4:	55                   	push   %ebp
c00224f5:	6a 00                	push   $0x0
c00224f7:	68 cd 00 00 00       	push   $0xcd
c00224fc:	e9 d6 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022501 <intrce_stub>:
c0022501:	55                   	push   %ebp
c0022502:	6a 00                	push   $0x0
c0022504:	68 ce 00 00 00       	push   $0xce
c0022509:	e9 c9 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c002250e <intrcf_stub>:
c002250e:	55                   	push   %ebp
c002250f:	6a 00                	push   $0x0
c0022511:	68 cf 00 00 00       	push   $0xcf
c0022516:	e9 bc f6 ff ff       	jmp    c0021bd7 <intr_entry>

c002251b <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c002251b:	55                   	push   %ebp
c002251c:	6a 00                	push   $0x0
c002251e:	68 d0 00 00 00       	push   $0xd0
c0022523:	e9 af f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022528 <intrd1_stub>:
c0022528:	55                   	push   %ebp
c0022529:	6a 00                	push   $0x0
c002252b:	68 d1 00 00 00       	push   $0xd1
c0022530:	e9 a2 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022535 <intrd2_stub>:
c0022535:	55                   	push   %ebp
c0022536:	6a 00                	push   $0x0
c0022538:	68 d2 00 00 00       	push   $0xd2
c002253d:	e9 95 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022542 <intrd3_stub>:
c0022542:	55                   	push   %ebp
c0022543:	6a 00                	push   $0x0
c0022545:	68 d3 00 00 00       	push   $0xd3
c002254a:	e9 88 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c002254f <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c002254f:	55                   	push   %ebp
c0022550:	6a 00                	push   $0x0
c0022552:	68 d4 00 00 00       	push   $0xd4
c0022557:	e9 7b f6 ff ff       	jmp    c0021bd7 <intr_entry>

c002255c <intrd5_stub>:
c002255c:	55                   	push   %ebp
c002255d:	6a 00                	push   $0x0
c002255f:	68 d5 00 00 00       	push   $0xd5
c0022564:	e9 6e f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022569 <intrd6_stub>:
c0022569:	55                   	push   %ebp
c002256a:	6a 00                	push   $0x0
c002256c:	68 d6 00 00 00       	push   $0xd6
c0022571:	e9 61 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022576 <intrd7_stub>:
c0022576:	55                   	push   %ebp
c0022577:	6a 00                	push   $0x0
c0022579:	68 d7 00 00 00       	push   $0xd7
c002257e:	e9 54 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022583 <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022583:	55                   	push   %ebp
c0022584:	6a 00                	push   $0x0
c0022586:	68 d8 00 00 00       	push   $0xd8
c002258b:	e9 47 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c0022590 <intrd9_stub>:
c0022590:	55                   	push   %ebp
c0022591:	6a 00                	push   $0x0
c0022593:	68 d9 00 00 00       	push   $0xd9
c0022598:	e9 3a f6 ff ff       	jmp    c0021bd7 <intr_entry>

c002259d <intrda_stub>:
c002259d:	55                   	push   %ebp
c002259e:	6a 00                	push   $0x0
c00225a0:	68 da 00 00 00       	push   $0xda
c00225a5:	e9 2d f6 ff ff       	jmp    c0021bd7 <intr_entry>

c00225aa <intrdb_stub>:
c00225aa:	55                   	push   %ebp
c00225ab:	6a 00                	push   $0x0
c00225ad:	68 db 00 00 00       	push   $0xdb
c00225b2:	e9 20 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c00225b7 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c00225b7:	55                   	push   %ebp
c00225b8:	6a 00                	push   $0x0
c00225ba:	68 dc 00 00 00       	push   $0xdc
c00225bf:	e9 13 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c00225c4 <intrdd_stub>:
c00225c4:	55                   	push   %ebp
c00225c5:	6a 00                	push   $0x0
c00225c7:	68 dd 00 00 00       	push   $0xdd
c00225cc:	e9 06 f6 ff ff       	jmp    c0021bd7 <intr_entry>

c00225d1 <intrde_stub>:
c00225d1:	55                   	push   %ebp
c00225d2:	6a 00                	push   $0x0
c00225d4:	68 de 00 00 00       	push   $0xde
c00225d9:	e9 f9 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00225de <intrdf_stub>:
c00225de:	55                   	push   %ebp
c00225df:	6a 00                	push   $0x0
c00225e1:	68 df 00 00 00       	push   $0xdf
c00225e6:	e9 ec f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00225eb <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c00225eb:	55                   	push   %ebp
c00225ec:	6a 00                	push   $0x0
c00225ee:	68 e0 00 00 00       	push   $0xe0
c00225f3:	e9 df f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00225f8 <intre1_stub>:
c00225f8:	55                   	push   %ebp
c00225f9:	6a 00                	push   $0x0
c00225fb:	68 e1 00 00 00       	push   $0xe1
c0022600:	e9 d2 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022605 <intre2_stub>:
c0022605:	55                   	push   %ebp
c0022606:	6a 00                	push   $0x0
c0022608:	68 e2 00 00 00       	push   $0xe2
c002260d:	e9 c5 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022612 <intre3_stub>:
c0022612:	55                   	push   %ebp
c0022613:	6a 00                	push   $0x0
c0022615:	68 e3 00 00 00       	push   $0xe3
c002261a:	e9 b8 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c002261f <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c002261f:	55                   	push   %ebp
c0022620:	6a 00                	push   $0x0
c0022622:	68 e4 00 00 00       	push   $0xe4
c0022627:	e9 ab f5 ff ff       	jmp    c0021bd7 <intr_entry>

c002262c <intre5_stub>:
c002262c:	55                   	push   %ebp
c002262d:	6a 00                	push   $0x0
c002262f:	68 e5 00 00 00       	push   $0xe5
c0022634:	e9 9e f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022639 <intre6_stub>:
c0022639:	55                   	push   %ebp
c002263a:	6a 00                	push   $0x0
c002263c:	68 e6 00 00 00       	push   $0xe6
c0022641:	e9 91 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022646 <intre7_stub>:
c0022646:	55                   	push   %ebp
c0022647:	6a 00                	push   $0x0
c0022649:	68 e7 00 00 00       	push   $0xe7
c002264e:	e9 84 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022653 <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022653:	55                   	push   %ebp
c0022654:	6a 00                	push   $0x0
c0022656:	68 e8 00 00 00       	push   $0xe8
c002265b:	e9 77 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022660 <intre9_stub>:
c0022660:	55                   	push   %ebp
c0022661:	6a 00                	push   $0x0
c0022663:	68 e9 00 00 00       	push   $0xe9
c0022668:	e9 6a f5 ff ff       	jmp    c0021bd7 <intr_entry>

c002266d <intrea_stub>:
c002266d:	55                   	push   %ebp
c002266e:	6a 00                	push   $0x0
c0022670:	68 ea 00 00 00       	push   $0xea
c0022675:	e9 5d f5 ff ff       	jmp    c0021bd7 <intr_entry>

c002267a <intreb_stub>:
c002267a:	55                   	push   %ebp
c002267b:	6a 00                	push   $0x0
c002267d:	68 eb 00 00 00       	push   $0xeb
c0022682:	e9 50 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022687 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022687:	55                   	push   %ebp
c0022688:	6a 00                	push   $0x0
c002268a:	68 ec 00 00 00       	push   $0xec
c002268f:	e9 43 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c0022694 <intred_stub>:
c0022694:	55                   	push   %ebp
c0022695:	6a 00                	push   $0x0
c0022697:	68 ed 00 00 00       	push   $0xed
c002269c:	e9 36 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00226a1 <intree_stub>:
c00226a1:	55                   	push   %ebp
c00226a2:	6a 00                	push   $0x0
c00226a4:	68 ee 00 00 00       	push   $0xee
c00226a9:	e9 29 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00226ae <intref_stub>:
c00226ae:	55                   	push   %ebp
c00226af:	6a 00                	push   $0x0
c00226b1:	68 ef 00 00 00       	push   $0xef
c00226b6:	e9 1c f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00226bb <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c00226bb:	55                   	push   %ebp
c00226bc:	6a 00                	push   $0x0
c00226be:	68 f0 00 00 00       	push   $0xf0
c00226c3:	e9 0f f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00226c8 <intrf1_stub>:
c00226c8:	55                   	push   %ebp
c00226c9:	6a 00                	push   $0x0
c00226cb:	68 f1 00 00 00       	push   $0xf1
c00226d0:	e9 02 f5 ff ff       	jmp    c0021bd7 <intr_entry>

c00226d5 <intrf2_stub>:
c00226d5:	55                   	push   %ebp
c00226d6:	6a 00                	push   $0x0
c00226d8:	68 f2 00 00 00       	push   $0xf2
c00226dd:	e9 f5 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c00226e2 <intrf3_stub>:
c00226e2:	55                   	push   %ebp
c00226e3:	6a 00                	push   $0x0
c00226e5:	68 f3 00 00 00       	push   $0xf3
c00226ea:	e9 e8 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c00226ef <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c00226ef:	55                   	push   %ebp
c00226f0:	6a 00                	push   $0x0
c00226f2:	68 f4 00 00 00       	push   $0xf4
c00226f7:	e9 db f4 ff ff       	jmp    c0021bd7 <intr_entry>

c00226fc <intrf5_stub>:
c00226fc:	55                   	push   %ebp
c00226fd:	6a 00                	push   $0x0
c00226ff:	68 f5 00 00 00       	push   $0xf5
c0022704:	e9 ce f4 ff ff       	jmp    c0021bd7 <intr_entry>

c0022709 <intrf6_stub>:
c0022709:	55                   	push   %ebp
c002270a:	6a 00                	push   $0x0
c002270c:	68 f6 00 00 00       	push   $0xf6
c0022711:	e9 c1 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c0022716 <intrf7_stub>:
c0022716:	55                   	push   %ebp
c0022717:	6a 00                	push   $0x0
c0022719:	68 f7 00 00 00       	push   $0xf7
c002271e:	e9 b4 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c0022723 <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c0022723:	55                   	push   %ebp
c0022724:	6a 00                	push   $0x0
c0022726:	68 f8 00 00 00       	push   $0xf8
c002272b:	e9 a7 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c0022730 <intrf9_stub>:
c0022730:	55                   	push   %ebp
c0022731:	6a 00                	push   $0x0
c0022733:	68 f9 00 00 00       	push   $0xf9
c0022738:	e9 9a f4 ff ff       	jmp    c0021bd7 <intr_entry>

c002273d <intrfa_stub>:
c002273d:	55                   	push   %ebp
c002273e:	6a 00                	push   $0x0
c0022740:	68 fa 00 00 00       	push   $0xfa
c0022745:	e9 8d f4 ff ff       	jmp    c0021bd7 <intr_entry>

c002274a <intrfb_stub>:
c002274a:	55                   	push   %ebp
c002274b:	6a 00                	push   $0x0
c002274d:	68 fb 00 00 00       	push   $0xfb
c0022752:	e9 80 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c0022757 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c0022757:	55                   	push   %ebp
c0022758:	6a 00                	push   $0x0
c002275a:	68 fc 00 00 00       	push   $0xfc
c002275f:	e9 73 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c0022764 <intrfd_stub>:
c0022764:	55                   	push   %ebp
c0022765:	6a 00                	push   $0x0
c0022767:	68 fd 00 00 00       	push   $0xfd
c002276c:	e9 66 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c0022771 <intrfe_stub>:
c0022771:	55                   	push   %ebp
c0022772:	6a 00                	push   $0x0
c0022774:	68 fe 00 00 00       	push   $0xfe
c0022779:	e9 59 f4 ff ff       	jmp    c0021bd7 <intr_entry>

c002277e <intrff_stub>:
c002277e:	55                   	push   %ebp
c002277f:	6a 00                	push   $0x0
c0022781:	68 ff 00 00 00       	push   $0xff
c0022786:	e9 4c f4 ff ff       	jmp    c0021bd7 <intr_entry>

c002278b <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c002278b:	55                   	push   %ebp
c002278c:	89 e5                	mov    %esp,%ebp
c002278e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c0022791:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022795:	75 1e                	jne    c00227b5 <sema_init+0x2a>
c0022797:	83 ec 0c             	sub    $0xc,%esp
c002279a:	68 6c ef 02 c0       	push   $0xc002ef6c
c002279f:	68 79 ef 02 c0       	push   $0xc002ef79
c00227a4:	68 40 f0 02 c0       	push   $0xc002f040
c00227a9:	6a 2f                	push   $0x2f
c00227ab:	68 90 ef 02 c0       	push   $0xc002ef90
c00227b0:	e8 73 6d 00 00       	call   c0029528 <debug_panic>

  sema->value = value;
c00227b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00227b8:	8b 55 0c             	mov    0xc(%ebp),%edx
c00227bb:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c00227bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00227c0:	83 c0 04             	add    $0x4,%eax
c00227c3:	83 ec 0c             	sub    $0xc,%esp
c00227c6:	50                   	push   %eax
c00227c7:	e8 cd 6f 00 00       	call   c0029799 <list_init>
c00227cc:	83 c4 10             	add    $0x10,%esp
}
c00227cf:	90                   	nop
c00227d0:	c9                   	leave  
c00227d1:	c3                   	ret    

c00227d2 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c00227d2:	55                   	push   %ebp
c00227d3:	89 e5                	mov    %esp,%ebp
c00227d5:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c00227d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00227dc:	75 1e                	jne    c00227fc <sema_down+0x2a>
c00227de:	83 ec 0c             	sub    $0xc,%esp
c00227e1:	68 6c ef 02 c0       	push   $0xc002ef6c
c00227e6:	68 79 ef 02 c0       	push   $0xc002ef79
c00227eb:	68 4c f0 02 c0       	push   $0xc002f04c
c00227f0:	6a 41                	push   $0x41
c00227f2:	68 90 ef 02 c0       	push   $0xc002ef90
c00227f7:	e8 2c 6d 00 00       	call   c0029528 <debug_panic>
  ASSERT (!intr_context ());
c00227fc:	e8 58 ee ff ff       	call   c0021659 <intr_context>
c0022801:	83 f0 01             	xor    $0x1,%eax
c0022804:	84 c0                	test   %al,%al
c0022806:	75 1e                	jne    c0022826 <sema_down+0x54>
c0022808:	83 ec 0c             	sub    $0xc,%esp
c002280b:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022810:	68 79 ef 02 c0       	push   $0xc002ef79
c0022815:	68 4c f0 02 c0       	push   $0xc002f04c
c002281a:	6a 42                	push   $0x42
c002281c:	68 90 ef 02 c0       	push   $0xc002ef90
c0022821:	e8 02 6d 00 00       	call   c0029528 <debug_panic>

  old_level = intr_disable ();
c0022826:	e8 61 eb ff ff       	call   c002138c <intr_disable>
c002282b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (sema->value == 0) 
c002282e:	eb 20                	jmp    c0022850 <sema_down+0x7e>
    {
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022830:	e8 2e e4 ff ff       	call   c0020c63 <thread_current>
c0022835:	8d 50 28             	lea    0x28(%eax),%edx
c0022838:	8b 45 08             	mov    0x8(%ebp),%eax
c002283b:	83 c0 04             	add    $0x4,%eax
c002283e:	83 ec 08             	sub    $0x8,%esp
c0022841:	52                   	push   %edx
c0022842:	50                   	push   %eax
c0022843:	e8 31 73 00 00       	call   c0029b79 <list_push_back>
c0022848:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c002284b:	e8 f3 e2 ff ff       	call   c0020b43 <thread_block>
  while (sema->value == 0) 
c0022850:	8b 45 08             	mov    0x8(%ebp),%eax
c0022853:	8b 00                	mov    (%eax),%eax
c0022855:	85 c0                	test   %eax,%eax
c0022857:	74 d7                	je     c0022830 <sema_down+0x5e>
    }
  sema->value--;
c0022859:	8b 45 08             	mov    0x8(%ebp),%eax
c002285c:	8b 00                	mov    (%eax),%eax
c002285e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022861:	8b 45 08             	mov    0x8(%ebp),%eax
c0022864:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022866:	83 ec 0c             	sub    $0xc,%esp
c0022869:	ff 75 f4             	pushl  -0xc(%ebp)
c002286c:	e8 c3 ea ff ff       	call   c0021334 <intr_set_level>
c0022871:	83 c4 10             	add    $0x10,%esp
}
c0022874:	90                   	nop
c0022875:	c9                   	leave  
c0022876:	c3                   	ret    

c0022877 <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022877:	55                   	push   %ebp
c0022878:	89 e5                	mov    %esp,%ebp
c002287a:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c002287d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022881:	75 1e                	jne    c00228a1 <sema_try_down+0x2a>
c0022883:	83 ec 0c             	sub    $0xc,%esp
c0022886:	68 6c ef 02 c0       	push   $0xc002ef6c
c002288b:	68 79 ef 02 c0       	push   $0xc002ef79
c0022890:	68 58 f0 02 c0       	push   $0xc002f058
c0022895:	6a 59                	push   $0x59
c0022897:	68 90 ef 02 c0       	push   $0xc002ef90
c002289c:	e8 87 6c 00 00       	call   c0029528 <debug_panic>

  old_level = intr_disable ();
c00228a1:	e8 e6 ea ff ff       	call   c002138c <intr_disable>
c00228a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c00228a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00228ac:	8b 00                	mov    (%eax),%eax
c00228ae:	85 c0                	test   %eax,%eax
c00228b0:	74 13                	je     c00228c5 <sema_try_down+0x4e>
    {
      sema->value--;
c00228b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00228b5:	8b 00                	mov    (%eax),%eax
c00228b7:	8d 50 ff             	lea    -0x1(%eax),%edx
c00228ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00228bd:	89 10                	mov    %edx,(%eax)
      success = true; 
c00228bf:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c00228c3:	eb 04                	jmp    c00228c9 <sema_try_down+0x52>
    }
  else
    success = false;
c00228c5:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c00228c9:	83 ec 0c             	sub    $0xc,%esp
c00228cc:	ff 75 f0             	pushl  -0x10(%ebp)
c00228cf:	e8 60 ea ff ff       	call   c0021334 <intr_set_level>
c00228d4:	83 c4 10             	add    $0x10,%esp

  return success;
c00228d7:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c00228da:	c9                   	leave  
c00228db:	c3                   	ret    

c00228dc <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c00228dc:	55                   	push   %ebp
c00228dd:	89 e5                	mov    %esp,%ebp
c00228df:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (sema != NULL);
c00228e2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00228e6:	75 1e                	jne    c0022906 <sema_up+0x2a>
c00228e8:	83 ec 0c             	sub    $0xc,%esp
c00228eb:	68 6c ef 02 c0       	push   $0xc002ef6c
c00228f0:	68 79 ef 02 c0       	push   $0xc002ef79
c00228f5:	68 68 f0 02 c0       	push   $0xc002f068
c00228fa:	6a 71                	push   $0x71
c00228fc:	68 90 ef 02 c0       	push   $0xc002ef90
c0022901:	e8 22 6c 00 00       	call   c0029528 <debug_panic>

  old_level = intr_disable ();
c0022906:	e8 81 ea ff ff       	call   c002138c <intr_disable>
c002290b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (!list_empty (&sema->waiters)) 
c002290e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022911:	83 c0 04             	add    $0x4,%eax
c0022914:	83 ec 0c             	sub    $0xc,%esp
c0022917:	50                   	push   %eax
c0022918:	e8 03 74 00 00       	call   c0029d20 <list_empty>
c002291d:	83 c4 10             	add    $0x10,%esp
c0022920:	83 f0 01             	xor    $0x1,%eax
c0022923:	84 c0                	test   %al,%al
c0022925:	74 24                	je     c002294b <sema_up+0x6f>
    thread_unblock (list_entry (list_pop_front (&sema->waiters),
c0022927:	8b 45 08             	mov    0x8(%ebp),%eax
c002292a:	83 c0 04             	add    $0x4,%eax
c002292d:	83 ec 0c             	sub    $0xc,%esp
c0022930:	50                   	push   %eax
c0022931:	e8 c2 72 00 00       	call   c0029bf8 <list_pop_front>
c0022936:	83 c4 10             	add    $0x10,%esp
c0022939:	83 c0 04             	add    $0x4,%eax
c002293c:	83 e8 2c             	sub    $0x2c,%eax
c002293f:	83 ec 0c             	sub    $0xc,%esp
c0022942:	50                   	push   %eax
c0022943:	e8 6c e2 ff ff       	call   c0020bb4 <thread_unblock>
c0022948:	83 c4 10             	add    $0x10,%esp
                                struct thread, elem));
  sema->value++;
c002294b:	8b 45 08             	mov    0x8(%ebp),%eax
c002294e:	8b 00                	mov    (%eax),%eax
c0022950:	8d 50 01             	lea    0x1(%eax),%edx
c0022953:	8b 45 08             	mov    0x8(%ebp),%eax
c0022956:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022958:	83 ec 0c             	sub    $0xc,%esp
c002295b:	ff 75 f4             	pushl  -0xc(%ebp)
c002295e:	e8 d1 e9 ff ff       	call   c0021334 <intr_set_level>
c0022963:	83 c4 10             	add    $0x10,%esp
}
c0022966:	90                   	nop
c0022967:	c9                   	leave  
c0022968:	c3                   	ret    

c0022969 <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c0022969:	55                   	push   %ebp
c002296a:	89 e5                	mov    %esp,%ebp
c002296c:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c002296f:	83 ec 0c             	sub    $0xc,%esp
c0022972:	68 b7 ef 02 c0       	push   $0xc002efb7
c0022977:	e8 ed 47 00 00       	call   c0027169 <printf>
c002297c:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c002297f:	83 ec 08             	sub    $0x8,%esp
c0022982:	6a 00                	push   $0x0
c0022984:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022987:	50                   	push   %eax
c0022988:	e8 fe fd ff ff       	call   c002278b <sema_init>
c002298d:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c0022990:	83 ec 08             	sub    $0x8,%esp
c0022993:	6a 00                	push   $0x0
c0022995:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022998:	83 c0 14             	add    $0x14,%eax
c002299b:	50                   	push   %eax
c002299c:	e8 ea fd ff ff       	call   c002278b <sema_init>
c00229a1:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c00229a4:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229a7:	50                   	push   %eax
c00229a8:	68 02 2a 02 c0       	push   $0xc0022a02
c00229ad:	6a 1f                	push   $0x1f
c00229af:	68 cd ef 02 c0       	push   $0xc002efcd
c00229b4:	e8 91 e0 ff ff       	call   c0020a4a <thread_create>
c00229b9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00229bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00229c3:	eb 24                	jmp    c00229e9 <sema_self_test+0x80>
    {
      sema_up (&sema[0]);
c00229c5:	83 ec 0c             	sub    $0xc,%esp
c00229c8:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229cb:	50                   	push   %eax
c00229cc:	e8 0b ff ff ff       	call   c00228dc <sema_up>
c00229d1:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c00229d4:	83 ec 0c             	sub    $0xc,%esp
c00229d7:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00229da:	83 c0 14             	add    $0x14,%eax
c00229dd:	50                   	push   %eax
c00229de:	e8 ef fd ff ff       	call   c00227d2 <sema_down>
c00229e3:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c00229e6:	ff 45 f4             	incl   -0xc(%ebp)
c00229e9:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c00229ed:	7e d6                	jle    c00229c5 <sema_self_test+0x5c>
    }
  printf ("done.\n");
c00229ef:	83 ec 0c             	sub    $0xc,%esp
c00229f2:	68 d7 ef 02 c0       	push   $0xc002efd7
c00229f7:	e8 ed 8c 00 00       	call   c002b6e9 <puts>
c00229fc:	83 c4 10             	add    $0x10,%esp
}
c00229ff:	90                   	nop
c0022a00:	c9                   	leave  
c0022a01:	c3                   	ret    

c0022a02 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022a02:	55                   	push   %ebp
c0022a03:	89 e5                	mov    %esp,%ebp
c0022a05:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0022a08:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c0022a0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022a15:	eb 23                	jmp    c0022a3a <sema_test_helper+0x38>
    {
      sema_down (&sema[0]);
c0022a17:	83 ec 0c             	sub    $0xc,%esp
c0022a1a:	ff 75 f0             	pushl  -0x10(%ebp)
c0022a1d:	e8 b0 fd ff ff       	call   c00227d2 <sema_down>
c0022a22:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c0022a25:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022a28:	83 c0 14             	add    $0x14,%eax
c0022a2b:	83 ec 0c             	sub    $0xc,%esp
c0022a2e:	50                   	push   %eax
c0022a2f:	e8 a8 fe ff ff       	call   c00228dc <sema_up>
c0022a34:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022a37:	ff 45 f4             	incl   -0xc(%ebp)
c0022a3a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022a3e:	7e d7                	jle    c0022a17 <sema_test_helper+0x15>
    }
}
c0022a40:	90                   	nop
c0022a41:	c9                   	leave  
c0022a42:	c3                   	ret    

c0022a43 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022a43:	55                   	push   %ebp
c0022a44:	89 e5                	mov    %esp,%ebp
c0022a46:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022a49:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022a4d:	75 21                	jne    c0022a70 <lock_init+0x2d>
c0022a4f:	83 ec 0c             	sub    $0xc,%esp
c0022a52:	68 dd ef 02 c0       	push   $0xc002efdd
c0022a57:	68 79 ef 02 c0       	push   $0xc002ef79
c0022a5c:	68 70 f0 02 c0       	push   $0xc002f070
c0022a61:	68 b2 00 00 00       	push   $0xb2
c0022a66:	68 90 ef 02 c0       	push   $0xc002ef90
c0022a6b:	e8 b8 6a 00 00       	call   c0029528 <debug_panic>

  lock->holder = NULL;
c0022a70:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0022a79:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a7c:	83 c0 04             	add    $0x4,%eax
c0022a7f:	83 ec 08             	sub    $0x8,%esp
c0022a82:	6a 01                	push   $0x1
c0022a84:	50                   	push   %eax
c0022a85:	e8 01 fd ff ff       	call   c002278b <sema_init>
c0022a8a:	83 c4 10             	add    $0x10,%esp
}
c0022a8d:	90                   	nop
c0022a8e:	c9                   	leave  
c0022a8f:	c3                   	ret    

c0022a90 <lock_acquire>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
lock_acquire (struct lock *lock)
{
c0022a90:	55                   	push   %ebp
c0022a91:	89 e5                	mov    %esp,%ebp
c0022a93:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022a96:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022a9a:	75 21                	jne    c0022abd <lock_acquire+0x2d>
c0022a9c:	83 ec 0c             	sub    $0xc,%esp
c0022a9f:	68 dd ef 02 c0       	push   $0xc002efdd
c0022aa4:	68 79 ef 02 c0       	push   $0xc002ef79
c0022aa9:	68 7c f0 02 c0       	push   $0xc002f07c
c0022aae:	68 c3 00 00 00       	push   $0xc3
c0022ab3:	68 90 ef 02 c0       	push   $0xc002ef90
c0022ab8:	e8 6b 6a 00 00       	call   c0029528 <debug_panic>
  ASSERT (!intr_context ());
c0022abd:	e8 97 eb ff ff       	call   c0021659 <intr_context>
c0022ac2:	83 f0 01             	xor    $0x1,%eax
c0022ac5:	84 c0                	test   %al,%al
c0022ac7:	75 21                	jne    c0022aea <lock_acquire+0x5a>
c0022ac9:	83 ec 0c             	sub    $0xc,%esp
c0022acc:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022ad1:	68 79 ef 02 c0       	push   $0xc002ef79
c0022ad6:	68 7c f0 02 c0       	push   $0xc002f07c
c0022adb:	68 c4 00 00 00       	push   $0xc4
c0022ae0:	68 90 ef 02 c0       	push   $0xc002ef90
c0022ae5:	e8 3e 6a 00 00       	call   c0029528 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022aea:	83 ec 0c             	sub    $0xc,%esp
c0022aed:	ff 75 08             	pushl  0x8(%ebp)
c0022af0:	e8 59 01 00 00       	call   c0022c4e <lock_held_by_current_thread>
c0022af5:	83 c4 10             	add    $0x10,%esp
c0022af8:	83 f0 01             	xor    $0x1,%eax
c0022afb:	84 c0                	test   %al,%al
c0022afd:	75 21                	jne    c0022b20 <lock_acquire+0x90>
c0022aff:	83 ec 0c             	sub    $0xc,%esp
c0022b02:	68 ec ef 02 c0       	push   $0xc002efec
c0022b07:	68 79 ef 02 c0       	push   $0xc002ef79
c0022b0c:	68 7c f0 02 c0       	push   $0xc002f07c
c0022b11:	68 c5 00 00 00       	push   $0xc5
c0022b16:	68 90 ef 02 c0       	push   $0xc002ef90
c0022b1b:	e8 08 6a 00 00       	call   c0029528 <debug_panic>

  sema_down (&lock->semaphore);
c0022b20:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b23:	83 c0 04             	add    $0x4,%eax
c0022b26:	83 ec 0c             	sub    $0xc,%esp
c0022b29:	50                   	push   %eax
c0022b2a:	e8 a3 fc ff ff       	call   c00227d2 <sema_down>
c0022b2f:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c0022b32:	e8 2c e1 ff ff       	call   c0020c63 <thread_current>
c0022b37:	89 c2                	mov    %eax,%edx
c0022b39:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b3c:	89 10                	mov    %edx,(%eax)
}
c0022b3e:	90                   	nop
c0022b3f:	c9                   	leave  
c0022b40:	c3                   	ret    

c0022b41 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0022b41:	55                   	push   %ebp
c0022b42:	89 e5                	mov    %esp,%ebp
c0022b44:	83 ec 18             	sub    $0x18,%esp
  bool success;

  ASSERT (lock != NULL);
c0022b47:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022b4b:	75 21                	jne    c0022b6e <lock_try_acquire+0x2d>
c0022b4d:	83 ec 0c             	sub    $0xc,%esp
c0022b50:	68 dd ef 02 c0       	push   $0xc002efdd
c0022b55:	68 79 ef 02 c0       	push   $0xc002ef79
c0022b5a:	68 8c f0 02 c0       	push   $0xc002f08c
c0022b5f:	68 d6 00 00 00       	push   $0xd6
c0022b64:	68 90 ef 02 c0       	push   $0xc002ef90
c0022b69:	e8 ba 69 00 00       	call   c0029528 <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022b6e:	83 ec 0c             	sub    $0xc,%esp
c0022b71:	ff 75 08             	pushl  0x8(%ebp)
c0022b74:	e8 d5 00 00 00       	call   c0022c4e <lock_held_by_current_thread>
c0022b79:	83 c4 10             	add    $0x10,%esp
c0022b7c:	83 f0 01             	xor    $0x1,%eax
c0022b7f:	84 c0                	test   %al,%al
c0022b81:	75 21                	jne    c0022ba4 <lock_try_acquire+0x63>
c0022b83:	83 ec 0c             	sub    $0xc,%esp
c0022b86:	68 ec ef 02 c0       	push   $0xc002efec
c0022b8b:	68 79 ef 02 c0       	push   $0xc002ef79
c0022b90:	68 8c f0 02 c0       	push   $0xc002f08c
c0022b95:	68 d7 00 00 00       	push   $0xd7
c0022b9a:	68 90 ef 02 c0       	push   $0xc002ef90
c0022b9f:	e8 84 69 00 00       	call   c0029528 <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0022ba4:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ba7:	83 c0 04             	add    $0x4,%eax
c0022baa:	83 ec 0c             	sub    $0xc,%esp
c0022bad:	50                   	push   %eax
c0022bae:	e8 c4 fc ff ff       	call   c0022877 <sema_try_down>
c0022bb3:	83 c4 10             	add    $0x10,%esp
c0022bb6:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success)
c0022bb9:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0022bbd:	74 0c                	je     c0022bcb <lock_try_acquire+0x8a>
    lock->holder = thread_current ();
c0022bbf:	e8 9f e0 ff ff       	call   c0020c63 <thread_current>
c0022bc4:	89 c2                	mov    %eax,%edx
c0022bc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0022bc9:	89 10                	mov    %edx,(%eax)
  return success;
c0022bcb:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0022bce:	c9                   	leave  
c0022bcf:	c3                   	ret    

c0022bd0 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0022bd0:	55                   	push   %ebp
c0022bd1:	89 e5                	mov    %esp,%ebp
c0022bd3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022bd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022bda:	75 21                	jne    c0022bfd <lock_release+0x2d>
c0022bdc:	83 ec 0c             	sub    $0xc,%esp
c0022bdf:	68 dd ef 02 c0       	push   $0xc002efdd
c0022be4:	68 79 ef 02 c0       	push   $0xc002ef79
c0022be9:	68 a0 f0 02 c0       	push   $0xc002f0a0
c0022bee:	68 e7 00 00 00       	push   $0xe7
c0022bf3:	68 90 ef 02 c0       	push   $0xc002ef90
c0022bf8:	e8 2b 69 00 00       	call   c0029528 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022bfd:	83 ec 0c             	sub    $0xc,%esp
c0022c00:	ff 75 08             	pushl  0x8(%ebp)
c0022c03:	e8 46 00 00 00       	call   c0022c4e <lock_held_by_current_thread>
c0022c08:	83 c4 10             	add    $0x10,%esp
c0022c0b:	84 c0                	test   %al,%al
c0022c0d:	75 21                	jne    c0022c30 <lock_release+0x60>
c0022c0f:	83 ec 0c             	sub    $0xc,%esp
c0022c12:	68 10 f0 02 c0       	push   $0xc002f010
c0022c17:	68 79 ef 02 c0       	push   $0xc002ef79
c0022c1c:	68 a0 f0 02 c0       	push   $0xc002f0a0
c0022c21:	68 e8 00 00 00       	push   $0xe8
c0022c26:	68 90 ef 02 c0       	push   $0xc002ef90
c0022c2b:	e8 f8 68 00 00       	call   c0029528 <debug_panic>

  lock->holder = NULL;
c0022c30:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c33:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up (&lock->semaphore);
c0022c39:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c3c:	83 c0 04             	add    $0x4,%eax
c0022c3f:	83 ec 0c             	sub    $0xc,%esp
c0022c42:	50                   	push   %eax
c0022c43:	e8 94 fc ff ff       	call   c00228dc <sema_up>
c0022c48:	83 c4 10             	add    $0x10,%esp
}
c0022c4b:	90                   	nop
c0022c4c:	c9                   	leave  
c0022c4d:	c3                   	ret    

c0022c4e <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0022c4e:	55                   	push   %ebp
c0022c4f:	89 e5                	mov    %esp,%ebp
c0022c51:	53                   	push   %ebx
c0022c52:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c0022c55:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022c59:	75 21                	jne    c0022c7c <lock_held_by_current_thread+0x2e>
c0022c5b:	83 ec 0c             	sub    $0xc,%esp
c0022c5e:	68 dd ef 02 c0       	push   $0xc002efdd
c0022c63:	68 79 ef 02 c0       	push   $0xc002ef79
c0022c68:	68 b0 f0 02 c0       	push   $0xc002f0b0
c0022c6d:	68 f4 00 00 00       	push   $0xf4
c0022c72:	68 90 ef 02 c0       	push   $0xc002ef90
c0022c77:	e8 ac 68 00 00       	call   c0029528 <debug_panic>

  return lock->holder == thread_current ();
c0022c7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c7f:	8b 18                	mov    (%eax),%ebx
c0022c81:	e8 dd df ff ff       	call   c0020c63 <thread_current>
c0022c86:	39 c3                	cmp    %eax,%ebx
c0022c88:	0f 94 c0             	sete   %al
}
c0022c8b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022c8e:	c9                   	leave  
c0022c8f:	c3                   	ret    

c0022c90 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0022c90:	55                   	push   %ebp
c0022c91:	89 e5                	mov    %esp,%ebp
c0022c93:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022c96:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022c9a:	75 21                	jne    c0022cbd <cond_init+0x2d>
c0022c9c:	83 ec 0c             	sub    $0xc,%esp
c0022c9f:	68 33 f0 02 c0       	push   $0xc002f033
c0022ca4:	68 79 ef 02 c0       	push   $0xc002ef79
c0022ca9:	68 cc f0 02 c0       	push   $0xc002f0cc
c0022cae:	68 06 01 00 00       	push   $0x106
c0022cb3:	68 90 ef 02 c0       	push   $0xc002ef90
c0022cb8:	e8 6b 68 00 00       	call   c0029528 <debug_panic>

  list_init (&cond->waiters);
c0022cbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0022cc0:	83 ec 0c             	sub    $0xc,%esp
c0022cc3:	50                   	push   %eax
c0022cc4:	e8 d0 6a 00 00       	call   c0029799 <list_init>
c0022cc9:	83 c4 10             	add    $0x10,%esp
}
c0022ccc:	90                   	nop
c0022ccd:	c9                   	leave  
c0022cce:	c3                   	ret    

c0022ccf <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c0022ccf:	55                   	push   %ebp
c0022cd0:	89 e5                	mov    %esp,%ebp
c0022cd2:	83 ec 28             	sub    $0x28,%esp
  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c0022cd5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022cd9:	75 21                	jne    c0022cfc <cond_wait+0x2d>
c0022cdb:	83 ec 0c             	sub    $0xc,%esp
c0022cde:	68 33 f0 02 c0       	push   $0xc002f033
c0022ce3:	68 79 ef 02 c0       	push   $0xc002ef79
c0022ce8:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022ced:	68 24 01 00 00       	push   $0x124
c0022cf2:	68 90 ef 02 c0       	push   $0xc002ef90
c0022cf7:	e8 2c 68 00 00       	call   c0029528 <debug_panic>
  ASSERT (lock != NULL);
c0022cfc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022d00:	75 21                	jne    c0022d23 <cond_wait+0x54>
c0022d02:	83 ec 0c             	sub    $0xc,%esp
c0022d05:	68 dd ef 02 c0       	push   $0xc002efdd
c0022d0a:	68 79 ef 02 c0       	push   $0xc002ef79
c0022d0f:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022d14:	68 25 01 00 00       	push   $0x125
c0022d19:	68 90 ef 02 c0       	push   $0xc002ef90
c0022d1e:	e8 05 68 00 00       	call   c0029528 <debug_panic>
  ASSERT (!intr_context ());
c0022d23:	e8 31 e9 ff ff       	call   c0021659 <intr_context>
c0022d28:	83 f0 01             	xor    $0x1,%eax
c0022d2b:	84 c0                	test   %al,%al
c0022d2d:	75 21                	jne    c0022d50 <cond_wait+0x81>
c0022d2f:	83 ec 0c             	sub    $0xc,%esp
c0022d32:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022d37:	68 79 ef 02 c0       	push   $0xc002ef79
c0022d3c:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022d41:	68 26 01 00 00       	push   $0x126
c0022d46:	68 90 ef 02 c0       	push   $0xc002ef90
c0022d4b:	e8 d8 67 00 00       	call   c0029528 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022d50:	83 ec 0c             	sub    $0xc,%esp
c0022d53:	ff 75 0c             	pushl  0xc(%ebp)
c0022d56:	e8 f3 fe ff ff       	call   c0022c4e <lock_held_by_current_thread>
c0022d5b:	83 c4 10             	add    $0x10,%esp
c0022d5e:	84 c0                	test   %al,%al
c0022d60:	75 21                	jne    c0022d83 <cond_wait+0xb4>
c0022d62:	83 ec 0c             	sub    $0xc,%esp
c0022d65:	68 10 f0 02 c0       	push   $0xc002f010
c0022d6a:	68 79 ef 02 c0       	push   $0xc002ef79
c0022d6f:	68 d8 f0 02 c0       	push   $0xc002f0d8
c0022d74:	68 27 01 00 00       	push   $0x127
c0022d79:	68 90 ef 02 c0       	push   $0xc002ef90
c0022d7e:	e8 a5 67 00 00       	call   c0029528 <debug_panic>
  
  sema_init (&waiter.semaphore, 0);
c0022d83:	83 ec 08             	sub    $0x8,%esp
c0022d86:	6a 00                	push   $0x0
c0022d88:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022d8b:	83 c0 08             	add    $0x8,%eax
c0022d8e:	50                   	push   %eax
c0022d8f:	e8 f7 f9 ff ff       	call   c002278b <sema_init>
c0022d94:	83 c4 10             	add    $0x10,%esp
  list_push_back (&cond->waiters, &waiter.elem);
c0022d97:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d9a:	83 ec 08             	sub    $0x8,%esp
c0022d9d:	8d 55 dc             	lea    -0x24(%ebp),%edx
c0022da0:	52                   	push   %edx
c0022da1:	50                   	push   %eax
c0022da2:	e8 d2 6d 00 00       	call   c0029b79 <list_push_back>
c0022da7:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0022daa:	83 ec 0c             	sub    $0xc,%esp
c0022dad:	ff 75 0c             	pushl  0xc(%ebp)
c0022db0:	e8 1b fe ff ff       	call   c0022bd0 <lock_release>
c0022db5:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c0022db8:	83 ec 0c             	sub    $0xc,%esp
c0022dbb:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0022dbe:	83 c0 08             	add    $0x8,%eax
c0022dc1:	50                   	push   %eax
c0022dc2:	e8 0b fa ff ff       	call   c00227d2 <sema_down>
c0022dc7:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c0022dca:	83 ec 0c             	sub    $0xc,%esp
c0022dcd:	ff 75 0c             	pushl  0xc(%ebp)
c0022dd0:	e8 bb fc ff ff       	call   c0022a90 <lock_acquire>
c0022dd5:	83 c4 10             	add    $0x10,%esp
}
c0022dd8:	90                   	nop
c0022dd9:	c9                   	leave  
c0022dda:	c3                   	ret    

c0022ddb <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c0022ddb:	55                   	push   %ebp
c0022ddc:	89 e5                	mov    %esp,%ebp
c0022dde:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022de1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022de5:	75 21                	jne    c0022e08 <cond_signal+0x2d>
c0022de7:	83 ec 0c             	sub    $0xc,%esp
c0022dea:	68 33 f0 02 c0       	push   $0xc002f033
c0022def:	68 79 ef 02 c0       	push   $0xc002ef79
c0022df4:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022df9:	68 3a 01 00 00       	push   $0x13a
c0022dfe:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e03:	e8 20 67 00 00       	call   c0029528 <debug_panic>
  ASSERT (lock != NULL);
c0022e08:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022e0c:	75 21                	jne    c0022e2f <cond_signal+0x54>
c0022e0e:	83 ec 0c             	sub    $0xc,%esp
c0022e11:	68 dd ef 02 c0       	push   $0xc002efdd
c0022e16:	68 79 ef 02 c0       	push   $0xc002ef79
c0022e1b:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022e20:	68 3b 01 00 00       	push   $0x13b
c0022e25:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e2a:	e8 f9 66 00 00       	call   c0029528 <debug_panic>
  ASSERT (!intr_context ());
c0022e2f:	e8 25 e8 ff ff       	call   c0021659 <intr_context>
c0022e34:	83 f0 01             	xor    $0x1,%eax
c0022e37:	84 c0                	test   %al,%al
c0022e39:	75 21                	jne    c0022e5c <cond_signal+0x81>
c0022e3b:	83 ec 0c             	sub    $0xc,%esp
c0022e3e:	68 a6 ef 02 c0       	push   $0xc002efa6
c0022e43:	68 79 ef 02 c0       	push   $0xc002ef79
c0022e48:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022e4d:	68 3c 01 00 00       	push   $0x13c
c0022e52:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e57:	e8 cc 66 00 00       	call   c0029528 <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022e5c:	83 ec 0c             	sub    $0xc,%esp
c0022e5f:	ff 75 0c             	pushl  0xc(%ebp)
c0022e62:	e8 e7 fd ff ff       	call   c0022c4e <lock_held_by_current_thread>
c0022e67:	83 c4 10             	add    $0x10,%esp
c0022e6a:	84 c0                	test   %al,%al
c0022e6c:	75 21                	jne    c0022e8f <cond_signal+0xb4>
c0022e6e:	83 ec 0c             	sub    $0xc,%esp
c0022e71:	68 10 f0 02 c0       	push   $0xc002f010
c0022e76:	68 79 ef 02 c0       	push   $0xc002ef79
c0022e7b:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0022e80:	68 3d 01 00 00       	push   $0x13d
c0022e85:	68 90 ef 02 c0       	push   $0xc002ef90
c0022e8a:	e8 99 66 00 00       	call   c0029528 <debug_panic>

  if (!list_empty (&cond->waiters)) 
c0022e8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e92:	83 ec 0c             	sub    $0xc,%esp
c0022e95:	50                   	push   %eax
c0022e96:	e8 85 6e 00 00       	call   c0029d20 <list_empty>
c0022e9b:	83 c4 10             	add    $0x10,%esp
c0022e9e:	83 f0 01             	xor    $0x1,%eax
c0022ea1:	84 c0                	test   %al,%al
c0022ea3:	74 24                	je     c0022ec9 <cond_signal+0xee>
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c0022ea5:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ea8:	83 ec 0c             	sub    $0xc,%esp
c0022eab:	50                   	push   %eax
c0022eac:	e8 47 6d 00 00       	call   c0029bf8 <list_pop_front>
c0022eb1:	83 c4 10             	add    $0x10,%esp
c0022eb4:	83 c0 04             	add    $0x4,%eax
c0022eb7:	83 e8 04             	sub    $0x4,%eax
c0022eba:	83 c0 08             	add    $0x8,%eax
c0022ebd:	83 ec 0c             	sub    $0xc,%esp
c0022ec0:	50                   	push   %eax
c0022ec1:	e8 16 fa ff ff       	call   c00228dc <sema_up>
c0022ec6:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
}
c0022ec9:	90                   	nop
c0022eca:	c9                   	leave  
c0022ecb:	c3                   	ret    

c0022ecc <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c0022ecc:	55                   	push   %ebp
c0022ecd:	89 e5                	mov    %esp,%ebp
c0022ecf:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c0022ed2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ed6:	75 21                	jne    c0022ef9 <cond_broadcast+0x2d>
c0022ed8:	83 ec 0c             	sub    $0xc,%esp
c0022edb:	68 33 f0 02 c0       	push   $0xc002f033
c0022ee0:	68 79 ef 02 c0       	push   $0xc002ef79
c0022ee5:	68 f0 f0 02 c0       	push   $0xc002f0f0
c0022eea:	68 4d 01 00 00       	push   $0x14d
c0022eef:	68 90 ef 02 c0       	push   $0xc002ef90
c0022ef4:	e8 2f 66 00 00       	call   c0029528 <debug_panic>
  ASSERT (lock != NULL);
c0022ef9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0022efd:	75 32                	jne    c0022f31 <cond_broadcast+0x65>
c0022eff:	83 ec 0c             	sub    $0xc,%esp
c0022f02:	68 dd ef 02 c0       	push   $0xc002efdd
c0022f07:	68 79 ef 02 c0       	push   $0xc002ef79
c0022f0c:	68 f0 f0 02 c0       	push   $0xc002f0f0
c0022f11:	68 4e 01 00 00       	push   $0x14e
c0022f16:	68 90 ef 02 c0       	push   $0xc002ef90
c0022f1b:	e8 08 66 00 00       	call   c0029528 <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c0022f20:	83 ec 08             	sub    $0x8,%esp
c0022f23:	ff 75 0c             	pushl  0xc(%ebp)
c0022f26:	ff 75 08             	pushl  0x8(%ebp)
c0022f29:	e8 ad fe ff ff       	call   c0022ddb <cond_signal>
c0022f2e:	83 c4 10             	add    $0x10,%esp
  while (!list_empty (&cond->waiters))
c0022f31:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f34:	83 ec 0c             	sub    $0xc,%esp
c0022f37:	50                   	push   %eax
c0022f38:	e8 e3 6d 00 00       	call   c0029d20 <list_empty>
c0022f3d:	83 c4 10             	add    $0x10,%esp
c0022f40:	83 f0 01             	xor    $0x1,%eax
c0022f43:	84 c0                	test   %al,%al
c0022f45:	75 d9                	jne    c0022f20 <cond_broadcast+0x54>
}
c0022f47:	90                   	nop
c0022f48:	c9                   	leave  
c0022f49:	c3                   	ret    

c0022f4a <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c0022f4a:	55                   	push   %ebp
c0022f4b:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0022f4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f50:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0022f55:	5d                   	pop    %ebp
c0022f56:	c3                   	ret    

c0022f57 <pg_no>:
static inline uintptr_t pg_no (const void *va) {
c0022f57:	55                   	push   %ebp
c0022f58:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PGBITS;
c0022f5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f5d:	c1 e8 0c             	shr    $0xc,%eax
}
c0022f60:	5d                   	pop    %ebp
c0022f61:	c3                   	ret    

c0022f62 <ptov>:
{
c0022f62:	55                   	push   %ebp
c0022f63:	89 e5                	mov    %esp,%ebp
c0022f65:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0022f68:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f6b:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0022f70:	76 1e                	jbe    c0022f90 <ptov+0x2e>
c0022f72:	83 ec 0c             	sub    $0xc,%esp
c0022f75:	68 00 f1 02 c0       	push   $0xc002f100
c0022f7a:	68 1b f1 02 c0       	push   $0xc002f11b
c0022f7f:	68 38 f2 02 c0       	push   $0xc002f238
c0022f84:	6a 4a                	push   $0x4a
c0022f86:	68 32 f1 02 c0       	push   $0xc002f132
c0022f8b:	e8 98 65 00 00       	call   c0029528 <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c0022f90:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f93:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0022f98:	c9                   	leave  
c0022f99:	c3                   	ret    

c0022f9a <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c0022f9a:	55                   	push   %ebp
c0022f9b:	89 e5                	mov    %esp,%ebp
c0022f9d:	83 ec 28             	sub    $0x28,%esp
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c0022fa0:	83 ec 0c             	sub    $0xc,%esp
c0022fa3:	68 00 00 10 00       	push   $0x100000
c0022fa8:	e8 b5 ff ff ff       	call   c0022f62 <ptov>
c0022fad:	83 c4 10             	add    $0x10,%esp
c0022fb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c0022fb3:	a1 5e 01 02 c0       	mov    0xc002015e,%eax
c0022fb8:	c1 e0 0c             	shl    $0xc,%eax
c0022fbb:	83 ec 0c             	sub    $0xc,%esp
c0022fbe:	50                   	push   %eax
c0022fbf:	e8 9e ff ff ff       	call   c0022f62 <ptov>
c0022fc4:	83 c4 10             	add    $0x10,%esp
c0022fc7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0022fca:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0022fcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022fd0:	29 c2                	sub    %eax,%edx
c0022fd2:	89 d0                	mov    %edx,%eax
c0022fd4:	85 c0                	test   %eax,%eax
c0022fd6:	79 05                	jns    c0022fdd <palloc_init+0x43>
c0022fd8:	05 ff 0f 00 00       	add    $0xfff,%eax
c0022fdd:	c1 f8 0c             	sar    $0xc,%eax
c0022fe0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c0022fe3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0022fe6:	d1 e8                	shr    %eax
c0022fe8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c0022feb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0022fee:	3b 45 08             	cmp    0x8(%ebp),%eax
c0022ff1:	76 06                	jbe    c0022ff9 <palloc_init+0x5f>
    user_pages = user_page_limit;
c0022ff3:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ff6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c0022ff9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0022ffc:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0022fff:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023002:	68 48 f1 02 c0       	push   $0xc002f148
c0023007:	ff 75 e4             	pushl  -0x1c(%ebp)
c002300a:	ff 75 f0             	pushl  -0x10(%ebp)
c002300d:	68 80 86 03 c0       	push   $0xc0038680
c0023012:	e8 6e 02 00 00       	call   c0023285 <init_pool>
c0023017:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c002301a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002301d:	c1 e0 0c             	shl    $0xc,%eax
c0023020:	89 c2                	mov    %eax,%edx
c0023022:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023025:	01 d0                	add    %edx,%eax
c0023027:	68 54 f1 02 c0       	push   $0xc002f154
c002302c:	ff 75 f4             	pushl  -0xc(%ebp)
c002302f:	50                   	push   %eax
c0023030:	68 a0 86 03 c0       	push   $0xc00386a0
c0023035:	e8 4b 02 00 00       	call   c0023285 <init_pool>
c002303a:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c002303d:	90                   	nop
c002303e:	c9                   	leave  
c002303f:	c3                   	ret    

c0023040 <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c0023040:	55                   	push   %ebp
c0023041:	89 e5                	mov    %esp,%ebp
c0023043:	83 ec 18             	sub    $0x18,%esp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023046:	8b 45 08             	mov    0x8(%ebp),%eax
c0023049:	83 e0 04             	and    $0x4,%eax
c002304c:	85 c0                	test   %eax,%eax
c002304e:	74 07                	je     c0023057 <palloc_get_multiple+0x17>
c0023050:	b8 a0 86 03 c0       	mov    $0xc00386a0,%eax
c0023055:	eb 05                	jmp    c002305c <palloc_get_multiple+0x1c>
c0023057:	b8 80 86 03 c0       	mov    $0xc0038680,%eax
c002305c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c002305f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023063:	75 0a                	jne    c002306f <palloc_get_multiple+0x2f>
    return NULL;
c0023065:	b8 00 00 00 00       	mov    $0x0,%eax
c002306a:	e9 a3 00 00 00       	jmp    c0023112 <palloc_get_multiple+0xd2>

  lock_acquire (&pool->lock);
c002306f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023072:	83 ec 0c             	sub    $0xc,%esp
c0023075:	50                   	push   %eax
c0023076:	e8 15 fa ff ff       	call   c0022a90 <lock_acquire>
c002307b:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c002307e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023081:	8b 40 18             	mov    0x18(%eax),%eax
c0023084:	6a 00                	push   $0x0
c0023086:	ff 75 0c             	pushl  0xc(%ebp)
c0023089:	6a 00                	push   $0x0
c002308b:	50                   	push   %eax
c002308c:	e8 bc 7b 00 00       	call   c002ac4d <bitmap_scan_and_flip>
c0023091:	83 c4 10             	add    $0x10,%esp
c0023094:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c0023097:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002309a:	83 ec 0c             	sub    $0xc,%esp
c002309d:	50                   	push   %eax
c002309e:	e8 2d fb ff ff       	call   c0022bd0 <lock_release>
c00230a3:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c00230a6:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00230aa:	74 13                	je     c00230bf <palloc_get_multiple+0x7f>
    pages = pool->base + PGSIZE * page_idx;
c00230ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230af:	8b 40 1c             	mov    0x1c(%eax),%eax
c00230b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00230b5:	c1 e2 0c             	shl    $0xc,%edx
c00230b8:	01 d0                	add    %edx,%eax
c00230ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00230bd:	eb 07                	jmp    c00230c6 <palloc_get_multiple+0x86>
  else
    pages = NULL;
c00230bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c00230c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00230ca:	74 23                	je     c00230ef <palloc_get_multiple+0xaf>
    {
      if (flags & PAL_ZERO)
c00230cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00230cf:	83 e0 02             	and    $0x2,%eax
c00230d2:	85 c0                	test   %eax,%eax
c00230d4:	74 39                	je     c002310f <palloc_get_multiple+0xcf>
        memset (pages, 0, PGSIZE * page_cnt);
c00230d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00230d9:	c1 e0 0c             	shl    $0xc,%eax
c00230dc:	83 ec 04             	sub    $0x4,%esp
c00230df:	50                   	push   %eax
c00230e0:	6a 00                	push   $0x0
c00230e2:	ff 75 f4             	pushl  -0xc(%ebp)
c00230e5:	e8 58 58 00 00       	call   c0028942 <memset>
c00230ea:	83 c4 10             	add    $0x10,%esp
c00230ed:	eb 20                	jmp    c002310f <palloc_get_multiple+0xcf>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c00230ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00230f2:	83 e0 01             	and    $0x1,%eax
c00230f5:	85 c0                	test   %eax,%eax
c00230f7:	74 16                	je     c002310f <palloc_get_multiple+0xcf>
        PANIC ("palloc_get: out of pages");
c00230f9:	68 5e f1 02 c0       	push   $0xc002f15e
c00230fe:	68 40 f2 02 c0       	push   $0xc002f240
c0023103:	6a 61                	push   $0x61
c0023105:	68 77 f1 02 c0       	push   $0xc002f177
c002310a:	e8 19 64 00 00       	call   c0029528 <debug_panic>
    }

  return pages;
c002310f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023112:	c9                   	leave  
c0023113:	c3                   	ret    

c0023114 <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c0023114:	55                   	push   %ebp
c0023115:	89 e5                	mov    %esp,%ebp
c0023117:	83 ec 08             	sub    $0x8,%esp
  return palloc_get_multiple (flags, 1);
c002311a:	83 ec 08             	sub    $0x8,%esp
c002311d:	6a 01                	push   $0x1
c002311f:	ff 75 08             	pushl  0x8(%ebp)
c0023122:	e8 19 ff ff ff       	call   c0023040 <palloc_get_multiple>
c0023127:	83 c4 10             	add    $0x10,%esp
}
c002312a:	c9                   	leave  
c002312b:	c3                   	ret    

c002312c <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c002312c:	55                   	push   %ebp
c002312d:	89 e5                	mov    %esp,%ebp
c002312f:	53                   	push   %ebx
c0023130:	83 ec 14             	sub    $0x14,%esp
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c0023133:	ff 75 08             	pushl  0x8(%ebp)
c0023136:	e8 0f fe ff ff       	call   c0022f4a <pg_ofs>
c002313b:	83 c4 04             	add    $0x4,%esp
c002313e:	85 c0                	test   %eax,%eax
c0023140:	74 1e                	je     c0023160 <palloc_free_multiple+0x34>
c0023142:	83 ec 0c             	sub    $0xc,%esp
c0023145:	68 8e f1 02 c0       	push   $0xc002f18e
c002314a:	68 1b f1 02 c0       	push   $0xc002f11b
c002314f:	68 54 f2 02 c0       	push   $0xc002f254
c0023154:	6a 7b                	push   $0x7b
c0023156:	68 77 f1 02 c0       	push   $0xc002f177
c002315b:	e8 c8 63 00 00       	call   c0029528 <debug_panic>
  if (pages == NULL || page_cnt == 0)
c0023160:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023164:	0f 84 fc 00 00 00    	je     c0023266 <palloc_free_multiple+0x13a>
c002316a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002316e:	0f 84 f2 00 00 00    	je     c0023266 <palloc_free_multiple+0x13a>
    return;

  if (page_from_pool (&kernel_pool, pages))
c0023174:	83 ec 08             	sub    $0x8,%esp
c0023177:	ff 75 08             	pushl  0x8(%ebp)
c002317a:	68 80 86 03 c0       	push   $0xc0038680
c002317f:	e8 a8 01 00 00       	call   c002332c <page_from_pool>
c0023184:	83 c4 10             	add    $0x10,%esp
c0023187:	84 c0                	test   %al,%al
c0023189:	74 09                	je     c0023194 <palloc_free_multiple+0x68>
    pool = &kernel_pool;
c002318b:	c7 45 f4 80 86 03 c0 	movl   $0xc0038680,-0xc(%ebp)
c0023192:	eb 39                	jmp    c00231cd <palloc_free_multiple+0xa1>
  else if (page_from_pool (&user_pool, pages))
c0023194:	83 ec 08             	sub    $0x8,%esp
c0023197:	ff 75 08             	pushl  0x8(%ebp)
c002319a:	68 a0 86 03 c0       	push   $0xc00386a0
c002319f:	e8 88 01 00 00       	call   c002332c <page_from_pool>
c00231a4:	83 c4 10             	add    $0x10,%esp
c00231a7:	84 c0                	test   %al,%al
c00231a9:	74 09                	je     c00231b4 <palloc_free_multiple+0x88>
    pool = &user_pool;
c00231ab:	c7 45 f4 a0 86 03 c0 	movl   $0xc00386a0,-0xc(%ebp)
c00231b2:	eb 19                	jmp    c00231cd <palloc_free_multiple+0xa1>
  else
    NOT_REACHED ();
c00231b4:	68 a4 f1 02 c0       	push   $0xc002f1a4
c00231b9:	68 54 f2 02 c0       	push   $0xc002f254
c00231be:	68 84 00 00 00       	push   $0x84
c00231c3:	68 77 f1 02 c0       	push   $0xc002f177
c00231c8:	e8 5b 63 00 00       	call   c0029528 <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c00231cd:	83 ec 0c             	sub    $0xc,%esp
c00231d0:	ff 75 08             	pushl  0x8(%ebp)
c00231d3:	e8 7f fd ff ff       	call   c0022f57 <pg_no>
c00231d8:	83 c4 10             	add    $0x10,%esp
c00231db:	89 c3                	mov    %eax,%ebx
c00231dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00231e0:	8b 40 1c             	mov    0x1c(%eax),%eax
c00231e3:	83 ec 0c             	sub    $0xc,%esp
c00231e6:	50                   	push   %eax
c00231e7:	e8 6b fd ff ff       	call   c0022f57 <pg_no>
c00231ec:	83 c4 10             	add    $0x10,%esp
c00231ef:	29 c3                	sub    %eax,%ebx
c00231f1:	89 d8                	mov    %ebx,%eax
c00231f3:	89 45 f0             	mov    %eax,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c00231f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00231f9:	c1 e0 0c             	shl    $0xc,%eax
c00231fc:	83 ec 04             	sub    $0x4,%esp
c00231ff:	50                   	push   %eax
c0023200:	68 cc 00 00 00       	push   $0xcc
c0023205:	ff 75 08             	pushl  0x8(%ebp)
c0023208:	e8 35 57 00 00       	call   c0028942 <memset>
c002320d:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023210:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023213:	8b 40 18             	mov    0x18(%eax),%eax
c0023216:	83 ec 04             	sub    $0x4,%esp
c0023219:	ff 75 0c             	pushl  0xc(%ebp)
c002321c:	ff 75 f0             	pushl  -0x10(%ebp)
c002321f:	50                   	push   %eax
c0023220:	e8 3c 79 00 00       	call   c002ab61 <bitmap_all>
c0023225:	83 c4 10             	add    $0x10,%esp
c0023228:	84 c0                	test   %al,%al
c002322a:	75 21                	jne    c002324d <palloc_free_multiple+0x121>
c002322c:	83 ec 0c             	sub    $0xc,%esp
c002322f:	68 c8 f1 02 c0       	push   $0xc002f1c8
c0023234:	68 1b f1 02 c0       	push   $0xc002f11b
c0023239:	68 54 f2 02 c0       	push   $0xc002f254
c002323e:	68 8c 00 00 00       	push   $0x8c
c0023243:	68 77 f1 02 c0       	push   $0xc002f177
c0023248:	e8 db 62 00 00       	call   c0029528 <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c002324d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023250:	8b 40 18             	mov    0x18(%eax),%eax
c0023253:	6a 00                	push   $0x0
c0023255:	ff 75 0c             	pushl  0xc(%ebp)
c0023258:	ff 75 f0             	pushl  -0x10(%ebp)
c002325b:	50                   	push   %eax
c002325c:	e8 5f 76 00 00       	call   c002a8c0 <bitmap_set_multiple>
c0023261:	83 c4 10             	add    $0x10,%esp
c0023264:	eb 01                	jmp    c0023267 <palloc_free_multiple+0x13b>
    return;
c0023266:	90                   	nop
}
c0023267:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002326a:	c9                   	leave  
c002326b:	c3                   	ret    

c002326c <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c002326c:	55                   	push   %ebp
c002326d:	89 e5                	mov    %esp,%ebp
c002326f:	83 ec 08             	sub    $0x8,%esp
  palloc_free_multiple (page, 1);
c0023272:	83 ec 08             	sub    $0x8,%esp
c0023275:	6a 01                	push   $0x1
c0023277:	ff 75 08             	pushl  0x8(%ebp)
c002327a:	e8 ad fe ff ff       	call   c002312c <palloc_free_multiple>
c002327f:	83 c4 10             	add    $0x10,%esp
}
c0023282:	90                   	nop
c0023283:	c9                   	leave  
c0023284:	c3                   	ret    

c0023285 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0023285:	55                   	push   %ebp
c0023286:	89 e5                	mov    %esp,%ebp
c0023288:	83 ec 18             	sub    $0x18,%esp
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c002328b:	83 ec 0c             	sub    $0xc,%esp
c002328e:	ff 75 10             	pushl  0x10(%ebp)
c0023291:	e8 c0 73 00 00       	call   c002a656 <bitmap_buf_size>
c0023296:	83 c4 10             	add    $0x10,%esp
c0023299:	05 ff 0f 00 00       	add    $0xfff,%eax
c002329e:	c1 e8 0c             	shr    $0xc,%eax
c00232a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c00232a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00232a7:	3b 45 10             	cmp    0x10(%ebp),%eax
c00232aa:	76 1f                	jbe    c00232cb <init_pool+0x46>
    PANIC ("Not enough memory in %s for bitmap.", name);
c00232ac:	83 ec 0c             	sub    $0xc,%esp
c00232af:	ff 75 14             	pushl  0x14(%ebp)
c00232b2:	68 f8 f1 02 c0       	push   $0xc002f1f8
c00232b7:	68 6c f2 02 c0       	push   $0xc002f26c
c00232bc:	68 a1 00 00 00       	push   $0xa1
c00232c1:	68 77 f1 02 c0       	push   $0xc002f177
c00232c6:	e8 5d 62 00 00       	call   c0029528 <debug_panic>
  page_cnt -= bm_pages;
c00232cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00232ce:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c00232d1:	83 ec 04             	sub    $0x4,%esp
c00232d4:	ff 75 14             	pushl  0x14(%ebp)
c00232d7:	ff 75 10             	pushl  0x10(%ebp)
c00232da:	68 1c f2 02 c0       	push   $0xc002f21c
c00232df:	e8 85 3e 00 00       	call   c0027169 <printf>
c00232e4:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c00232e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00232ea:	83 ec 0c             	sub    $0xc,%esp
c00232ed:	50                   	push   %eax
c00232ee:	e8 50 f7 ff ff       	call   c0022a43 <lock_init>
c00232f3:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c00232f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00232f9:	c1 e0 0c             	shl    $0xc,%eax
c00232fc:	83 ec 04             	sub    $0x4,%esp
c00232ff:	50                   	push   %eax
c0023300:	ff 75 0c             	pushl  0xc(%ebp)
c0023303:	ff 75 10             	pushl  0x10(%ebp)
c0023306:	e8 e5 72 00 00       	call   c002a5f0 <bitmap_create_in_buf>
c002330b:	83 c4 10             	add    $0x10,%esp
c002330e:	89 c2                	mov    %eax,%edx
c0023310:	8b 45 08             	mov    0x8(%ebp),%eax
c0023313:	89 50 18             	mov    %edx,0x18(%eax)
  p->base = base + bm_pages * PGSIZE;
c0023316:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023319:	c1 e0 0c             	shl    $0xc,%eax
c002331c:	89 c2                	mov    %eax,%edx
c002331e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023321:	01 c2                	add    %eax,%edx
c0023323:	8b 45 08             	mov    0x8(%ebp),%eax
c0023326:	89 50 1c             	mov    %edx,0x1c(%eax)
}
c0023329:	90                   	nop
c002332a:	c9                   	leave  
c002332b:	c3                   	ret    

c002332c <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c002332c:	55                   	push   %ebp
c002332d:	89 e5                	mov    %esp,%ebp
c002332f:	83 ec 18             	sub    $0x18,%esp
  size_t page_no = pg_no (page);
c0023332:	ff 75 0c             	pushl  0xc(%ebp)
c0023335:	e8 1d fc ff ff       	call   c0022f57 <pg_no>
c002333a:	83 c4 04             	add    $0x4,%esp
c002333d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c0023340:	8b 45 08             	mov    0x8(%ebp),%eax
c0023343:	8b 40 1c             	mov    0x1c(%eax),%eax
c0023346:	50                   	push   %eax
c0023347:	e8 0b fc ff ff       	call   c0022f57 <pg_no>
c002334c:	83 c4 04             	add    $0x4,%esp
c002334f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023352:	8b 45 08             	mov    0x8(%ebp),%eax
c0023355:	8b 40 18             	mov    0x18(%eax),%eax
c0023358:	83 ec 0c             	sub    $0xc,%esp
c002335b:	50                   	push   %eax
c002335c:	e8 37 73 00 00       	call   c002a698 <bitmap_size>
c0023361:	83 c4 10             	add    $0x10,%esp
c0023364:	89 c2                	mov    %eax,%edx
c0023366:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023369:	01 d0                	add    %edx,%eax
c002336b:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c002336e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023371:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023374:	72 0f                	jb     c0023385 <page_from_pool+0x59>
c0023376:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023379:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002337c:	73 07                	jae    c0023385 <page_from_pool+0x59>
c002337e:	b8 01 00 00 00       	mov    $0x1,%eax
c0023383:	eb 05                	jmp    c002338a <page_from_pool+0x5e>
c0023385:	b8 00 00 00 00       	mov    $0x0,%eax
c002338a:	83 e0 01             	and    $0x1,%eax
}
c002338d:	c9                   	leave  
c002338e:	c3                   	ret    

c002338f <pg_ofs>:
static inline unsigned pg_ofs (const void *va) {
c002338f:	55                   	push   %ebp
c0023390:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0023392:	8b 45 08             	mov    0x8(%ebp),%eax
c0023395:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002339a:	5d                   	pop    %ebp
c002339b:	c3                   	ret    

c002339c <pg_round_down>:
static inline void *pg_round_down (const void *va) {
c002339c:	55                   	push   %ebp
c002339d:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c002339f:	8b 45 08             	mov    0x8(%ebp),%eax
c00233a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00233a7:	5d                   	pop    %ebp
c00233a8:	c3                   	ret    

c00233a9 <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c00233a9:	55                   	push   %ebp
c00233aa:	89 e5                	mov    %esp,%ebp
c00233ac:	83 ec 18             	sub    $0x18,%esp
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00233af:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c00233b6:	e9 90 00 00 00       	jmp    c002344b <malloc_init+0xa2>
    {
      struct desc *d = &descs[desc_cnt++];
c00233bb:	8b 15 a0 88 03 c0    	mov    0xc00388a0,%edx
c00233c1:	8d 42 01             	lea    0x1(%edx),%eax
c00233c4:	a3 a0 88 03 c0       	mov    %eax,0xc00388a0
c00233c9:	89 d0                	mov    %edx,%eax
c00233cb:	01 c0                	add    %eax,%eax
c00233cd:	01 d0                	add    %edx,%eax
c00233cf:	c1 e0 04             	shl    $0x4,%eax
c00233d2:	05 c0 86 03 c0       	add    $0xc00386c0,%eax
c00233d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00233da:	a1 a0 88 03 c0       	mov    0xc00388a0,%eax
c00233df:	83 f8 0a             	cmp    $0xa,%eax
c00233e2:	76 1e                	jbe    c0023402 <malloc_init+0x59>
c00233e4:	83 ec 0c             	sub    $0xc,%esp
c00233e7:	68 78 f2 02 c0       	push   $0xc002f278
c00233ec:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00233f1:	68 ac f3 02 c0       	push   $0xc002f3ac
c00233f6:	6a 4f                	push   $0x4f
c00233f8:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00233fd:	e8 26 61 00 00       	call   c0029528 <debug_panic>
      d->block_size = block_size;
c0023402:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023405:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023408:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c002340a:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c002340f:	ba 00 00 00 00       	mov    $0x0,%edx
c0023414:	f7 75 f4             	divl   -0xc(%ebp)
c0023417:	89 c2                	mov    %eax,%edx
c0023419:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002341c:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c002341f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023422:	83 c0 08             	add    $0x8,%eax
c0023425:	83 ec 0c             	sub    $0xc,%esp
c0023428:	50                   	push   %eax
c0023429:	e8 6b 63 00 00       	call   c0029799 <list_init>
c002342e:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c0023431:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023434:	83 c0 18             	add    $0x18,%eax
c0023437:	83 ec 0c             	sub    $0xc,%esp
c002343a:	50                   	push   %eax
c002343b:	e8 03 f6 ff ff       	call   c0022a43 <lock_init>
c0023440:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0023443:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023446:	01 c0                	add    %eax,%eax
c0023448:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002344b:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0023452:	0f 86 63 ff ff ff    	jbe    c00233bb <malloc_init+0x12>
    }
}
c0023458:	90                   	nop
c0023459:	c9                   	leave  
c002345a:	c3                   	ret    

c002345b <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c002345b:	55                   	push   %ebp
c002345c:	89 e5                	mov    %esp,%ebp
c002345e:	83 ec 28             	sub    $0x28,%esp
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0023461:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023465:	75 0a                	jne    c0023471 <malloc+0x16>
    return NULL;
c0023467:	b8 00 00 00 00       	mov    $0x0,%eax
c002346c:	e9 b1 01 00 00       	jmp    c0023622 <malloc+0x1c7>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c0023471:	c7 45 f4 c0 86 03 c0 	movl   $0xc00386c0,-0xc(%ebp)
c0023478:	eb 0e                	jmp    c0023488 <malloc+0x2d>
    if (d->block_size >= size)
c002347a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002347d:	8b 00                	mov    (%eax),%eax
c002347f:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023482:	73 1f                	jae    c00234a3 <malloc+0x48>
  for (d = descs; d < descs + desc_cnt; d++)
c0023484:	83 45 f4 30          	addl   $0x30,-0xc(%ebp)
c0023488:	8b 15 a0 88 03 c0    	mov    0xc00388a0,%edx
c002348e:	89 d0                	mov    %edx,%eax
c0023490:	01 c0                	add    %eax,%eax
c0023492:	01 d0                	add    %edx,%eax
c0023494:	c1 e0 04             	shl    $0x4,%eax
c0023497:	05 c0 86 03 c0       	add    $0xc00386c0,%eax
c002349c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002349f:	77 d9                	ja     c002347a <malloc+0x1f>
c00234a1:	eb 01                	jmp    c00234a4 <malloc+0x49>
      break;
c00234a3:	90                   	nop
  if (d == descs + desc_cnt) 
c00234a4:	8b 15 a0 88 03 c0    	mov    0xc00388a0,%edx
c00234aa:	89 d0                	mov    %edx,%eax
c00234ac:	01 c0                	add    %eax,%eax
c00234ae:	01 d0                	add    %edx,%eax
c00234b0:	c1 e0 04             	shl    $0x4,%eax
c00234b3:	05 c0 86 03 c0       	add    $0xc00386c0,%eax
c00234b8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00234bb:	75 58                	jne    c0023515 <malloc+0xba>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c00234bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00234c0:	05 0b 10 00 00       	add    $0x100b,%eax
c00234c5:	c1 e8 0c             	shr    $0xc,%eax
c00234c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c00234cb:	83 ec 08             	sub    $0x8,%esp
c00234ce:	ff 75 ec             	pushl  -0x14(%ebp)
c00234d1:	6a 00                	push   $0x0
c00234d3:	e8 68 fb ff ff       	call   c0023040 <palloc_get_multiple>
c00234d8:	83 c4 10             	add    $0x10,%esp
c00234db:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL)
c00234de:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00234e2:	75 0a                	jne    c00234ee <malloc+0x93>
        return NULL;
c00234e4:	b8 00 00 00 00       	mov    $0x0,%eax
c00234e9:	e9 34 01 00 00       	jmp    c0023622 <malloc+0x1c7>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c00234ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00234f1:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c00234f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00234fa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023501:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023504:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023507:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c002350a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002350d:	83 c0 0c             	add    $0xc,%eax
c0023510:	e9 0d 01 00 00       	jmp    c0023622 <malloc+0x1c7>
    }

  lock_acquire (&d->lock);
c0023515:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023518:	83 c0 18             	add    $0x18,%eax
c002351b:	83 ec 0c             	sub    $0xc,%esp
c002351e:	50                   	push   %eax
c002351f:	e8 6c f5 ff ff       	call   c0022a90 <lock_acquire>
c0023524:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c0023527:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002352a:	83 c0 08             	add    $0x8,%eax
c002352d:	83 ec 0c             	sub    $0xc,%esp
c0023530:	50                   	push   %eax
c0023531:	e8 ea 67 00 00       	call   c0029d20 <list_empty>
c0023536:	83 c4 10             	add    $0x10,%esp
c0023539:	84 c0                	test   %al,%al
c002353b:	0f 84 91 00 00 00    	je     c00235d2 <malloc+0x177>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0023541:	83 ec 0c             	sub    $0xc,%esp
c0023544:	6a 00                	push   $0x0
c0023546:	e8 c9 fb ff ff       	call   c0023114 <palloc_get_page>
c002354b:	83 c4 10             	add    $0x10,%esp
c002354e:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL) 
c0023551:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023555:	75 1c                	jne    c0023573 <malloc+0x118>
        {
          lock_release (&d->lock);
c0023557:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002355a:	83 c0 18             	add    $0x18,%eax
c002355d:	83 ec 0c             	sub    $0xc,%esp
c0023560:	50                   	push   %eax
c0023561:	e8 6a f6 ff ff       	call   c0022bd0 <lock_release>
c0023566:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c0023569:	b8 00 00 00 00       	mov    $0x0,%eax
c002356e:	e9 af 00 00 00       	jmp    c0023622 <malloc+0x1c7>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c0023573:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023576:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c002357c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002357f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023582:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0023585:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023588:	8b 50 04             	mov    0x4(%eax),%edx
c002358b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002358e:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023591:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0023598:	eb 2d                	jmp    c00235c7 <malloc+0x16c>
        {
          struct block *b = arena_to_block (a, i);
c002359a:	83 ec 08             	sub    $0x8,%esp
c002359d:	ff 75 f0             	pushl  -0x10(%ebp)
c00235a0:	ff 75 e8             	pushl  -0x18(%ebp)
c00235a3:	e8 ea 03 00 00       	call   c0023992 <arena_to_block>
c00235a8:	83 c4 10             	add    $0x10,%esp
c00235ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c00235ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00235b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00235b4:	83 c2 08             	add    $0x8,%edx
c00235b7:	83 ec 08             	sub    $0x8,%esp
c00235ba:	50                   	push   %eax
c00235bb:	52                   	push   %edx
c00235bc:	e8 b8 65 00 00       	call   c0029b79 <list_push_back>
c00235c1:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < d->blocks_per_arena; i++) 
c00235c4:	ff 45 f0             	incl   -0x10(%ebp)
c00235c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235ca:	8b 40 04             	mov    0x4(%eax),%eax
c00235cd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00235d0:	77 c8                	ja     c002359a <malloc+0x13f>
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c00235d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00235d5:	83 c0 08             	add    $0x8,%eax
c00235d8:	83 ec 0c             	sub    $0xc,%esp
c00235db:	50                   	push   %eax
c00235dc:	e8 17 66 00 00       	call   c0029bf8 <list_pop_front>
c00235e1:	83 c4 10             	add    $0x10,%esp
c00235e4:	83 c0 04             	add    $0x4,%eax
c00235e7:	83 e8 04             	sub    $0x4,%eax
c00235ea:	89 45 e0             	mov    %eax,-0x20(%ebp)
  a = block_to_arena (b);
c00235ed:	83 ec 0c             	sub    $0xc,%esp
c00235f0:	ff 75 e0             	pushl  -0x20(%ebp)
c00235f3:	e8 9c 02 00 00       	call   c0023894 <block_to_arena>
c00235f8:	83 c4 10             	add    $0x10,%esp
c00235fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  a->free_cnt--;
c00235fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023601:	8b 40 08             	mov    0x8(%eax),%eax
c0023604:	8d 50 ff             	lea    -0x1(%eax),%edx
c0023607:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002360a:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c002360d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023610:	83 c0 18             	add    $0x18,%eax
c0023613:	83 ec 0c             	sub    $0xc,%esp
c0023616:	50                   	push   %eax
c0023617:	e8 b4 f5 ff ff       	call   c0022bd0 <lock_release>
c002361c:	83 c4 10             	add    $0x10,%esp
  return b;
c002361f:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
c0023622:	c9                   	leave  
c0023623:	c3                   	ret    

c0023624 <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c0023624:	55                   	push   %ebp
c0023625:	89 e5                	mov    %esp,%ebp
c0023627:	83 ec 18             	sub    $0x18,%esp
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c002362a:	8b 45 08             	mov    0x8(%ebp),%eax
c002362d:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023631:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c0023634:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023637:	3b 45 08             	cmp    0x8(%ebp),%eax
c002363a:	72 08                	jb     c0023644 <calloc+0x20>
c002363c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002363f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023642:	73 07                	jae    c002364b <calloc+0x27>
    return NULL;
c0023644:	b8 00 00 00 00       	mov    $0x0,%eax
c0023649:	eb 2d                	jmp    c0023678 <calloc+0x54>

  /* Allocate and zero memory. */
  p = malloc (size);
c002364b:	83 ec 0c             	sub    $0xc,%esp
c002364e:	ff 75 f4             	pushl  -0xc(%ebp)
c0023651:	e8 05 fe ff ff       	call   c002345b <malloc>
c0023656:	83 c4 10             	add    $0x10,%esp
c0023659:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c002365c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0023660:	74 13                	je     c0023675 <calloc+0x51>
    memset (p, 0, size);
c0023662:	83 ec 04             	sub    $0x4,%esp
c0023665:	ff 75 f4             	pushl  -0xc(%ebp)
c0023668:	6a 00                	push   $0x0
c002366a:	ff 75 f0             	pushl  -0x10(%ebp)
c002366d:	e8 d0 52 00 00       	call   c0028942 <memset>
c0023672:	83 c4 10             	add    $0x10,%esp

  return p;
c0023675:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0023678:	c9                   	leave  
c0023679:	c3                   	ret    

c002367a <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c002367a:	55                   	push   %ebp
c002367b:	89 e5                	mov    %esp,%ebp
c002367d:	53                   	push   %ebx
c002367e:	83 ec 14             	sub    $0x14,%esp
  struct block *b = block;
c0023681:	8b 45 08             	mov    0x8(%ebp),%eax
c0023684:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c0023687:	83 ec 0c             	sub    $0xc,%esp
c002368a:	ff 75 f4             	pushl  -0xc(%ebp)
c002368d:	e8 02 02 00 00       	call   c0023894 <block_to_arena>
c0023692:	83 c4 10             	add    $0x10,%esp
c0023695:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c0023698:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002369b:	8b 40 04             	mov    0x4(%eax),%eax
c002369e:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c00236a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00236a5:	74 07                	je     c00236ae <block_size+0x34>
c00236a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00236aa:	8b 00                	mov    (%eax),%eax
c00236ac:	eb 1d                	jmp    c00236cb <block_size+0x51>
c00236ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00236b1:	8b 40 08             	mov    0x8(%eax),%eax
c00236b4:	c1 e0 0c             	shl    $0xc,%eax
c00236b7:	89 c3                	mov    %eax,%ebx
c00236b9:	83 ec 0c             	sub    $0xc,%esp
c00236bc:	ff 75 08             	pushl  0x8(%ebp)
c00236bf:	e8 cb fc ff ff       	call   c002338f <pg_ofs>
c00236c4:	83 c4 10             	add    $0x10,%esp
c00236c7:	29 c3                	sub    %eax,%ebx
c00236c9:	89 d8                	mov    %ebx,%eax
}
c00236cb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00236ce:	c9                   	leave  
c00236cf:	c3                   	ret    

c00236d0 <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c00236d0:	55                   	push   %ebp
c00236d1:	89 e5                	mov    %esp,%ebp
c00236d3:	83 ec 18             	sub    $0x18,%esp
  if (new_size == 0) 
c00236d6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00236da:	75 15                	jne    c00236f1 <realloc+0x21>
    {
      free (old_block);
c00236dc:	83 ec 0c             	sub    $0xc,%esp
c00236df:	ff 75 08             	pushl  0x8(%ebp)
c00236e2:	e8 6e 00 00 00       	call   c0023755 <free>
c00236e7:	83 c4 10             	add    $0x10,%esp
      return NULL;
c00236ea:	b8 00 00 00 00       	mov    $0x0,%eax
c00236ef:	eb 62                	jmp    c0023753 <realloc+0x83>
    }
  else 
    {
      void *new_block = malloc (new_size);
c00236f1:	83 ec 0c             	sub    $0xc,%esp
c00236f4:	ff 75 0c             	pushl  0xc(%ebp)
c00236f7:	e8 5f fd ff ff       	call   c002345b <malloc>
c00236fc:	83 c4 10             	add    $0x10,%esp
c00236ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c0023702:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023706:	74 48                	je     c0023750 <realloc+0x80>
c0023708:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002370c:	74 42                	je     c0023750 <realloc+0x80>
        {
          size_t old_size = block_size (old_block);
c002370e:	83 ec 0c             	sub    $0xc,%esp
c0023711:	ff 75 08             	pushl  0x8(%ebp)
c0023714:	e8 61 ff ff ff       	call   c002367a <block_size>
c0023719:	83 c4 10             	add    $0x10,%esp
c002371c:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c002371f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0023722:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023725:	39 d0                	cmp    %edx,%eax
c0023727:	76 02                	jbe    c002372b <realloc+0x5b>
c0023729:	89 d0                	mov    %edx,%eax
c002372b:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c002372e:	83 ec 04             	sub    $0x4,%esp
c0023731:	ff 75 ec             	pushl  -0x14(%ebp)
c0023734:	ff 75 08             	pushl  0x8(%ebp)
c0023737:	ff 75 f4             	pushl  -0xc(%ebp)
c002373a:	e8 29 4c 00 00       	call   c0028368 <memcpy>
c002373f:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c0023742:	83 ec 0c             	sub    $0xc,%esp
c0023745:	ff 75 08             	pushl  0x8(%ebp)
c0023748:	e8 08 00 00 00       	call   c0023755 <free>
c002374d:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c0023750:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0023753:	c9                   	leave  
c0023754:	c3                   	ret    

c0023755 <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c0023755:	55                   	push   %ebp
c0023756:	89 e5                	mov    %esp,%ebp
c0023758:	83 ec 28             	sub    $0x28,%esp
  if (p != NULL)
c002375b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002375f:	0f 84 2d 01 00 00    	je     c0023892 <free+0x13d>
    {
      struct block *b = p;
c0023765:	8b 45 08             	mov    0x8(%ebp),%eax
c0023768:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c002376b:	83 ec 0c             	sub    $0xc,%esp
c002376e:	ff 75 f0             	pushl  -0x10(%ebp)
c0023771:	e8 1e 01 00 00       	call   c0023894 <block_to_arena>
c0023776:	83 c4 10             	add    $0x10,%esp
c0023779:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c002377c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002377f:	8b 40 04             	mov    0x4(%eax),%eax
c0023782:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c0023785:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023789:	0f 84 ed 00 00 00    	je     c002387c <free+0x127>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c002378f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023792:	8b 00                	mov    (%eax),%eax
c0023794:	83 ec 04             	sub    $0x4,%esp
c0023797:	50                   	push   %eax
c0023798:	68 cc 00 00 00       	push   $0xcc
c002379d:	ff 75 f0             	pushl  -0x10(%ebp)
c00237a0:	e8 9d 51 00 00       	call   c0028942 <memset>
c00237a5:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c00237a8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237ab:	83 c0 18             	add    $0x18,%eax
c00237ae:	83 ec 0c             	sub    $0xc,%esp
c00237b1:	50                   	push   %eax
c00237b2:	e8 d9 f2 ff ff       	call   c0022a90 <lock_acquire>
c00237b7:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c00237ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00237bd:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00237c0:	83 c2 08             	add    $0x8,%edx
c00237c3:	83 ec 08             	sub    $0x8,%esp
c00237c6:	50                   	push   %eax
c00237c7:	52                   	push   %edx
c00237c8:	e8 86 63 00 00       	call   c0029b53 <list_push_front>
c00237cd:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c00237d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237d3:	8b 40 08             	mov    0x8(%eax),%eax
c00237d6:	8d 50 01             	lea    0x1(%eax),%edx
c00237d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237dc:	89 50 08             	mov    %edx,0x8(%eax)
c00237df:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237e2:	8b 50 08             	mov    0x8(%eax),%edx
c00237e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237e8:	8b 40 04             	mov    0x4(%eax),%eax
c00237eb:	39 c2                	cmp    %eax,%edx
c00237ed:	72 79                	jb     c0023868 <free+0x113>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c00237ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00237f2:	8b 50 08             	mov    0x8(%eax),%edx
c00237f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00237f8:	8b 40 04             	mov    0x4(%eax),%eax
c00237fb:	39 c2                	cmp    %eax,%edx
c00237fd:	74 21                	je     c0023820 <free+0xcb>
c00237ff:	83 ec 0c             	sub    $0xc,%esp
c0023802:	68 d0 f2 02 c0       	push   $0xc002f2d0
c0023807:	68 a1 f2 02 c0       	push   $0xc002f2a1
c002380c:	68 b8 f3 02 c0       	push   $0xc002f3b8
c0023811:	68 f6 00 00 00       	push   $0xf6
c0023816:	68 b8 f2 02 c0       	push   $0xc002f2b8
c002381b:	e8 08 5d 00 00       	call   c0029528 <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023820:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023827:	eb 26                	jmp    c002384f <free+0xfa>
                {
                  struct block *b = arena_to_block (a, i);
c0023829:	83 ec 08             	sub    $0x8,%esp
c002382c:	ff 75 f4             	pushl  -0xc(%ebp)
c002382f:	ff 75 ec             	pushl  -0x14(%ebp)
c0023832:	e8 5b 01 00 00       	call   c0023992 <arena_to_block>
c0023837:	83 c4 10             	add    $0x10,%esp
c002383a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c002383d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023840:	83 ec 0c             	sub    $0xc,%esp
c0023843:	50                   	push   %eax
c0023844:	e8 56 63 00 00       	call   c0029b9f <list_remove>
c0023849:	83 c4 10             	add    $0x10,%esp
              for (i = 0; i < d->blocks_per_arena; i++) 
c002384c:	ff 45 f4             	incl   -0xc(%ebp)
c002384f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023852:	8b 40 04             	mov    0x4(%eax),%eax
c0023855:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023858:	77 cf                	ja     c0023829 <free+0xd4>
                }
              palloc_free_page (a);
c002385a:	83 ec 0c             	sub    $0xc,%esp
c002385d:	ff 75 ec             	pushl  -0x14(%ebp)
c0023860:	e8 07 fa ff ff       	call   c002326c <palloc_free_page>
c0023865:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c0023868:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002386b:	83 c0 18             	add    $0x18,%eax
c002386e:	83 ec 0c             	sub    $0xc,%esp
c0023871:	50                   	push   %eax
c0023872:	e8 59 f3 ff ff       	call   c0022bd0 <lock_release>
c0023877:	83 c4 10             	add    $0x10,%esp
c002387a:	eb 16                	jmp    c0023892 <free+0x13d>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c002387c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002387f:	8b 40 08             	mov    0x8(%eax),%eax
c0023882:	83 ec 08             	sub    $0x8,%esp
c0023885:	50                   	push   %eax
c0023886:	ff 75 ec             	pushl  -0x14(%ebp)
c0023889:	e8 9e f8 ff ff       	call   c002312c <palloc_free_multiple>
c002388e:	83 c4 10             	add    $0x10,%esp
          return;
c0023891:	90                   	nop
        }
    }
}
c0023892:	c9                   	leave  
c0023893:	c3                   	ret    

c0023894 <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c0023894:	55                   	push   %ebp
c0023895:	89 e5                	mov    %esp,%ebp
c0023897:	83 ec 18             	sub    $0x18,%esp
  struct arena *a = pg_round_down (b);
c002389a:	ff 75 08             	pushl  0x8(%ebp)
c002389d:	e8 fa fa ff ff       	call   c002339c <pg_round_down>
c00238a2:	83 c4 04             	add    $0x4,%esp
c00238a5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c00238a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00238ac:	75 21                	jne    c00238cf <block_to_arena+0x3b>
c00238ae:	83 ec 0c             	sub    $0xc,%esp
c00238b1:	68 f3 f2 02 c0       	push   $0xc002f2f3
c00238b6:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00238bb:	68 c0 f3 02 c0       	push   $0xc002f3c0
c00238c0:	68 11 01 00 00       	push   $0x111
c00238c5:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00238ca:	e8 59 5c 00 00       	call   c0029528 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00238cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00238d2:	8b 00                	mov    (%eax),%eax
c00238d4:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c00238d9:	74 21                	je     c00238fc <block_to_arena+0x68>
c00238db:	83 ec 0c             	sub    $0xc,%esp
c00238de:	68 fd f2 02 c0       	push   $0xc002f2fd
c00238e3:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00238e8:	68 c0 f3 02 c0       	push   $0xc002f3c0
c00238ed:	68 12 01 00 00       	push   $0x112
c00238f2:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00238f7:	e8 2c 5c 00 00       	call   c0029528 <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c00238fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00238ff:	8b 40 04             	mov    0x4(%eax),%eax
c0023902:	85 c0                	test   %eax,%eax
c0023904:	74 49                	je     c002394f <block_to_arena+0xbb>
c0023906:	83 ec 0c             	sub    $0xc,%esp
c0023909:	ff 75 08             	pushl  0x8(%ebp)
c002390c:	e8 7e fa ff ff       	call   c002338f <pg_ofs>
c0023911:	83 c4 10             	add    $0x10,%esp
c0023914:	8d 50 f4             	lea    -0xc(%eax),%edx
c0023917:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002391a:	8b 40 04             	mov    0x4(%eax),%eax
c002391d:	8b 08                	mov    (%eax),%ecx
c002391f:	89 d0                	mov    %edx,%eax
c0023921:	ba 00 00 00 00       	mov    $0x0,%edx
c0023926:	f7 f1                	div    %ecx
c0023928:	89 d0                	mov    %edx,%eax
c002392a:	85 c0                	test   %eax,%eax
c002392c:	74 21                	je     c002394f <block_to_arena+0xbb>
c002392e:	83 ec 0c             	sub    $0xc,%esp
c0023931:	68 18 f3 02 c0       	push   $0xc002f318
c0023936:	68 a1 f2 02 c0       	push   $0xc002f2a1
c002393b:	68 c0 f3 02 c0       	push   $0xc002f3c0
c0023940:	68 16 01 00 00       	push   $0x116
c0023945:	68 b8 f2 02 c0       	push   $0xc002f2b8
c002394a:	e8 d9 5b 00 00       	call   c0029528 <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c002394f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023952:	8b 40 04             	mov    0x4(%eax),%eax
c0023955:	85 c0                	test   %eax,%eax
c0023957:	75 34                	jne    c002398d <block_to_arena+0xf9>
c0023959:	83 ec 0c             	sub    $0xc,%esp
c002395c:	ff 75 08             	pushl  0x8(%ebp)
c002395f:	e8 2b fa ff ff       	call   c002338f <pg_ofs>
c0023964:	83 c4 10             	add    $0x10,%esp
c0023967:	83 f8 0c             	cmp    $0xc,%eax
c002396a:	74 21                	je     c002398d <block_to_arena+0xf9>
c002396c:	83 ec 0c             	sub    $0xc,%esp
c002396f:	68 60 f3 02 c0       	push   $0xc002f360
c0023974:	68 a1 f2 02 c0       	push   $0xc002f2a1
c0023979:	68 c0 f3 02 c0       	push   $0xc002f3c0
c002397e:	68 17 01 00 00       	push   $0x117
c0023983:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023988:	e8 9b 5b 00 00       	call   c0029528 <debug_panic>

  return a;
c002398d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023990:	c9                   	leave  
c0023991:	c3                   	ret    

c0023992 <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0023992:	55                   	push   %ebp
c0023993:	89 e5                	mov    %esp,%ebp
c0023995:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0023998:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002399c:	75 21                	jne    c00239bf <arena_to_block+0x2d>
c002399e:	83 ec 0c             	sub    $0xc,%esp
c00239a1:	68 f3 f2 02 c0       	push   $0xc002f2f3
c00239a6:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00239ab:	68 d0 f3 02 c0       	push   $0xc002f3d0
c00239b0:	68 20 01 00 00       	push   $0x120
c00239b5:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00239ba:	e8 69 5b 00 00       	call   c0029528 <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c00239bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00239c2:	8b 00                	mov    (%eax),%eax
c00239c4:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c00239c9:	74 21                	je     c00239ec <arena_to_block+0x5a>
c00239cb:	83 ec 0c             	sub    $0xc,%esp
c00239ce:	68 fd f2 02 c0       	push   $0xc002f2fd
c00239d3:	68 a1 f2 02 c0       	push   $0xc002f2a1
c00239d8:	68 d0 f3 02 c0       	push   $0xc002f3d0
c00239dd:	68 21 01 00 00       	push   $0x121
c00239e2:	68 b8 f2 02 c0       	push   $0xc002f2b8
c00239e7:	e8 3c 5b 00 00       	call   c0029528 <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c00239ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00239ef:	8b 40 04             	mov    0x4(%eax),%eax
c00239f2:	8b 40 04             	mov    0x4(%eax),%eax
c00239f5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00239f8:	77 21                	ja     c0023a1b <arena_to_block+0x89>
c00239fa:	83 ec 0c             	sub    $0xc,%esp
c00239fd:	68 8c f3 02 c0       	push   $0xc002f38c
c0023a02:	68 a1 f2 02 c0       	push   $0xc002f2a1
c0023a07:	68 d0 f3 02 c0       	push   $0xc002f3d0
c0023a0c:	68 22 01 00 00       	push   $0x122
c0023a11:	68 b8 f2 02 c0       	push   $0xc002f2b8
c0023a16:	e8 0d 5b 00 00       	call   c0029528 <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0023a1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a1e:	8b 40 04             	mov    0x4(%eax),%eax
c0023a21:	8b 00                	mov    (%eax),%eax
c0023a23:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023a27:	8d 50 0c             	lea    0xc(%eax),%edx
  return (struct block *) ((uint8_t *) a
c0023a2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a2d:	01 d0                	add    %edx,%eax
}
c0023a2f:	c9                   	leave  
c0023a30:	c3                   	ret    

c0023a31 <outb>:
{
c0023a31:	55                   	push   %ebp
c0023a32:	89 e5                	mov    %esp,%ebp
c0023a34:	83 ec 08             	sub    $0x8,%esp
c0023a37:	8b 45 08             	mov    0x8(%ebp),%eax
c0023a3a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0023a3d:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0023a41:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023a44:	8a 45 f8             	mov    -0x8(%ebp),%al
c0023a47:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0023a4a:	ee                   	out    %al,(%dx)
}
c0023a4b:	90                   	nop
c0023a4c:	c9                   	leave  
c0023a4d:	c3                   	ret    

c0023a4e <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023a4e:	55                   	push   %ebp
c0023a4f:	89 e5                	mov    %esp,%ebp
c0023a51:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023a54:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023a58:	74 24                	je     c0023a7e <pit_configure_channel+0x30>
c0023a5a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0023a5e:	74 1e                	je     c0023a7e <pit_configure_channel+0x30>
c0023a60:	83 ec 0c             	sub    $0xc,%esp
c0023a63:	68 e0 f3 02 c0       	push   $0xc002f3e0
c0023a68:	68 fd f3 02 c0       	push   $0xc002f3fd
c0023a6d:	68 40 f4 02 c0       	push   $0xc002f440
c0023a72:	6a 33                	push   $0x33
c0023a74:	68 14 f4 02 c0       	push   $0xc002f414
c0023a79:	e8 aa 5a 00 00       	call   c0029528 <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023a7e:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c0023a82:	74 24                	je     c0023aa8 <pit_configure_channel+0x5a>
c0023a84:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0023a88:	74 1e                	je     c0023aa8 <pit_configure_channel+0x5a>
c0023a8a:	83 ec 0c             	sub    $0xc,%esp
c0023a8d:	68 28 f4 02 c0       	push   $0xc002f428
c0023a92:	68 fd f3 02 c0       	push   $0xc002f3fd
c0023a97:	68 40 f4 02 c0       	push   $0xc002f440
c0023a9c:	6a 34                	push   $0x34
c0023a9e:	68 14 f4 02 c0       	push   $0xc002f414
c0023aa3:	e8 80 5a 00 00       	call   c0029528 <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023aa8:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0023aac:	7f 08                	jg     c0023ab6 <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0023aae:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0023ab4:	eb 2a                	jmp    c0023ae0 <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c0023ab6:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0023abd:	7e 08                	jle    c0023ac7 <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0023abf:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0023ac5:	eb 19                	jmp    c0023ae0 <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023ac7:	8b 45 10             	mov    0x10(%ebp),%eax
c0023aca:	89 c2                	mov    %eax,%edx
c0023acc:	c1 ea 1f             	shr    $0x1f,%edx
c0023acf:	01 d0                	add    %edx,%eax
c0023ad1:	d1 f8                	sar    %eax
c0023ad3:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023ad8:	99                   	cltd   
c0023ad9:	f7 7d 10             	idivl  0x10(%ebp)
c0023adc:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023ae0:	e8 a7 d8 ff ff       	call   c002138c <intr_disable>
c0023ae5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023ae8:	8b 45 08             	mov    0x8(%ebp),%eax
c0023aeb:	c1 e0 06             	shl    $0x6,%eax
c0023aee:	83 c8 30             	or     $0x30,%eax
c0023af1:	88 c2                	mov    %al,%dl
c0023af3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023af6:	01 c0                	add    %eax,%eax
c0023af8:	09 d0                	or     %edx,%eax
c0023afa:	0f b6 c0             	movzbl %al,%eax
c0023afd:	83 ec 08             	sub    $0x8,%esp
c0023b00:	50                   	push   %eax
c0023b01:	6a 43                	push   $0x43
c0023b03:	e8 29 ff ff ff       	call   c0023a31 <outb>
c0023b08:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c0023b0b:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0023b0f:	0f b6 d0             	movzbl %al,%edx
c0023b12:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b15:	83 c0 40             	add    $0x40,%eax
c0023b18:	0f b7 c0             	movzwl %ax,%eax
c0023b1b:	83 ec 08             	sub    $0x8,%esp
c0023b1e:	52                   	push   %edx
c0023b1f:	50                   	push   %eax
c0023b20:	e8 0c ff ff ff       	call   c0023a31 <outb>
c0023b25:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0023b28:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
c0023b2c:	66 c1 e8 08          	shr    $0x8,%ax
c0023b30:	0f b6 d0             	movzbl %al,%edx
c0023b33:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b36:	83 c0 40             	add    $0x40,%eax
c0023b39:	0f b7 c0             	movzwl %ax,%eax
c0023b3c:	83 ec 08             	sub    $0x8,%esp
c0023b3f:	52                   	push   %edx
c0023b40:	50                   	push   %eax
c0023b41:	e8 eb fe ff ff       	call   c0023a31 <outb>
c0023b46:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0023b49:	83 ec 0c             	sub    $0xc,%esp
c0023b4c:	ff 75 f0             	pushl  -0x10(%ebp)
c0023b4f:	e8 e0 d7 ff ff       	call   c0021334 <intr_set_level>
c0023b54:	83 c4 10             	add    $0x10,%esp
}
c0023b57:	90                   	nop
c0023b58:	c9                   	leave  
c0023b59:	c3                   	ret    

c0023b5a <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c0023b5a:	55                   	push   %ebp
c0023b5b:	89 e5                	mov    %esp,%ebp
c0023b5d:	83 ec 08             	sub    $0x8,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c0023b60:	83 ec 04             	sub    $0x4,%esp
c0023b63:	6a 64                	push   $0x64
c0023b65:	6a 02                	push   $0x2
c0023b67:	6a 00                	push   $0x0
c0023b69:	e8 e0 fe ff ff       	call   c0023a4e <pit_configure_channel>
c0023b6e:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c0023b71:	83 ec 04             	sub    $0x4,%esp
c0023b74:	68 58 f4 02 c0       	push   $0xc002f458
c0023b79:	68 81 3e 02 c0       	push   $0xc0023e81
c0023b7e:	6a 20                	push   $0x20
c0023b80:	e8 26 da ff ff       	call   c00215ab <intr_register_ext>
c0023b85:	83 c4 10             	add    $0x10,%esp
}
c0023b88:	90                   	nop
c0023b89:	c9                   	leave  
c0023b8a:	c3                   	ret    

c0023b8b <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c0023b8b:	55                   	push   %ebp
c0023b8c:	89 e5                	mov    %esp,%ebp
c0023b8e:	53                   	push   %ebx
c0023b8f:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c0023b92:	e8 80 d7 ff ff       	call   c0021317 <intr_get_level>
c0023b97:	83 f8 01             	cmp    $0x1,%eax
c0023b9a:	74 1e                	je     c0023bba <timer_calibrate+0x2f>
c0023b9c:	83 ec 0c             	sub    $0xc,%esp
c0023b9f:	68 63 f4 02 c0       	push   $0xc002f463
c0023ba4:	68 80 f4 02 c0       	push   $0xc002f480
c0023ba9:	68 10 f5 02 c0       	push   $0xc002f510
c0023bae:	6a 30                	push   $0x30
c0023bb0:	68 97 f4 02 c0       	push   $0xc002f497
c0023bb5:	e8 6e 59 00 00       	call   c0029528 <debug_panic>
  printf ("Calibrating timer...  ");
c0023bba:	83 ec 0c             	sub    $0xc,%esp
c0023bbd:	68 ad f4 02 c0       	push   $0xc002f4ad
c0023bc2:	e8 a2 35 00 00       	call   c0027169 <printf>
c0023bc7:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0023bca:	c7 05 b0 88 03 c0 00 	movl   $0x400,0xc00388b0
c0023bd1:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0023bd4:	eb 33                	jmp    c0023c09 <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c0023bd6:	a1 b0 88 03 c0       	mov    0xc00388b0,%eax
c0023bdb:	01 c0                	add    %eax,%eax
c0023bdd:	a3 b0 88 03 c0       	mov    %eax,0xc00388b0
      ASSERT (loops_per_tick != 0);
c0023be2:	a1 b0 88 03 c0       	mov    0xc00388b0,%eax
c0023be7:	85 c0                	test   %eax,%eax
c0023be9:	75 1e                	jne    c0023c09 <timer_calibrate+0x7e>
c0023beb:	83 ec 0c             	sub    $0xc,%esp
c0023bee:	68 c4 f4 02 c0       	push   $0xc002f4c4
c0023bf3:	68 80 f4 02 c0       	push   $0xc002f480
c0023bf8:	68 10 f5 02 c0       	push   $0xc002f510
c0023bfd:	6a 39                	push   $0x39
c0023bff:	68 97 f4 02 c0       	push   $0xc002f497
c0023c04:	e8 1f 59 00 00       	call   c0029528 <debug_panic>
  while (!too_many_loops (loops_per_tick << 1)) 
c0023c09:	a1 b0 88 03 c0       	mov    0xc00388b0,%eax
c0023c0e:	01 c0                	add    %eax,%eax
c0023c10:	83 ec 0c             	sub    $0xc,%esp
c0023c13:	50                   	push   %eax
c0023c14:	e8 92 02 00 00       	call   c0023eab <too_many_loops>
c0023c19:	83 c4 10             	add    $0x10,%esp
c0023c1c:	83 f0 01             	xor    $0x1,%eax
c0023c1f:	84 c0                	test   %al,%al
c0023c21:	75 b3                	jne    c0023bd6 <timer_calibrate+0x4b>
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c0023c23:	a1 b0 88 03 c0       	mov    0xc00388b0,%eax
c0023c28:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c2e:	d1 e8                	shr    %eax
c0023c30:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0023c33:	eb 29                	jmp    c0023c5e <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c0023c35:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c38:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023c3b:	83 ec 0c             	sub    $0xc,%esp
c0023c3e:	50                   	push   %eax
c0023c3f:	e8 67 02 00 00       	call   c0023eab <too_many_loops>
c0023c44:	83 c4 10             	add    $0x10,%esp
c0023c47:	83 f0 01             	xor    $0x1,%eax
c0023c4a:	84 c0                	test   %al,%al
c0023c4c:	74 0d                	je     c0023c5b <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c0023c4e:	a1 b0 88 03 c0       	mov    0xc00388b0,%eax
c0023c53:	0b 45 f4             	or     -0xc(%ebp),%eax
c0023c56:	a3 b0 88 03 c0       	mov    %eax,0xc00388b0
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0023c5b:	d1 6d f4             	shrl   -0xc(%ebp)
c0023c5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023c61:	c1 e8 0a             	shr    $0xa,%eax
c0023c64:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023c67:	75 cc                	jne    c0023c35 <timer_calibrate+0xaa>

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c0023c69:	a1 b0 88 03 c0       	mov    0xc00388b0,%eax
c0023c6e:	ba 00 00 00 00       	mov    $0x0,%edx
c0023c73:	6b da 64             	imul   $0x64,%edx,%ebx
c0023c76:	6b c8 00             	imul   $0x0,%eax,%ecx
c0023c79:	01 d9                	add    %ebx,%ecx
c0023c7b:	bb 64 00 00 00       	mov    $0x64,%ebx
c0023c80:	f7 e3                	mul    %ebx
c0023c82:	01 d1                	add    %edx,%ecx
c0023c84:	89 ca                	mov    %ecx,%edx
c0023c86:	83 ec 04             	sub    $0x4,%esp
c0023c89:	52                   	push   %edx
c0023c8a:	50                   	push   %eax
c0023c8b:	68 d8 f4 02 c0       	push   $0xc002f4d8
c0023c90:	e8 d4 34 00 00       	call   c0027169 <printf>
c0023c95:	83 c4 10             	add    $0x10,%esp
}
c0023c98:	90                   	nop
c0023c99:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023c9c:	c9                   	leave  
c0023c9d:	c3                   	ret    

c0023c9e <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c0023c9e:	55                   	push   %ebp
c0023c9f:	89 e5                	mov    %esp,%ebp
c0023ca1:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0023ca4:	e8 e3 d6 ff ff       	call   c002138c <intr_disable>
c0023ca9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c0023cac:	a1 a8 88 03 c0       	mov    0xc00388a8,%eax
c0023cb1:	8b 15 ac 88 03 c0    	mov    0xc00388ac,%edx
c0023cb7:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0023cba:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c0023cbd:	83 ec 0c             	sub    $0xc,%esp
c0023cc0:	ff 75 f4             	pushl  -0xc(%ebp)
c0023cc3:	e8 6c d6 ff ff       	call   c0021334 <intr_set_level>
c0023cc8:	83 c4 10             	add    $0x10,%esp
  return t;
c0023ccb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023cce:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c0023cd1:	c9                   	leave  
c0023cd2:	c3                   	ret    

c0023cd3 <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c0023cd3:	55                   	push   %ebp
c0023cd4:	89 e5                	mov    %esp,%ebp
c0023cd6:	83 ec 18             	sub    $0x18,%esp
c0023cd9:	8b 45 08             	mov    0x8(%ebp),%eax
c0023cdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023cdf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023ce2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c0023ce5:	e8 b4 ff ff ff       	call   c0023c9e <timer_ticks>
c0023cea:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0023ced:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c0023cf0:	c9                   	leave  
c0023cf1:	c3                   	ret    

c0023cf2 <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c0023cf2:	55                   	push   %ebp
c0023cf3:	89 e5                	mov    %esp,%ebp
c0023cf5:	83 ec 28             	sub    $0x28,%esp
c0023cf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0023cfb:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023cfe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  int64_t start = timer_ticks ();
c0023d04:	e8 95 ff ff ff       	call   c0023c9e <timer_ticks>
c0023d09:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d0c:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023d0f:	e8 03 d6 ff ff       	call   c0021317 <intr_get_level>
c0023d14:	83 f8 01             	cmp    $0x1,%eax
c0023d17:	74 23                	je     c0023d3c <timer_sleep+0x4a>
c0023d19:	83 ec 0c             	sub    $0xc,%esp
c0023d1c:	68 63 f4 02 c0       	push   $0xc002f463
c0023d21:	68 80 f4 02 c0       	push   $0xc002f480
c0023d26:	68 20 f5 02 c0       	push   $0xc002f520
c0023d2b:	6a 5e                	push   $0x5e
c0023d2d:	68 97 f4 02 c0       	push   $0xc002f497
c0023d32:	e8 f1 57 00 00       	call   c0029528 <debug_panic>
  while (timer_elapsed (start) < ticks) 
    thread_yield ();
c0023d37:	e8 1d d0 ff ff       	call   c0020d59 <thread_yield>
  while (timer_elapsed (start) < ticks) 
c0023d3c:	83 ec 08             	sub    $0x8,%esp
c0023d3f:	ff 75 f4             	pushl  -0xc(%ebp)
c0023d42:	ff 75 f0             	pushl  -0x10(%ebp)
c0023d45:	e8 89 ff ff ff       	call   c0023cd3 <timer_elapsed>
c0023d4a:	83 c4 10             	add    $0x10,%esp
c0023d4d:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023d50:	7c e5                	jl     c0023d37 <timer_sleep+0x45>
c0023d52:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
c0023d55:	7f 05                	jg     c0023d5c <timer_sleep+0x6a>
c0023d57:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0023d5a:	72 db                	jb     c0023d37 <timer_sleep+0x45>
}
c0023d5c:	90                   	nop
c0023d5d:	c9                   	leave  
c0023d5e:	c3                   	ret    

c0023d5f <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c0023d5f:	55                   	push   %ebp
c0023d60:	89 e5                	mov    %esp,%ebp
c0023d62:	83 ec 18             	sub    $0x18,%esp
c0023d65:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d68:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d6b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c0023d71:	83 ec 04             	sub    $0x4,%esp
c0023d74:	68 e8 03 00 00       	push   $0x3e8
c0023d79:	ff 75 f4             	pushl  -0xc(%ebp)
c0023d7c:	ff 75 f0             	pushl  -0x10(%ebp)
c0023d7f:	e8 f9 01 00 00       	call   c0023f7d <real_time_sleep>
c0023d84:	83 c4 10             	add    $0x10,%esp
}
c0023d87:	90                   	nop
c0023d88:	c9                   	leave  
c0023d89:	c3                   	ret    

c0023d8a <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c0023d8a:	55                   	push   %ebp
c0023d8b:	89 e5                	mov    %esp,%ebp
c0023d8d:	83 ec 18             	sub    $0x18,%esp
c0023d90:	8b 45 08             	mov    0x8(%ebp),%eax
c0023d93:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023d96:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023d99:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c0023d9c:	83 ec 04             	sub    $0x4,%esp
c0023d9f:	68 40 42 0f 00       	push   $0xf4240
c0023da4:	ff 75 f4             	pushl  -0xc(%ebp)
c0023da7:	ff 75 f0             	pushl  -0x10(%ebp)
c0023daa:	e8 ce 01 00 00       	call   c0023f7d <real_time_sleep>
c0023daf:	83 c4 10             	add    $0x10,%esp
}
c0023db2:	90                   	nop
c0023db3:	c9                   	leave  
c0023db4:	c3                   	ret    

c0023db5 <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0023db5:	55                   	push   %ebp
c0023db6:	89 e5                	mov    %esp,%ebp
c0023db8:	83 ec 18             	sub    $0x18,%esp
c0023dbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0023dbe:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023dc1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023dc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0023dc7:	83 ec 04             	sub    $0x4,%esp
c0023dca:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023dcf:	ff 75 f4             	pushl  -0xc(%ebp)
c0023dd2:	ff 75 f0             	pushl  -0x10(%ebp)
c0023dd5:	e8 a3 01 00 00       	call   c0023f7d <real_time_sleep>
c0023dda:	83 c4 10             	add    $0x10,%esp
}
c0023ddd:	90                   	nop
c0023dde:	c9                   	leave  
c0023ddf:	c3                   	ret    

c0023de0 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0023de0:	55                   	push   %ebp
c0023de1:	89 e5                	mov    %esp,%ebp
c0023de3:	83 ec 18             	sub    $0x18,%esp
c0023de6:	8b 45 08             	mov    0x8(%ebp),%eax
c0023de9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023dec:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023def:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c0023df2:	83 ec 04             	sub    $0x4,%esp
c0023df5:	68 e8 03 00 00       	push   $0x3e8
c0023dfa:	ff 75 f4             	pushl  -0xc(%ebp)
c0023dfd:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e00:	e8 2a 02 00 00       	call   c002402f <real_time_delay>
c0023e05:	83 c4 10             	add    $0x10,%esp
}
c0023e08:	90                   	nop
c0023e09:	c9                   	leave  
c0023e0a:	c3                   	ret    

c0023e0b <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c0023e0b:	55                   	push   %ebp
c0023e0c:	89 e5                	mov    %esp,%ebp
c0023e0e:	83 ec 18             	sub    $0x18,%esp
c0023e11:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e14:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e17:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c0023e1d:	83 ec 04             	sub    $0x4,%esp
c0023e20:	68 40 42 0f 00       	push   $0xf4240
c0023e25:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e28:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e2b:	e8 ff 01 00 00       	call   c002402f <real_time_delay>
c0023e30:	83 c4 10             	add    $0x10,%esp
}
c0023e33:	90                   	nop
c0023e34:	c9                   	leave  
c0023e35:	c3                   	ret    

c0023e36 <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c0023e36:	55                   	push   %ebp
c0023e37:	89 e5                	mov    %esp,%ebp
c0023e39:	83 ec 18             	sub    $0x18,%esp
c0023e3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0023e3f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023e42:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023e45:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c0023e48:	83 ec 04             	sub    $0x4,%esp
c0023e4b:	68 00 ca 9a 3b       	push   $0x3b9aca00
c0023e50:	ff 75 f4             	pushl  -0xc(%ebp)
c0023e53:	ff 75 f0             	pushl  -0x10(%ebp)
c0023e56:	e8 d4 01 00 00       	call   c002402f <real_time_delay>
c0023e5b:	83 c4 10             	add    $0x10,%esp
}
c0023e5e:	90                   	nop
c0023e5f:	c9                   	leave  
c0023e60:	c3                   	ret    

c0023e61 <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c0023e61:	55                   	push   %ebp
c0023e62:	89 e5                	mov    %esp,%ebp
c0023e64:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c0023e67:	e8 32 fe ff ff       	call   c0023c9e <timer_ticks>
c0023e6c:	83 ec 04             	sub    $0x4,%esp
c0023e6f:	52                   	push   %edx
c0023e70:	50                   	push   %eax
c0023e71:	68 e8 f4 02 c0       	push   $0xc002f4e8
c0023e76:	e8 ee 32 00 00       	call   c0027169 <printf>
c0023e7b:	83 c4 10             	add    $0x10,%esp
}
c0023e7e:	90                   	nop
c0023e7f:	c9                   	leave  
c0023e80:	c3                   	ret    

c0023e81 <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c0023e81:	55                   	push   %ebp
c0023e82:	89 e5                	mov    %esp,%ebp
c0023e84:	83 ec 08             	sub    $0x8,%esp
  ticks++;
c0023e87:	a1 a8 88 03 c0       	mov    0xc00388a8,%eax
c0023e8c:	8b 15 ac 88 03 c0    	mov    0xc00388ac,%edx
c0023e92:	83 c0 01             	add    $0x1,%eax
c0023e95:	83 d2 00             	adc    $0x0,%edx
c0023e98:	a3 a8 88 03 c0       	mov    %eax,0xc00388a8
c0023e9d:	89 15 ac 88 03 c0    	mov    %edx,0xc00388ac
  thread_tick ();
c0023ea3:	e8 e8 ca ff ff       	call   c0020990 <thread_tick>
}
c0023ea8:	90                   	nop
c0023ea9:	c9                   	leave  
c0023eaa:	c3                   	ret    

c0023eab <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c0023eab:	55                   	push   %ebp
c0023eac:	89 e5                	mov    %esp,%ebp
c0023eae:	56                   	push   %esi
c0023eaf:	53                   	push   %ebx
c0023eb0:	83 ec 20             	sub    $0x20,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c0023eb3:	a1 a8 88 03 c0       	mov    0xc00388a8,%eax
c0023eb8:	8b 15 ac 88 03 c0    	mov    0xc00388ac,%edx
c0023ebe:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023ec1:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (ticks == start)
c0023ec4:	eb 00                	jmp    c0023ec6 <too_many_loops+0x1b>
c0023ec6:	a1 a8 88 03 c0       	mov    0xc00388a8,%eax
c0023ecb:	8b 15 ac 88 03 c0    	mov    0xc00388ac,%edx
c0023ed1:	89 c1                	mov    %eax,%ecx
c0023ed3:	33 4d f0             	xor    -0x10(%ebp),%ecx
c0023ed6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0023ed9:	89 d0                	mov    %edx,%eax
c0023edb:	33 45 f4             	xor    -0xc(%ebp),%eax
c0023ede:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0023ee1:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0023ee4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0023ee7:	89 c8                	mov    %ecx,%eax
c0023ee9:	09 d0                	or     %edx,%eax
c0023eeb:	85 c0                	test   %eax,%eax
c0023eed:	74 d7                	je     c0023ec6 <too_many_loops+0x1b>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c0023eef:	a1 a8 88 03 c0       	mov    0xc00388a8,%eax
c0023ef4:	8b 15 ac 88 03 c0    	mov    0xc00388ac,%edx
c0023efa:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023efd:	89 55 f4             	mov    %edx,-0xc(%ebp)
  busy_wait (loops);
c0023f00:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f03:	ba 00 00 00 00       	mov    $0x0,%edx
c0023f08:	83 ec 08             	sub    $0x8,%esp
c0023f0b:	52                   	push   %edx
c0023f0c:	50                   	push   %eax
c0023f0d:	e8 2c 00 00 00       	call   c0023f3e <busy_wait>
c0023f12:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c0023f15:	a1 a8 88 03 c0       	mov    0xc00388a8,%eax
c0023f1a:	8b 15 ac 88 03 c0    	mov    0xc00388ac,%edx
c0023f20:	89 c1                	mov    %eax,%ecx
c0023f22:	33 4d f0             	xor    -0x10(%ebp),%ecx
c0023f25:	89 cb                	mov    %ecx,%ebx
c0023f27:	89 d0                	mov    %edx,%eax
c0023f29:	33 45 f4             	xor    -0xc(%ebp),%eax
c0023f2c:	89 c6                	mov    %eax,%esi
c0023f2e:	89 d8                	mov    %ebx,%eax
c0023f30:	09 f0                	or     %esi,%eax
c0023f32:	85 c0                	test   %eax,%eax
c0023f34:	0f 95 c0             	setne  %al
}
c0023f37:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0023f3a:	5b                   	pop    %ebx
c0023f3b:	5e                   	pop    %esi
c0023f3c:	5d                   	pop    %ebp
c0023f3d:	c3                   	ret    

c0023f3e <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c0023f3e:	55                   	push   %ebp
c0023f3f:	89 e5                	mov    %esp,%ebp
c0023f41:	53                   	push   %ebx
c0023f42:	83 ec 0c             	sub    $0xc,%esp
c0023f45:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f48:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023f4b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c0023f51:	eb 00                	jmp    c0023f53 <busy_wait+0x15>
c0023f53:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023f56:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023f59:	89 c1                	mov    %eax,%ecx
c0023f5b:	89 d3                	mov    %edx,%ebx
c0023f5d:	83 c1 ff             	add    $0xffffffff,%ecx
c0023f60:	83 d3 ff             	adc    $0xffffffff,%ebx
c0023f63:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0023f66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0023f69:	85 d2                	test   %edx,%edx
c0023f6b:	7f e6                	jg     c0023f53 <busy_wait+0x15>
c0023f6d:	85 d2                	test   %edx,%edx
c0023f6f:	78 05                	js     c0023f76 <busy_wait+0x38>
c0023f71:	83 f8 00             	cmp    $0x0,%eax
c0023f74:	77 dd                	ja     c0023f53 <busy_wait+0x15>
    barrier ();
}
c0023f76:	90                   	nop
c0023f77:	83 c4 0c             	add    $0xc,%esp
c0023f7a:	5b                   	pop    %ebx
c0023f7b:	5d                   	pop    %ebp
c0023f7c:	c3                   	ret    

c0023f7d <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c0023f7d:	55                   	push   %ebp
c0023f7e:	89 e5                	mov    %esp,%ebp
c0023f80:	53                   	push   %ebx
c0023f81:	83 ec 24             	sub    $0x24,%esp
c0023f84:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f87:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0023f8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c0023f90:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023f93:	6b d0 64             	imul   $0x64,%eax,%edx
c0023f96:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0023f99:	6b c0 00             	imul   $0x0,%eax,%eax
c0023f9c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0023f9f:	b8 64 00 00 00       	mov    $0x64,%eax
c0023fa4:	f7 65 e0             	mull   -0x20(%ebp)
c0023fa7:	01 d1                	add    %edx,%ecx
c0023fa9:	89 ca                	mov    %ecx,%edx
c0023fab:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0023fae:	89 cb                	mov    %ecx,%ebx
c0023fb0:	c1 fb 1f             	sar    $0x1f,%ebx
c0023fb3:	53                   	push   %ebx
c0023fb4:	51                   	push   %ecx
c0023fb5:	52                   	push   %edx
c0023fb6:	50                   	push   %eax
c0023fb7:	e8 72 4f 00 00       	call   c0028f2e <__divdi3>
c0023fbc:	83 c4 10             	add    $0x10,%esp
c0023fbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023fc2:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c0023fc5:	e8 4d d3 ff ff       	call   c0021317 <intr_get_level>
c0023fca:	83 f8 01             	cmp    $0x1,%eax
c0023fcd:	74 21                	je     c0023ff0 <real_time_sleep+0x73>
c0023fcf:	83 ec 0c             	sub    $0xc,%esp
c0023fd2:	68 63 f4 02 c0       	push   $0xc002f463
c0023fd7:	68 80 f4 02 c0       	push   $0xc002f480
c0023fdc:	68 2c f5 02 c0       	push   $0xc002f52c
c0023fe1:	68 de 00 00 00       	push   $0xde
c0023fe6:	68 97 f4 02 c0       	push   $0xc002f497
c0023feb:	e8 38 55 00 00       	call   c0029528 <debug_panic>
  if (ticks > 0)
c0023ff0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023ff4:	78 1f                	js     c0024015 <real_time_sleep+0x98>
c0023ff6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023ffa:	7f 06                	jg     c0024002 <real_time_sleep+0x85>
c0023ffc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024000:	76 13                	jbe    c0024015 <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c0024002:	83 ec 08             	sub    $0x8,%esp
c0024005:	ff 75 f4             	pushl  -0xc(%ebp)
c0024008:	ff 75 f0             	pushl  -0x10(%ebp)
c002400b:	e8 e2 fc ff ff       	call   c0023cf2 <timer_sleep>
c0024010:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c0024013:	eb 14                	jmp    c0024029 <real_time_sleep+0xac>
      real_time_delay (num, denom); 
c0024015:	83 ec 04             	sub    $0x4,%esp
c0024018:	ff 75 10             	pushl  0x10(%ebp)
c002401b:	ff 75 e4             	pushl  -0x1c(%ebp)
c002401e:	ff 75 e0             	pushl  -0x20(%ebp)
c0024021:	e8 09 00 00 00       	call   c002402f <real_time_delay>
c0024026:	83 c4 10             	add    $0x10,%esp
}
c0024029:	90                   	nop
c002402a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002402d:	c9                   	leave  
c002402e:	c3                   	ret    

c002402f <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c002402f:	55                   	push   %ebp
c0024030:	89 e5                	mov    %esp,%ebp
c0024032:	56                   	push   %esi
c0024033:	53                   	push   %ebx
c0024034:	83 ec 10             	sub    $0x10,%esp
c0024037:	8b 45 08             	mov    0x8(%ebp),%eax
c002403a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002403d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024040:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c0024043:	8b 45 10             	mov    0x10(%ebp),%eax
c0024046:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c002404b:	99                   	cltd   
c002404c:	f7 f9                	idiv   %ecx
c002404e:	89 d0                	mov    %edx,%eax
c0024050:	85 c0                	test   %eax,%eax
c0024052:	74 21                	je     c0024075 <real_time_delay+0x46>
c0024054:	83 ec 0c             	sub    $0xc,%esp
c0024057:	68 fb f4 02 c0       	push   $0xc002f4fb
c002405c:	68 80 f4 02 c0       	push   $0xc002f480
c0024061:	68 3c f5 02 c0       	push   $0xc002f53c
c0024066:	68 f4 00 00 00       	push   $0xf4
c002406b:	68 97 f4 02 c0       	push   $0xc002f497
c0024070:	e8 b3 54 00 00       	call   c0029528 <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c0024075:	a1 b0 88 03 c0       	mov    0xc00388b0,%eax
c002407a:	ba 00 00 00 00       	mov    $0x0,%edx
c002407f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c0024082:	89 cb                	mov    %ecx,%ebx
c0024084:	0f af da             	imul   %edx,%ebx
c0024087:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c002408a:	0f af c8             	imul   %eax,%ecx
c002408d:	01 d9                	add    %ebx,%ecx
c002408f:	f7 65 f0             	mull   -0x10(%ebp)
c0024092:	01 d1                	add    %edx,%ecx
c0024094:	89 ca                	mov    %ecx,%edx
c0024096:	6a 00                	push   $0x0
c0024098:	68 e8 03 00 00       	push   $0x3e8
c002409d:	52                   	push   %edx
c002409e:	50                   	push   %eax
c002409f:	e8 8a 4e 00 00       	call   c0028f2e <__divdi3>
c00240a4:	83 c4 10             	add    $0x10,%esp
c00240a7:	6b da 64             	imul   $0x64,%edx,%ebx
c00240aa:	6b c8 00             	imul   $0x0,%eax,%ecx
c00240ad:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c00240b0:	b9 64 00 00 00       	mov    $0x64,%ecx
c00240b5:	f7 e1                	mul    %ecx
c00240b7:	89 c1                	mov    %eax,%ecx
c00240b9:	89 d3                	mov    %edx,%ebx
c00240bb:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c00240be:	89 c3                	mov    %eax,%ebx
c00240c0:	8b 75 10             	mov    0x10(%ebp),%esi
c00240c3:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
c00240c8:	f7 ee                	imul   %esi
c00240ca:	c1 fa 06             	sar    $0x6,%edx
c00240cd:	89 f0                	mov    %esi,%eax
c00240cf:	c1 f8 1f             	sar    $0x1f,%eax
c00240d2:	29 c2                	sub    %eax,%edx
c00240d4:	89 d0                	mov    %edx,%eax
c00240d6:	99                   	cltd   
c00240d7:	52                   	push   %edx
c00240d8:	50                   	push   %eax
c00240d9:	53                   	push   %ebx
c00240da:	51                   	push   %ecx
c00240db:	e8 4e 4e 00 00       	call   c0028f2e <__divdi3>
c00240e0:	83 c4 10             	add    $0x10,%esp
c00240e3:	83 ec 08             	sub    $0x8,%esp
c00240e6:	52                   	push   %edx
c00240e7:	50                   	push   %eax
c00240e8:	e8 51 fe ff ff       	call   c0023f3e <busy_wait>
c00240ed:	83 c4 10             	add    $0x10,%esp
}
c00240f0:	90                   	nop
c00240f1:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00240f4:	5b                   	pop    %ebx
c00240f5:	5e                   	pop    %esi
c00240f6:	5d                   	pop    %ebp
c00240f7:	c3                   	ret    

c00240f8 <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c00240f8:	55                   	push   %ebp
c00240f9:	89 e5                	mov    %esp,%ebp
c00240fb:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c00240ff:	7e 0d                	jle    c002410e <isupper+0x16>
c0024101:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c0024105:	7f 07                	jg     c002410e <isupper+0x16>
c0024107:	b8 01 00 00 00       	mov    $0x1,%eax
c002410c:	eb 05                	jmp    c0024113 <isupper+0x1b>
c002410e:	b8 00 00 00 00       	mov    $0x0,%eax
c0024113:	5d                   	pop    %ebp
c0024114:	c3                   	ret    

c0024115 <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0024115:	55                   	push   %ebp
c0024116:	89 e5                	mov    %esp,%ebp
c0024118:	ff 75 08             	pushl  0x8(%ebp)
c002411b:	e8 d8 ff ff ff       	call   c00240f8 <isupper>
c0024120:	83 c4 04             	add    $0x4,%esp
c0024123:	85 c0                	test   %eax,%eax
c0024125:	74 08                	je     c002412f <tolower+0x1a>
c0024127:	8b 45 08             	mov    0x8(%ebp),%eax
c002412a:	83 c0 20             	add    $0x20,%eax
c002412d:	eb 03                	jmp    c0024132 <tolower+0x1d>
c002412f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024132:	c9                   	leave  
c0024133:	c3                   	ret    

c0024134 <inb>:
{
c0024134:	55                   	push   %ebp
c0024135:	89 e5                	mov    %esp,%ebp
c0024137:	83 ec 14             	sub    $0x14,%esp
c002413a:	8b 45 08             	mov    0x8(%ebp),%eax
c002413d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024141:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024144:	89 c2                	mov    %eax,%edx
c0024146:	ec                   	in     (%dx),%al
c0024147:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002414a:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c002414d:	c9                   	leave  
c002414e:	c3                   	ret    

c002414f <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c002414f:	55                   	push   %ebp
c0024150:	89 e5                	mov    %esp,%ebp
c0024152:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c0024155:	83 ec 04             	sub    $0x4,%esp
c0024158:	68 60 f5 02 c0       	push   $0xc002f560
c002415d:	68 95 41 02 c0       	push   $0xc0024195
c0024162:	6a 21                	push   $0x21
c0024164:	e8 42 d4 ff ff       	call   c00215ab <intr_register_ext>
c0024169:	83 c4 10             	add    $0x10,%esp
}
c002416c:	90                   	nop
c002416d:	c9                   	leave  
c002416e:	c3                   	ret    

c002416f <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c002416f:	55                   	push   %ebp
c0024170:	89 e5                	mov    %esp,%ebp
c0024172:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c0024175:	a1 c0 88 03 c0       	mov    0xc00388c0,%eax
c002417a:	8b 15 c4 88 03 c0    	mov    0xc00388c4,%edx
c0024180:	83 ec 04             	sub    $0x4,%esp
c0024183:	52                   	push   %edx
c0024184:	50                   	push   %eax
c0024185:	68 6e f5 02 c0       	push   $0xc002f56e
c002418a:	e8 da 2f 00 00       	call   c0027169 <printf>
c002418f:	83 c4 10             	add    $0x10,%esp
}
c0024192:	90                   	nop
c0024193:	c9                   	leave  
c0024194:	c3                   	ret    

c0024195 <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c0024195:	55                   	push   %ebp
c0024196:	89 e5                	mov    %esp,%ebp
c0024198:	53                   	push   %ebx
c0024199:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c002419c:	a0 b8 88 03 c0       	mov    0xc00388b8,%al
c00241a1:	84 c0                	test   %al,%al
c00241a3:	75 09                	jne    c00241ae <keyboard_interrupt+0x19>
c00241a5:	a0 b9 88 03 c0       	mov    0xc00388b9,%al
c00241aa:	84 c0                	test   %al,%al
c00241ac:	74 07                	je     c00241b5 <keyboard_interrupt+0x20>
c00241ae:	b8 01 00 00 00       	mov    $0x1,%eax
c00241b3:	eb 05                	jmp    c00241ba <keyboard_interrupt+0x25>
c00241b5:	b8 00 00 00 00       	mov    $0x0,%eax
c00241ba:	88 45 ef             	mov    %al,-0x11(%ebp)
c00241bd:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c00241c1:	a0 ba 88 03 c0       	mov    0xc00388ba,%al
c00241c6:	84 c0                	test   %al,%al
c00241c8:	75 09                	jne    c00241d3 <keyboard_interrupt+0x3e>
c00241ca:	a0 bb 88 03 c0       	mov    0xc00388bb,%al
c00241cf:	84 c0                	test   %al,%al
c00241d1:	74 07                	je     c00241da <keyboard_interrupt+0x45>
c00241d3:	b8 01 00 00 00       	mov    $0x1,%eax
c00241d8:	eb 05                	jmp    c00241df <keyboard_interrupt+0x4a>
c00241da:	b8 00 00 00 00       	mov    $0x0,%eax
c00241df:	88 45 ee             	mov    %al,-0x12(%ebp)
c00241e2:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c00241e6:	a0 bc 88 03 c0       	mov    0xc00388bc,%al
c00241eb:	84 c0                	test   %al,%al
c00241ed:	75 09                	jne    c00241f8 <keyboard_interrupt+0x63>
c00241ef:	a0 bd 88 03 c0       	mov    0xc00388bd,%al
c00241f4:	84 c0                	test   %al,%al
c00241f6:	74 07                	je     c00241ff <keyboard_interrupt+0x6a>
c00241f8:	b8 01 00 00 00       	mov    $0x1,%eax
c00241fd:	eb 05                	jmp    c0024204 <keyboard_interrupt+0x6f>
c00241ff:	b8 00 00 00 00       	mov    $0x0,%eax
c0024204:	88 45 ed             	mov    %al,-0x13(%ebp)
c0024207:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c002420b:	6a 60                	push   $0x60
c002420d:	e8 22 ff ff ff       	call   c0024134 <inb>
c0024212:	83 c4 04             	add    $0x4,%esp
c0024215:	0f b6 c0             	movzbl %al,%eax
c0024218:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c002421b:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c0024222:	75 1a                	jne    c002423e <keyboard_interrupt+0xa9>
    code = (code << 8) | inb (DATA_REG);
c0024224:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024227:	c1 e0 08             	shl    $0x8,%eax
c002422a:	89 c3                	mov    %eax,%ebx
c002422c:	6a 60                	push   $0x60
c002422e:	e8 01 ff ff ff       	call   c0024134 <inb>
c0024233:	83 c4 04             	add    $0x4,%esp
c0024236:	0f b6 c0             	movzbl %al,%eax
c0024239:	09 d8                	or     %ebx,%eax
c002423b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c002423e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024241:	25 80 00 00 00       	and    $0x80,%eax
c0024246:	85 c0                	test   %eax,%eax
c0024248:	0f 95 c0             	setne  %al
c002424b:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c002424e:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c0024255:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c0024259:	75 2e                	jne    c0024289 <keyboard_interrupt+0xf4>
    {
      /* Caps Lock. */
      if (!release)
c002425b:	8a 45 ec             	mov    -0x14(%ebp),%al
c002425e:	83 f0 01             	xor    $0x1,%eax
c0024261:	84 c0                	test   %al,%al
c0024263:	0f 84 77 01 00 00    	je     c00243e0 <keyboard_interrupt+0x24b>
        caps_lock = !caps_lock;
c0024269:	a0 be 88 03 c0       	mov    0xc00388be,%al
c002426e:	0f b6 c0             	movzbl %al,%eax
c0024271:	85 c0                	test   %eax,%eax
c0024273:	0f 95 c0             	setne  %al
c0024276:	83 f0 01             	xor    $0x1,%eax
c0024279:	0f b6 c0             	movzbl %al,%eax
c002427c:	83 e0 01             	and    $0x1,%eax
c002427f:	a2 be 88 03 c0       	mov    %al,0xc00388be
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024284:	e9 57 01 00 00       	jmp    c00243e0 <keyboard_interrupt+0x24b>
  else if (map_key (invariant_keymap, code, &c)
c0024289:	83 ec 04             	sub    $0x4,%esp
c002428c:	8d 45 eb             	lea    -0x15(%ebp),%eax
c002428f:	50                   	push   %eax
c0024290:	ff 75 f4             	pushl  -0xc(%ebp)
c0024293:	68 c0 f5 02 c0       	push   $0xc002f5c0
c0024298:	e8 49 01 00 00       	call   c00243e6 <map_key>
c002429d:	83 c4 10             	add    $0x10,%esp
c00242a0:	84 c0                	test   %al,%al
c00242a2:	75 4e                	jne    c00242f2 <keyboard_interrupt+0x15d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00242a4:	8a 45 ef             	mov    -0x11(%ebp),%al
c00242a7:	83 f0 01             	xor    $0x1,%eax
c00242aa:	84 c0                	test   %al,%al
c00242ac:	74 1b                	je     c00242c9 <keyboard_interrupt+0x134>
c00242ae:	83 ec 04             	sub    $0x4,%esp
c00242b1:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00242b4:	50                   	push   %eax
c00242b5:	ff 75 f4             	pushl  -0xc(%ebp)
c00242b8:	68 40 f6 02 c0       	push   $0xc002f640
c00242bd:	e8 24 01 00 00       	call   c00243e6 <map_key>
c00242c2:	83 c4 10             	add    $0x10,%esp
c00242c5:	84 c0                	test   %al,%al
c00242c7:	75 29                	jne    c00242f2 <keyboard_interrupt+0x15d>
           || (shift && map_key (shifted_keymap, code, &c)))
c00242c9:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c00242cd:	0f 84 ce 00 00 00    	je     c00243a1 <keyboard_interrupt+0x20c>
c00242d3:	83 ec 04             	sub    $0x4,%esp
c00242d6:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00242d9:	50                   	push   %eax
c00242da:	ff 75 f4             	pushl  -0xc(%ebp)
c00242dd:	68 a0 f6 02 c0       	push   $0xc002f6a0
c00242e2:	e8 ff 00 00 00       	call   c00243e6 <map_key>
c00242e7:	83 c4 10             	add    $0x10,%esp
c00242ea:	84 c0                	test   %al,%al
c00242ec:	0f 84 af 00 00 00    	je     c00243a1 <keyboard_interrupt+0x20c>
      if (!release) 
c00242f2:	8a 45 ec             	mov    -0x14(%ebp),%al
c00242f5:	83 f0 01             	xor    $0x1,%eax
c00242f8:	84 c0                	test   %al,%al
c00242fa:	0f 84 df 00 00 00    	je     c00243df <keyboard_interrupt+0x24a>
          if (c == 0177 && ctrl && alt)
c0024300:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024303:	3c 7f                	cmp    $0x7f,%al
c0024305:	75 11                	jne    c0024318 <keyboard_interrupt+0x183>
c0024307:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c002430b:	74 0b                	je     c0024318 <keyboard_interrupt+0x183>
c002430d:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024311:	74 05                	je     c0024318 <keyboard_interrupt+0x183>
            shutdown_reboot ();
c0024313:	e8 e5 28 00 00       	call   c0026bfd <shutdown_reboot>
          if (ctrl && c >= 0x40 && c < 0x60) 
c0024318:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c002431c:	74 19                	je     c0024337 <keyboard_interrupt+0x1a2>
c002431e:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024321:	3c 3f                	cmp    $0x3f,%al
c0024323:	76 12                	jbe    c0024337 <keyboard_interrupt+0x1a2>
c0024325:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024328:	3c 5f                	cmp    $0x5f,%al
c002432a:	77 0b                	ja     c0024337 <keyboard_interrupt+0x1a2>
              c -= 0x40; 
c002432c:	8a 45 eb             	mov    -0x15(%ebp),%al
c002432f:	83 e8 40             	sub    $0x40,%eax
c0024332:	88 45 eb             	mov    %al,-0x15(%ebp)
c0024335:	eb 1f                	jmp    c0024356 <keyboard_interrupt+0x1c1>
          else if (shift == caps_lock)
c0024337:	a0 be 88 03 c0       	mov    0xc00388be,%al
c002433c:	38 45 ef             	cmp    %al,-0x11(%ebp)
c002433f:	75 15                	jne    c0024356 <keyboard_interrupt+0x1c1>
            c = tolower (c);
c0024341:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024344:	0f b6 c0             	movzbl %al,%eax
c0024347:	83 ec 0c             	sub    $0xc,%esp
c002434a:	50                   	push   %eax
c002434b:	e8 c5 fd ff ff       	call   c0024115 <tolower>
c0024350:	83 c4 10             	add    $0x10,%esp
c0024353:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (alt)
c0024356:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c002435a:	74 09                	je     c0024365 <keyboard_interrupt+0x1d0>
            c += 0x80;
c002435c:	8a 45 eb             	mov    -0x15(%ebp),%al
c002435f:	83 c0 80             	add    $0xffffff80,%eax
c0024362:	88 45 eb             	mov    %al,-0x15(%ebp)
          if (!input_full ())
c0024365:	e8 3a 21 00 00       	call   c00264a4 <input_full>
c002436a:	83 f0 01             	xor    $0x1,%eax
c002436d:	84 c0                	test   %al,%al
c002436f:	74 6e                	je     c00243df <keyboard_interrupt+0x24a>
              key_cnt++;
c0024371:	a1 c0 88 03 c0       	mov    0xc00388c0,%eax
c0024376:	8b 15 c4 88 03 c0    	mov    0xc00388c4,%edx
c002437c:	83 c0 01             	add    $0x1,%eax
c002437f:	83 d2 00             	adc    $0x0,%edx
c0024382:	a3 c0 88 03 c0       	mov    %eax,0xc00388c0
c0024387:	89 15 c4 88 03 c0    	mov    %edx,0xc00388c4
              input_putc (c);
c002438d:	8a 45 eb             	mov    -0x15(%ebp),%al
c0024390:	0f b6 c0             	movzbl %al,%eax
c0024393:	83 ec 0c             	sub    $0xc,%esp
c0024396:	50                   	push   %eax
c0024397:	e8 4a 20 00 00       	call   c00263e6 <input_putc>
c002439c:	83 c4 10             	add    $0x10,%esp
      if (!release) 
c002439f:	eb 3e                	jmp    c00243df <keyboard_interrupt+0x24a>
      for (key = shift_keys; key->scancode != 0; key++) 
c00243a1:	c7 45 f0 e0 f6 02 c0 	movl   $0xc002f6e0,-0x10(%ebp)
c00243a8:	eb 2a                	jmp    c00243d4 <keyboard_interrupt+0x23f>
        if (key->scancode == code)
c00243aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00243ad:	8b 00                	mov    (%eax),%eax
c00243af:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00243b2:	75 1c                	jne    c00243d0 <keyboard_interrupt+0x23b>
            *key->state_var = !release;
c00243b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00243b7:	8b 50 04             	mov    0x4(%eax),%edx
c00243ba:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00243be:	85 c0                	test   %eax,%eax
c00243c0:	0f 95 c0             	setne  %al
c00243c3:	83 f0 01             	xor    $0x1,%eax
c00243c6:	0f b6 c0             	movzbl %al,%eax
c00243c9:	83 e0 01             	and    $0x1,%eax
c00243cc:	88 02                	mov    %al,(%edx)
            break;
c00243ce:	eb 10                	jmp    c00243e0 <keyboard_interrupt+0x24b>
      for (key = shift_keys; key->scancode != 0; key++) 
c00243d0:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c00243d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00243d7:	8b 00                	mov    (%eax),%eax
c00243d9:	85 c0                	test   %eax,%eax
c00243db:	75 cd                	jne    c00243aa <keyboard_interrupt+0x215>
}
c00243dd:	eb 01                	jmp    c00243e0 <keyboard_interrupt+0x24b>
      if (!release) 
c00243df:	90                   	nop
}
c00243e0:	90                   	nop
c00243e1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00243e4:	c9                   	leave  
c00243e5:	c3                   	ret    

c00243e6 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c00243e6:	55                   	push   %ebp
c00243e7:	89 e5                	mov    %esp,%ebp
c00243e9:	53                   	push   %ebx
c00243ea:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c00243ed:	eb 56                	jmp    c0024445 <map_key+0x5f>
    if (scancode >= k->first_scancode
c00243ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00243f2:	8a 00                	mov    (%eax),%al
c00243f4:	0f b6 c0             	movzbl %al,%eax
c00243f7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00243fa:	77 45                	ja     c0024441 <map_key+0x5b>
        && scancode < k->first_scancode + strlen (k->chars)) 
c00243fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00243ff:	8a 00                	mov    (%eax),%al
c0024401:	0f b6 d8             	movzbl %al,%ebx
c0024404:	8b 45 08             	mov    0x8(%ebp),%eax
c0024407:	8b 40 04             	mov    0x4(%eax),%eax
c002440a:	83 ec 0c             	sub    $0xc,%esp
c002440d:	50                   	push   %eax
c002440e:	e8 88 45 00 00       	call   c002899b <strlen>
c0024413:	83 c4 10             	add    $0x10,%esp
c0024416:	01 d8                	add    %ebx,%eax
c0024418:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002441b:	76 24                	jbe    c0024441 <map_key+0x5b>
      {
        *c = k->chars[scancode - k->first_scancode];
c002441d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024420:	8b 50 04             	mov    0x4(%eax),%edx
c0024423:	8b 45 08             	mov    0x8(%ebp),%eax
c0024426:	8a 00                	mov    (%eax),%al
c0024428:	0f b6 c0             	movzbl %al,%eax
c002442b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002442e:	29 c1                	sub    %eax,%ecx
c0024430:	89 c8                	mov    %ecx,%eax
c0024432:	01 d0                	add    %edx,%eax
c0024434:	8a 00                	mov    (%eax),%al
c0024436:	88 c2                	mov    %al,%dl
c0024438:	8b 45 10             	mov    0x10(%ebp),%eax
c002443b:	88 10                	mov    %dl,(%eax)
        return true; 
c002443d:	b0 01                	mov    $0x1,%al
c002443f:	eb 0f                	jmp    c0024450 <map_key+0x6a>
  for (; k->first_scancode != 0; k++)
c0024441:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c0024445:	8b 45 08             	mov    0x8(%ebp),%eax
c0024448:	8a 00                	mov    (%eax),%al
c002444a:	84 c0                	test   %al,%al
c002444c:	75 a1                	jne    c00243ef <map_key+0x9>
      }

  return false;
c002444e:	b0 00                	mov    $0x0,%al
}
c0024450:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024453:	c9                   	leave  
c0024454:	c3                   	ret    

c0024455 <inb>:
{
c0024455:	55                   	push   %ebp
c0024456:	89 e5                	mov    %esp,%ebp
c0024458:	83 ec 14             	sub    $0x14,%esp
c002445b:	8b 45 08             	mov    0x8(%ebp),%eax
c002445e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024462:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0024465:	89 c2                	mov    %eax,%edx
c0024467:	ec                   	in     (%dx),%al
c0024468:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002446b:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c002446e:	c9                   	leave  
c002446f:	c3                   	ret    

c0024470 <outb>:
{
c0024470:	55                   	push   %ebp
c0024471:	89 e5                	mov    %esp,%ebp
c0024473:	83 ec 08             	sub    $0x8,%esp
c0024476:	8b 45 08             	mov    0x8(%ebp),%eax
c0024479:	8b 55 0c             	mov    0xc(%ebp),%edx
c002447c:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0024480:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024483:	8a 45 f8             	mov    -0x8(%ebp),%al
c0024486:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024489:	ee                   	out    %al,(%dx)
}
c002448a:	90                   	nop
c002448b:	c9                   	leave  
c002448c:	c3                   	ret    

c002448d <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c002448d:	55                   	push   %ebp
c002448e:	89 e5                	mov    %esp,%ebp
c0024490:	83 ec 08             	sub    $0x8,%esp
c0024493:	8b 55 08             	mov    0x8(%ebp),%edx
c0024496:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024499:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c002449d:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c00244a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00244a4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00244a7:	66 ef                	out    %ax,(%dx)
}
c00244a9:	90                   	nop
c00244aa:	c9                   	leave  
c00244ab:	c3                   	ret    

c00244ac <ptov>:
{
c00244ac:	55                   	push   %ebp
c00244ad:	89 e5                	mov    %esp,%ebp
c00244af:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00244b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00244b5:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00244ba:	76 1e                	jbe    c00244da <ptov+0x2e>
c00244bc:	83 ec 0c             	sub    $0xc,%esp
c00244bf:	68 18 f7 02 c0       	push   $0xc002f718
c00244c4:	68 33 f7 02 c0       	push   $0xc002f733
c00244c9:	68 7c f7 02 c0       	push   $0xc002f77c
c00244ce:	6a 4a                	push   $0x4a
c00244d0:	68 4a f7 02 c0       	push   $0xc002f74a
c00244d5:	e8 4e 50 00 00       	call   c0029528 <debug_panic>
  return (void *) (paddr + PHYS_BASE);
c00244da:	8b 45 08             	mov    0x8(%ebp),%eax
c00244dd:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00244e2:	c9                   	leave  
c00244e3:	c3                   	ret    

c00244e4 <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c00244e4:	55                   	push   %ebp
c00244e5:	89 e5                	mov    %esp,%ebp
c00244e7:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c00244ea:	a0 d4 88 03 c0       	mov    0xc00388d4,%al
c00244ef:	83 f0 01             	xor    $0x1,%eax
c00244f2:	84 c0                	test   %al,%al
c00244f4:	74 31                	je     c0024527 <init+0x43>
    {
      fb = ptov (0xb8000);
c00244f6:	83 ec 0c             	sub    $0xc,%esp
c00244f9:	68 00 80 0b 00       	push   $0xb8000
c00244fe:	e8 a9 ff ff ff       	call   c00244ac <ptov>
c0024503:	83 c4 10             	add    $0x10,%esp
c0024506:	a3 d0 88 03 c0       	mov    %eax,0xc00388d0
      find_cursor (&cx, &cy);
c002450b:	83 ec 08             	sub    $0x8,%esp
c002450e:	68 cc 88 03 c0       	push   $0xc00388cc
c0024513:	68 c8 88 03 c0       	push   $0xc00388c8
c0024518:	e8 8f 02 00 00       	call   c00247ac <find_cursor>
c002451d:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c0024520:	c6 05 d4 88 03 c0 01 	movb   $0x1,0xc00388d4
    }
}
c0024527:	90                   	nop
c0024528:	c9                   	leave  
c0024529:	c3                   	ret    

c002452a <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c002452a:	55                   	push   %ebp
c002452b:	89 e5                	mov    %esp,%ebp
c002452d:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0024530:	e8 57 ce ff ff       	call   c002138c <intr_disable>
c0024535:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c0024538:	e8 a7 ff ff ff       	call   c00244e4 <init>
  
  switch (c) 
c002453d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024540:	83 e8 07             	sub    $0x7,%eax
c0024543:	83 f8 06             	cmp    $0x6,%eax
c0024546:	0f 87 8b 00 00 00    	ja     c00245d7 <vga_putc+0xad>
c002454c:	8b 04 85 60 f7 02 c0 	mov    -0x3ffd08a0(,%eax,4),%eax
c0024553:	ff e0                	jmp    *%eax
    {
    case '\n':
      newline ();
c0024555:	e8 95 01 00 00       	call   c00246ef <newline>
      break;
c002455a:	e9 e2 00 00 00       	jmp    c0024641 <vga_putc+0x117>

    case '\f':
      cls ();
c002455f:	e8 f3 00 00 00       	call   c0024657 <cls>
      break;
c0024564:	e9 d8 00 00 00       	jmp    c0024641 <vga_putc+0x117>

    case '\b':
      if (cx > 0)
c0024569:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c002456e:	85 c0                	test   %eax,%eax
c0024570:	0f 84 c4 00 00 00    	je     c002463a <vga_putc+0x110>
        cx--;
c0024576:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c002457b:	48                   	dec    %eax
c002457c:	a3 c8 88 03 c0       	mov    %eax,0xc00388c8
      break;
c0024581:	e9 b4 00 00 00       	jmp    c002463a <vga_putc+0x110>
      
    case '\r':
      cx = 0;
c0024586:	c7 05 c8 88 03 c0 00 	movl   $0x0,0xc00388c8
c002458d:	00 00 00 
      break;
c0024590:	e9 ac 00 00 00       	jmp    c0024641 <vga_putc+0x117>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c0024595:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c002459a:	83 c0 08             	add    $0x8,%eax
c002459d:	83 e0 f8             	and    $0xfffffff8,%eax
c00245a0:	a3 c8 88 03 c0       	mov    %eax,0xc00388c8
      if (cx >= COL_CNT)
c00245a5:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c00245aa:	83 f8 4f             	cmp    $0x4f,%eax
c00245ad:	0f 86 8a 00 00 00    	jbe    c002463d <vga_putc+0x113>
        newline ();
c00245b3:	e8 37 01 00 00       	call   c00246ef <newline>
      break;
c00245b8:	e9 80 00 00 00       	jmp    c002463d <vga_putc+0x113>

    case '\a':
      intr_set_level (old_level);
c00245bd:	83 ec 0c             	sub    $0xc,%esp
c00245c0:	ff 75 f4             	pushl  -0xc(%ebp)
c00245c3:	e8 6c cd ff ff       	call   c0021334 <intr_set_level>
c00245c8:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c00245cb:	e8 52 28 00 00       	call   c0026e22 <speaker_beep>
      intr_disable ();
c00245d0:	e8 b7 cd ff ff       	call   c002138c <intr_disable>
      break;
c00245d5:	eb 6a                	jmp    c0024641 <vga_putc+0x117>
      
    default:
      fb[cy][cx][0] = c;
c00245d7:	8b 0d d0 88 03 c0    	mov    0xc00388d0,%ecx
c00245dd:	8b 15 cc 88 03 c0    	mov    0xc00388cc,%edx
c00245e3:	89 d0                	mov    %edx,%eax
c00245e5:	c1 e0 02             	shl    $0x2,%eax
c00245e8:	01 d0                	add    %edx,%eax
c00245ea:	c1 e0 05             	shl    $0x5,%eax
c00245ed:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00245f0:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c00245f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00245f8:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c00245fb:	8b 0d d0 88 03 c0    	mov    0xc00388d0,%ecx
c0024601:	8b 15 cc 88 03 c0    	mov    0xc00388cc,%edx
c0024607:	89 d0                	mov    %edx,%eax
c0024609:	c1 e0 02             	shl    $0x2,%eax
c002460c:	01 d0                	add    %edx,%eax
c002460e:	c1 e0 05             	shl    $0x5,%eax
c0024611:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024614:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c0024619:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c002461e:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c0024623:	40                   	inc    %eax
c0024624:	a3 c8 88 03 c0       	mov    %eax,0xc00388c8
c0024629:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c002462e:	83 f8 4f             	cmp    $0x4f,%eax
c0024631:	76 0d                	jbe    c0024640 <vga_putc+0x116>
        newline ();
c0024633:	e8 b7 00 00 00       	call   c00246ef <newline>
      break;
c0024638:	eb 06                	jmp    c0024640 <vga_putc+0x116>
      break;
c002463a:	90                   	nop
c002463b:	eb 04                	jmp    c0024641 <vga_putc+0x117>
      break;
c002463d:	90                   	nop
c002463e:	eb 01                	jmp    c0024641 <vga_putc+0x117>
      break;
c0024640:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c0024641:	e8 0a 01 00 00       	call   c0024750 <move_cursor>

  intr_set_level (old_level);
c0024646:	83 ec 0c             	sub    $0xc,%esp
c0024649:	ff 75 f4             	pushl  -0xc(%ebp)
c002464c:	e8 e3 cc ff ff       	call   c0021334 <intr_set_level>
c0024651:	83 c4 10             	add    $0x10,%esp
}
c0024654:	90                   	nop
c0024655:	c9                   	leave  
c0024656:	c3                   	ret    

c0024657 <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c0024657:	55                   	push   %ebp
c0024658:	89 e5                	mov    %esp,%ebp
c002465a:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c002465d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0024664:	eb 11                	jmp    c0024677 <cls+0x20>
    clear_row (y);
c0024666:	83 ec 0c             	sub    $0xc,%esp
c0024669:	ff 75 f4             	pushl  -0xc(%ebp)
c002466c:	e8 28 00 00 00       	call   c0024699 <clear_row>
c0024671:	83 c4 10             	add    $0x10,%esp
  for (y = 0; y < ROW_CNT; y++)
c0024674:	ff 45 f4             	incl   -0xc(%ebp)
c0024677:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c002467b:	76 e9                	jbe    c0024666 <cls+0xf>

  cx = cy = 0;
c002467d:	c7 05 cc 88 03 c0 00 	movl   $0x0,0xc00388cc
c0024684:	00 00 00 
c0024687:	a1 cc 88 03 c0       	mov    0xc00388cc,%eax
c002468c:	a3 c8 88 03 c0       	mov    %eax,0xc00388c8
  move_cursor ();
c0024691:	e8 ba 00 00 00       	call   c0024750 <move_cursor>
}
c0024696:	90                   	nop
c0024697:	c9                   	leave  
c0024698:	c3                   	ret    

c0024699 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c0024699:	55                   	push   %ebp
c002469a:	89 e5                	mov    %esp,%ebp
c002469c:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c002469f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00246a6:	eb 3e                	jmp    c00246e6 <clear_row+0x4d>
    {
      fb[y][x][0] = ' ';
c00246a8:	8b 0d d0 88 03 c0    	mov    0xc00388d0,%ecx
c00246ae:	8b 55 08             	mov    0x8(%ebp),%edx
c00246b1:	89 d0                	mov    %edx,%eax
c00246b3:	c1 e0 02             	shl    $0x2,%eax
c00246b6:	01 d0                	add    %edx,%eax
c00246b8:	c1 e0 05             	shl    $0x5,%eax
c00246bb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00246be:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00246c1:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c00246c5:	8b 0d d0 88 03 c0    	mov    0xc00388d0,%ecx
c00246cb:	8b 55 08             	mov    0x8(%ebp),%edx
c00246ce:	89 d0                	mov    %edx,%eax
c00246d0:	c1 e0 02             	shl    $0x2,%eax
c00246d3:	01 d0                	add    %edx,%eax
c00246d5:	c1 e0 05             	shl    $0x5,%eax
c00246d8:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c00246db:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00246de:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
  for (x = 0; x < COL_CNT; x++)
c00246e3:	ff 45 fc             	incl   -0x4(%ebp)
c00246e6:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c00246ea:	76 bc                	jbe    c00246a8 <clear_row+0xf>
    }
}
c00246ec:	90                   	nop
c00246ed:	c9                   	leave  
c00246ee:	c3                   	ret    

c00246ef <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c00246ef:	55                   	push   %ebp
c00246f0:	89 e5                	mov    %esp,%ebp
c00246f2:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c00246f5:	c7 05 c8 88 03 c0 00 	movl   $0x0,0xc00388c8
c00246fc:	00 00 00 
  cy++;
c00246ff:	a1 cc 88 03 c0       	mov    0xc00388cc,%eax
c0024704:	40                   	inc    %eax
c0024705:	a3 cc 88 03 c0       	mov    %eax,0xc00388cc
  if (cy >= ROW_CNT)
c002470a:	a1 cc 88 03 c0       	mov    0xc00388cc,%eax
c002470f:	83 f8 18             	cmp    $0x18,%eax
c0024712:	76 39                	jbe    c002474d <newline+0x5e>
    {
      cy = ROW_CNT - 1;
c0024714:	c7 05 cc 88 03 c0 18 	movl   $0x18,0xc00388cc
c002471b:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c002471e:	a1 d0 88 03 c0       	mov    0xc00388d0,%eax
c0024723:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0024729:	a1 d0 88 03 c0       	mov    0xc00388d0,%eax
c002472e:	83 ec 04             	sub    $0x4,%esp
c0024731:	68 00 0f 00 00       	push   $0xf00
c0024736:	52                   	push   %edx
c0024737:	50                   	push   %eax
c0024738:	e8 b9 3c 00 00       	call   c00283f6 <memmove>
c002473d:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c0024740:	83 ec 0c             	sub    $0xc,%esp
c0024743:	6a 18                	push   $0x18
c0024745:	e8 4f ff ff ff       	call   c0024699 <clear_row>
c002474a:	83 c4 10             	add    $0x10,%esp
    }
}
c002474d:	90                   	nop
c002474e:	c9                   	leave  
c002474f:	c3                   	ret    

c0024750 <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c0024750:	55                   	push   %ebp
c0024751:	89 e5                	mov    %esp,%ebp
c0024753:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0024756:	a1 cc 88 03 c0       	mov    0xc00388cc,%eax
c002475b:	89 c2                	mov    %eax,%edx
c002475d:	89 d0                	mov    %edx,%eax
c002475f:	c1 e0 02             	shl    $0x2,%eax
c0024762:	01 d0                	add    %edx,%eax
c0024764:	c1 e0 04             	shl    $0x4,%eax
c0024767:	89 c2                	mov    %eax,%edx
c0024769:	a1 c8 88 03 c0       	mov    0xc00388c8,%eax
c002476e:	01 d0                	add    %edx,%eax
c0024770:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0024774:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c0024778:	b0 00                	mov    $0x0,%al
c002477a:	83 c8 0e             	or     $0xe,%eax
c002477d:	0f b7 c0             	movzwl %ax,%eax
c0024780:	50                   	push   %eax
c0024781:	68 d4 03 00 00       	push   $0x3d4
c0024786:	e8 02 fd ff ff       	call   c002448d <outw>
c002478b:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c002478e:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0024792:	c1 e0 08             	shl    $0x8,%eax
c0024795:	83 c8 0f             	or     $0xf,%eax
c0024798:	0f b7 c0             	movzwl %ax,%eax
c002479b:	50                   	push   %eax
c002479c:	68 d4 03 00 00       	push   $0x3d4
c00247a1:	e8 e7 fc ff ff       	call   c002448d <outw>
c00247a6:	83 c4 08             	add    $0x8,%esp
}
c00247a9:	90                   	nop
c00247aa:	c9                   	leave  
c00247ab:	c3                   	ret    

c00247ac <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c00247ac:	55                   	push   %ebp
c00247ad:	89 e5                	mov    %esp,%ebp
c00247af:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c00247b2:	6a 0e                	push   $0xe
c00247b4:	68 d4 03 00 00       	push   $0x3d4
c00247b9:	e8 b2 fc ff ff       	call   c0024470 <outb>
c00247be:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c00247c1:	68 d5 03 00 00       	push   $0x3d5
c00247c6:	e8 8a fc ff ff       	call   c0024455 <inb>
c00247cb:	83 c4 04             	add    $0x4,%esp
c00247ce:	0f b6 c0             	movzbl %al,%eax
c00247d1:	c1 e0 08             	shl    $0x8,%eax
c00247d4:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c00247d8:	6a 0f                	push   $0xf
c00247da:	68 d4 03 00 00       	push   $0x3d4
c00247df:	e8 8c fc ff ff       	call   c0024470 <outb>
c00247e4:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c00247e7:	68 d5 03 00 00       	push   $0x3d5
c00247ec:	e8 64 fc ff ff       	call   c0024455 <inb>
c00247f1:	83 c4 04             	add    $0x4,%esp
c00247f4:	0f b6 c0             	movzbl %al,%eax
c00247f7:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c00247fb:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c00247ff:	b9 50 00 00 00       	mov    $0x50,%ecx
c0024804:	ba 00 00 00 00       	mov    $0x0,%edx
c0024809:	66 f7 f1             	div    %cx
c002480c:	89 d0                	mov    %edx,%eax
c002480e:	0f b7 d0             	movzwl %ax,%edx
c0024811:	8b 45 08             	mov    0x8(%ebp),%eax
c0024814:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c0024816:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
c002481a:	0f b7 d0             	movzwl %ax,%edx
c002481d:	89 d0                	mov    %edx,%eax
c002481f:	c1 e0 02             	shl    $0x2,%eax
c0024822:	01 d0                	add    %edx,%eax
c0024824:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c002482b:	01 c8                	add    %ecx,%eax
c002482d:	01 c0                	add    %eax,%eax
c002482f:	01 d0                	add    %edx,%eax
c0024831:	89 c1                	mov    %eax,%ecx
c0024833:	c1 e1 08             	shl    $0x8,%ecx
c0024836:	01 c8                	add    %ecx,%eax
c0024838:	c1 e0 02             	shl    $0x2,%eax
c002483b:	01 d0                	add    %edx,%eax
c002483d:	c1 e8 10             	shr    $0x10,%eax
c0024840:	66 c1 e8 06          	shr    $0x6,%ax
c0024844:	0f b7 d0             	movzwl %ax,%edx
c0024847:	8b 45 0c             	mov    0xc(%ebp),%eax
c002484a:	89 10                	mov    %edx,(%eax)
}
c002484c:	90                   	nop
c002484d:	c9                   	leave  
c002484e:	c3                   	ret    

c002484f <inb>:
{
c002484f:	55                   	push   %ebp
c0024850:	89 e5                	mov    %esp,%ebp
c0024852:	83 ec 14             	sub    $0x14,%esp
c0024855:	8b 45 08             	mov    0x8(%ebp),%eax
c0024858:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c002485c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002485f:	89 c2                	mov    %eax,%edx
c0024861:	ec                   	in     (%dx),%al
c0024862:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024865:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0024868:	c9                   	leave  
c0024869:	c3                   	ret    

c002486a <outb>:
{
c002486a:	55                   	push   %ebp
c002486b:	89 e5                	mov    %esp,%ebp
c002486d:	83 ec 08             	sub    $0x8,%esp
c0024870:	8b 45 08             	mov    0x8(%ebp),%eax
c0024873:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024876:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c002487a:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c002487d:	8a 45 f8             	mov    -0x8(%ebp),%al
c0024880:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0024883:	ee                   	out    %al,(%dx)
}
c0024884:	90                   	nop
c0024885:	c9                   	leave  
c0024886:	c3                   	ret    

c0024887 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024887:	55                   	push   %ebp
c0024888:	89 e5                	mov    %esp,%ebp
c002488a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c002488d:	a1 e0 88 03 c0       	mov    0xc00388e0,%eax
c0024892:	85 c0                	test   %eax,%eax
c0024894:	74 1e                	je     c00248b4 <init_poll+0x2d>
c0024896:	83 ec 0c             	sub    $0xc,%esp
c0024899:	68 84 f7 02 c0       	push   $0xc002f784
c002489e:	68 93 f7 02 c0       	push   $0xc002f793
c00248a3:	68 10 f8 02 c0       	push   $0xc002f810
c00248a8:	6a 45                	push   $0x45
c00248aa:	68 aa f7 02 c0       	push   $0xc002f7aa
c00248af:	e8 74 4c 00 00       	call   c0029528 <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c00248b4:	83 ec 08             	sub    $0x8,%esp
c00248b7:	6a 00                	push   $0x0
c00248b9:	68 f9 03 00 00       	push   $0x3f9
c00248be:	e8 a7 ff ff ff       	call   c002486a <outb>
c00248c3:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c00248c6:	83 ec 08             	sub    $0x8,%esp
c00248c9:	6a 00                	push   $0x0
c00248cb:	68 fa 03 00 00       	push   $0x3fa
c00248d0:	e8 95 ff ff ff       	call   c002486a <outb>
c00248d5:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c00248d8:	83 ec 0c             	sub    $0xc,%esp
c00248db:	68 80 25 00 00       	push   $0x2580
c00248e0:	e8 e8 01 00 00       	call   c0024acd <set_serial>
c00248e5:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c00248e8:	83 ec 08             	sub    $0x8,%esp
c00248eb:	6a 08                	push   $0x8
c00248ed:	68 fc 03 00 00       	push   $0x3fc
c00248f2:	e8 73 ff ff ff       	call   c002486a <outb>
c00248f7:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c00248fa:	83 ec 0c             	sub    $0xc,%esp
c00248fd:	68 00 89 03 c0       	push   $0xc0038900
c0024902:	e8 dc 1b 00 00       	call   c00264e3 <intq_init>
c0024907:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c002490a:	c7 05 e0 88 03 c0 01 	movl   $0x1,0xc00388e0
c0024911:	00 00 00 
} 
c0024914:	90                   	nop
c0024915:	c9                   	leave  
c0024916:	c3                   	ret    

c0024917 <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0024917:	55                   	push   %ebp
c0024918:	89 e5                	mov    %esp,%ebp
c002491a:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c002491d:	a1 e0 88 03 c0       	mov    0xc00388e0,%eax
c0024922:	85 c0                	test   %eax,%eax
c0024924:	75 05                	jne    c002492b <serial_init_queue+0x14>
    init_poll ();
c0024926:	e8 5c ff ff ff       	call   c0024887 <init_poll>
  ASSERT (mode == POLL);
c002492b:	a1 e0 88 03 c0       	mov    0xc00388e0,%eax
c0024930:	83 f8 01             	cmp    $0x1,%eax
c0024933:	74 1e                	je     c0024953 <serial_init_queue+0x3c>
c0024935:	83 ec 0c             	sub    $0xc,%esp
c0024938:	68 c1 f7 02 c0       	push   $0xc002f7c1
c002493d:	68 93 f7 02 c0       	push   $0xc002f793
c0024942:	68 1c f8 02 c0       	push   $0xc002f81c
c0024947:	6a 58                	push   $0x58
c0024949:	68 aa f7 02 c0       	push   $0xc002f7aa
c002494e:	e8 d5 4b 00 00       	call   c0029528 <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024953:	83 ec 04             	sub    $0x4,%esp
c0024956:	68 ce f7 02 c0       	push   $0xc002f7ce
c002495b:	68 56 4c 02 c0       	push   $0xc0024c56
c0024960:	6a 24                	push   $0x24
c0024962:	e8 44 cc ff ff       	call   c00215ab <intr_register_ext>
c0024967:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c002496a:	c7 05 e0 88 03 c0 02 	movl   $0x2,0xc00388e0
c0024971:	00 00 00 
  old_level = intr_disable ();
c0024974:	e8 13 ca ff ff       	call   c002138c <intr_disable>
c0024979:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c002497c:	e8 f5 01 00 00       	call   c0024b76 <write_ier>
  intr_set_level (old_level);
c0024981:	83 ec 0c             	sub    $0xc,%esp
c0024984:	ff 75 f4             	pushl  -0xc(%ebp)
c0024987:	e8 a8 c9 ff ff       	call   c0021334 <intr_set_level>
c002498c:	83 c4 10             	add    $0x10,%esp
}
c002498f:	90                   	nop
c0024990:	c9                   	leave  
c0024991:	c3                   	ret    

c0024992 <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c0024992:	55                   	push   %ebp
c0024993:	89 e5                	mov    %esp,%ebp
c0024995:	83 ec 28             	sub    $0x28,%esp
c0024998:	8b 45 08             	mov    0x8(%ebp),%eax
c002499b:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c002499e:	e8 e9 c9 ff ff       	call   c002138c <intr_disable>
c00249a3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c00249a6:	a1 e0 88 03 c0       	mov    0xc00388e0,%eax
c00249ab:	83 f8 02             	cmp    $0x2,%eax
c00249ae:	74 20                	je     c00249d0 <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c00249b0:	a1 e0 88 03 c0       	mov    0xc00388e0,%eax
c00249b5:	85 c0                	test   %eax,%eax
c00249b7:	75 05                	jne    c00249be <serial_putc+0x2c>
        init_poll ();
c00249b9:	e8 c9 fe ff ff       	call   c0024887 <init_poll>
      putc_poll (byte); 
c00249be:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00249c2:	83 ec 0c             	sub    $0xc,%esp
c00249c5:	50                   	push   %eax
c00249c6:	e8 22 02 00 00       	call   c0024bed <putc_poll>
c00249cb:	83 c4 10             	add    $0x10,%esp
c00249ce:	eb 53                	jmp    c0024a23 <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c00249d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00249d4:	75 33                	jne    c0024a09 <serial_putc+0x77>
c00249d6:	83 ec 0c             	sub    $0xc,%esp
c00249d9:	68 00 89 03 c0       	push   $0xc0038900
c00249de:	e8 84 1b 00 00       	call   c0026567 <intq_full>
c00249e3:	83 c4 10             	add    $0x10,%esp
c00249e6:	84 c0                	test   %al,%al
c00249e8:	74 1f                	je     c0024a09 <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c00249ea:	83 ec 0c             	sub    $0xc,%esp
c00249ed:	68 00 89 03 c0       	push   $0xc0038900
c00249f2:	e8 be 1b 00 00       	call   c00265b5 <intq_getc>
c00249f7:	83 c4 10             	add    $0x10,%esp
c00249fa:	0f b6 c0             	movzbl %al,%eax
c00249fd:	83 ec 0c             	sub    $0xc,%esp
c0024a00:	50                   	push   %eax
c0024a01:	e8 e7 01 00 00       	call   c0024bed <putc_poll>
c0024a06:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0024a09:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0024a0d:	83 ec 08             	sub    $0x8,%esp
c0024a10:	50                   	push   %eax
c0024a11:	68 00 89 03 c0       	push   $0xc0038900
c0024a16:	e8 7a 1c 00 00       	call   c0026695 <intq_putc>
c0024a1b:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0024a1e:	e8 53 01 00 00       	call   c0024b76 <write_ier>
    }
  
  intr_set_level (old_level);
c0024a23:	83 ec 0c             	sub    $0xc,%esp
c0024a26:	ff 75 f4             	pushl  -0xc(%ebp)
c0024a29:	e8 06 c9 ff ff       	call   c0021334 <intr_set_level>
c0024a2e:	83 c4 10             	add    $0x10,%esp
}
c0024a31:	90                   	nop
c0024a32:	c9                   	leave  
c0024a33:	c3                   	ret    

c0024a34 <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c0024a34:	55                   	push   %ebp
c0024a35:	89 e5                	mov    %esp,%ebp
c0024a37:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0024a3a:	e8 4d c9 ff ff       	call   c002138c <intr_disable>
c0024a3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c0024a42:	eb 1f                	jmp    c0024a63 <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c0024a44:	83 ec 0c             	sub    $0xc,%esp
c0024a47:	68 00 89 03 c0       	push   $0xc0038900
c0024a4c:	e8 64 1b 00 00       	call   c00265b5 <intq_getc>
c0024a51:	83 c4 10             	add    $0x10,%esp
c0024a54:	0f b6 c0             	movzbl %al,%eax
c0024a57:	83 ec 0c             	sub    $0xc,%esp
c0024a5a:	50                   	push   %eax
c0024a5b:	e8 8d 01 00 00       	call   c0024bed <putc_poll>
c0024a60:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq))
c0024a63:	83 ec 0c             	sub    $0xc,%esp
c0024a66:	68 00 89 03 c0       	push   $0xc0038900
c0024a6b:	e8 b7 1a 00 00       	call   c0026527 <intq_empty>
c0024a70:	83 c4 10             	add    $0x10,%esp
c0024a73:	83 f0 01             	xor    $0x1,%eax
c0024a76:	84 c0                	test   %al,%al
c0024a78:	75 ca                	jne    c0024a44 <serial_flush+0x10>
  intr_set_level (old_level);
c0024a7a:	83 ec 0c             	sub    $0xc,%esp
c0024a7d:	ff 75 f4             	pushl  -0xc(%ebp)
c0024a80:	e8 af c8 ff ff       	call   c0021334 <intr_set_level>
c0024a85:	83 c4 10             	add    $0x10,%esp
}
c0024a88:	90                   	nop
c0024a89:	c9                   	leave  
c0024a8a:	c3                   	ret    

c0024a8b <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c0024a8b:	55                   	push   %ebp
c0024a8c:	89 e5                	mov    %esp,%ebp
c0024a8e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0024a91:	e8 81 c8 ff ff       	call   c0021317 <intr_get_level>
c0024a96:	85 c0                	test   %eax,%eax
c0024a98:	74 21                	je     c0024abb <serial_notify+0x30>
c0024a9a:	83 ec 0c             	sub    $0xc,%esp
c0024a9d:	68 d5 f7 02 c0       	push   $0xc002f7d5
c0024aa2:	68 93 f7 02 c0       	push   $0xc002f793
c0024aa7:	68 30 f8 02 c0       	push   $0xc002f830
c0024aac:	68 96 00 00 00       	push   $0x96
c0024ab1:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024ab6:	e8 6d 4a 00 00       	call   c0029528 <debug_panic>
  if (mode == QUEUE)
c0024abb:	a1 e0 88 03 c0       	mov    0xc00388e0,%eax
c0024ac0:	83 f8 02             	cmp    $0x2,%eax
c0024ac3:	75 05                	jne    c0024aca <serial_notify+0x3f>
    write_ier ();
c0024ac5:	e8 ac 00 00 00       	call   c0024b76 <write_ier>
}
c0024aca:	90                   	nop
c0024acb:	c9                   	leave  
c0024acc:	c3                   	ret    

c0024acd <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0024acd:	55                   	push   %ebp
c0024ace:	89 e5                	mov    %esp,%ebp
c0024ad0:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c0024ad3:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c0024ada:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024add:	99                   	cltd   
c0024ade:	f7 7d 08             	idivl  0x8(%ebp)
c0024ae1:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c0024ae5:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c0024aec:	7e 09                	jle    c0024af7 <set_serial+0x2a>
c0024aee:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c0024af5:	7e 21                	jle    c0024b18 <set_serial+0x4b>
c0024af7:	83 ec 0c             	sub    $0xc,%esp
c0024afa:	68 f3 f7 02 c0       	push   $0xc002f7f3
c0024aff:	68 93 f7 02 c0       	push   $0xc002f793
c0024b04:	68 40 f8 02 c0       	push   $0xc002f840
c0024b09:	68 a2 00 00 00       	push   $0xa2
c0024b0e:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024b13:	e8 10 4a 00 00       	call   c0029528 <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c0024b18:	83 ec 08             	sub    $0x8,%esp
c0024b1b:	68 83 00 00 00       	push   $0x83
c0024b20:	68 fb 03 00 00       	push   $0x3fb
c0024b25:	e8 40 fd ff ff       	call   c002486a <outb>
c0024b2a:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c0024b2d:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0024b31:	0f b6 c0             	movzbl %al,%eax
c0024b34:	83 ec 08             	sub    $0x8,%esp
c0024b37:	50                   	push   %eax
c0024b38:	68 f8 03 00 00       	push   $0x3f8
c0024b3d:	e8 28 fd ff ff       	call   c002486a <outb>
c0024b42:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c0024b45:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
c0024b49:	66 c1 e8 08          	shr    $0x8,%ax
c0024b4d:	0f b6 c0             	movzbl %al,%eax
c0024b50:	83 ec 08             	sub    $0x8,%esp
c0024b53:	50                   	push   %eax
c0024b54:	68 f9 03 00 00       	push   $0x3f9
c0024b59:	e8 0c fd ff ff       	call   c002486a <outb>
c0024b5e:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c0024b61:	83 ec 08             	sub    $0x8,%esp
c0024b64:	6a 03                	push   $0x3
c0024b66:	68 fb 03 00 00       	push   $0x3fb
c0024b6b:	e8 fa fc ff ff       	call   c002486a <outb>
c0024b70:	83 c4 10             	add    $0x10,%esp
}
c0024b73:	90                   	nop
c0024b74:	c9                   	leave  
c0024b75:	c3                   	ret    

c0024b76 <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c0024b76:	55                   	push   %ebp
c0024b77:	89 e5                	mov    %esp,%ebp
c0024b79:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c0024b7c:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0024b80:	e8 92 c7 ff ff       	call   c0021317 <intr_get_level>
c0024b85:	85 c0                	test   %eax,%eax
c0024b87:	74 21                	je     c0024baa <write_ier+0x34>
c0024b89:	83 ec 0c             	sub    $0xc,%esp
c0024b8c:	68 d5 f7 02 c0       	push   $0xc002f7d5
c0024b91:	68 93 f7 02 c0       	push   $0xc002f793
c0024b96:	68 4c f8 02 c0       	push   $0xc002f84c
c0024b9b:	68 b5 00 00 00       	push   $0xb5
c0024ba0:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024ba5:	e8 7e 49 00 00       	call   c0029528 <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0024baa:	83 ec 0c             	sub    $0xc,%esp
c0024bad:	68 00 89 03 c0       	push   $0xc0038900
c0024bb2:	e8 70 19 00 00       	call   c0026527 <intq_empty>
c0024bb7:	83 c4 10             	add    $0x10,%esp
c0024bba:	83 f0 01             	xor    $0x1,%eax
c0024bbd:	84 c0                	test   %al,%al
c0024bbf:	74 04                	je     c0024bc5 <write_ier+0x4f>
    ier |= IER_XMIT;
c0024bc1:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c0024bc5:	e8 da 18 00 00       	call   c00264a4 <input_full>
c0024bca:	83 f0 01             	xor    $0x1,%eax
c0024bcd:	84 c0                	test   %al,%al
c0024bcf:	74 04                	je     c0024bd5 <write_ier+0x5f>
    ier |= IER_RECV;
c0024bd1:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c0024bd5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0024bd9:	83 ec 08             	sub    $0x8,%esp
c0024bdc:	50                   	push   %eax
c0024bdd:	68 f9 03 00 00       	push   $0x3f9
c0024be2:	e8 83 fc ff ff       	call   c002486a <outb>
c0024be7:	83 c4 10             	add    $0x10,%esp
}
c0024bea:	90                   	nop
c0024beb:	c9                   	leave  
c0024bec:	c3                   	ret    

c0024bed <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0024bed:	55                   	push   %ebp
c0024bee:	89 e5                	mov    %esp,%ebp
c0024bf0:	83 ec 18             	sub    $0x18,%esp
c0024bf3:	8b 45 08             	mov    0x8(%ebp),%eax
c0024bf6:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0024bf9:	e8 19 c7 ff ff       	call   c0021317 <intr_get_level>
c0024bfe:	85 c0                	test   %eax,%eax
c0024c00:	74 22                	je     c0024c24 <putc_poll+0x37>
c0024c02:	83 ec 0c             	sub    $0xc,%esp
c0024c05:	68 d5 f7 02 c0       	push   $0xc002f7d5
c0024c0a:	68 93 f7 02 c0       	push   $0xc002f793
c0024c0f:	68 58 f8 02 c0       	push   $0xc002f858
c0024c14:	68 c9 00 00 00       	push   $0xc9
c0024c19:	68 aa f7 02 c0       	push   $0xc002f7aa
c0024c1e:	e8 05 49 00 00       	call   c0029528 <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c0024c23:	90                   	nop
  while ((inb (LSR_REG) & LSR_THRE) == 0)
c0024c24:	83 ec 0c             	sub    $0xc,%esp
c0024c27:	68 fd 03 00 00       	push   $0x3fd
c0024c2c:	e8 1e fc ff ff       	call   c002484f <inb>
c0024c31:	83 c4 10             	add    $0x10,%esp
c0024c34:	0f b6 c0             	movzbl %al,%eax
c0024c37:	83 e0 20             	and    $0x20,%eax
c0024c3a:	85 c0                	test   %eax,%eax
c0024c3c:	74 e5                	je     c0024c23 <putc_poll+0x36>
  outb (THR_REG, byte);
c0024c3e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0024c42:	83 ec 08             	sub    $0x8,%esp
c0024c45:	50                   	push   %eax
c0024c46:	68 f8 03 00 00       	push   $0x3f8
c0024c4b:	e8 1a fc ff ff       	call   c002486a <outb>
c0024c50:	83 c4 10             	add    $0x10,%esp
}
c0024c53:	90                   	nop
c0024c54:	c9                   	leave  
c0024c55:	c3                   	ret    

c0024c56 <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c0024c56:	55                   	push   %ebp
c0024c57:	89 e5                	mov    %esp,%ebp
c0024c59:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c0024c5c:	68 fa 03 00 00       	push   $0x3fa
c0024c61:	e8 e9 fb ff ff       	call   c002484f <inb>
c0024c66:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024c69:	eb 1c                	jmp    c0024c87 <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c0024c6b:	68 f8 03 00 00       	push   $0x3f8
c0024c70:	e8 da fb ff ff       	call   c002484f <inb>
c0024c75:	83 c4 04             	add    $0x4,%esp
c0024c78:	0f b6 c0             	movzbl %al,%eax
c0024c7b:	83 ec 0c             	sub    $0xc,%esp
c0024c7e:	50                   	push   %eax
c0024c7f:	e8 62 17 00 00       	call   c00263e6 <input_putc>
c0024c84:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c0024c87:	e8 18 18 00 00       	call   c00264a4 <input_full>
c0024c8c:	83 f0 01             	xor    $0x1,%eax
c0024c8f:	84 c0                	test   %al,%al
c0024c91:	74 40                	je     c0024cd3 <serial_interrupt+0x7d>
c0024c93:	83 ec 0c             	sub    $0xc,%esp
c0024c96:	68 fd 03 00 00       	push   $0x3fd
c0024c9b:	e8 af fb ff ff       	call   c002484f <inb>
c0024ca0:	83 c4 10             	add    $0x10,%esp
c0024ca3:	0f b6 c0             	movzbl %al,%eax
c0024ca6:	83 e0 01             	and    $0x1,%eax
c0024ca9:	85 c0                	test   %eax,%eax
c0024cab:	75 be                	jne    c0024c6b <serial_interrupt+0x15>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024cad:	eb 24                	jmp    c0024cd3 <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c0024caf:	83 ec 0c             	sub    $0xc,%esp
c0024cb2:	68 00 89 03 c0       	push   $0xc0038900
c0024cb7:	e8 f9 18 00 00       	call   c00265b5 <intq_getc>
c0024cbc:	83 c4 10             	add    $0x10,%esp
c0024cbf:	0f b6 c0             	movzbl %al,%eax
c0024cc2:	83 ec 08             	sub    $0x8,%esp
c0024cc5:	50                   	push   %eax
c0024cc6:	68 f8 03 00 00       	push   $0x3f8
c0024ccb:	e8 9a fb ff ff       	call   c002486a <outb>
c0024cd0:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0024cd3:	83 ec 0c             	sub    $0xc,%esp
c0024cd6:	68 00 89 03 c0       	push   $0xc0038900
c0024cdb:	e8 47 18 00 00       	call   c0026527 <intq_empty>
c0024ce0:	83 c4 10             	add    $0x10,%esp
c0024ce3:	83 f0 01             	xor    $0x1,%eax
c0024ce6:	84 c0                	test   %al,%al
c0024ce8:	74 1a                	je     c0024d04 <serial_interrupt+0xae>
c0024cea:	83 ec 0c             	sub    $0xc,%esp
c0024ced:	68 fd 03 00 00       	push   $0x3fd
c0024cf2:	e8 58 fb ff ff       	call   c002484f <inb>
c0024cf7:	83 c4 10             	add    $0x10,%esp
c0024cfa:	0f b6 c0             	movzbl %al,%eax
c0024cfd:	83 e0 20             	and    $0x20,%eax
c0024d00:	85 c0                	test   %eax,%eax
c0024d02:	75 ab                	jne    c0024caf <serial_interrupt+0x59>

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c0024d04:	e8 6d fe ff ff       	call   c0024b76 <write_ier>
}
c0024d09:	90                   	nop
c0024d0a:	c9                   	leave  
c0024d0b:	c3                   	ret    

c0024d0c <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c0024d0c:	55                   	push   %ebp
c0024d0d:	89 e5                	mov    %esp,%ebp
c0024d0f:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c0024d12:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c0024d16:	76 1e                	jbe    c0024d36 <block_type_name+0x2a>
c0024d18:	83 ec 0c             	sub    $0xc,%esp
c0024d1b:	68 64 f8 02 c0       	push   $0xc002f864
c0024d20:	68 75 f8 02 c0       	push   $0xc002f875
c0024d25:	68 7c f9 02 c0       	push   $0xc002f97c
c0024d2a:	6a 2f                	push   $0x2f
c0024d2c:	68 8c f8 02 c0       	push   $0xc002f88c
c0024d31:	e8 f2 47 00 00       	call   c0029528 <debug_panic>
  return block_type_names[type];
c0024d36:	8b 45 08             	mov    0x8(%ebp),%eax
c0024d39:	8b 04 85 5c 6c 03 c0 	mov    -0x3ffc93a4(,%eax,4),%eax
}
c0024d40:	c9                   	leave  
c0024d41:	c3                   	ret    

c0024d42 <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c0024d42:	55                   	push   %ebp
c0024d43:	89 e5                	mov    %esp,%ebp
c0024d45:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024d48:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024d4c:	76 1e                	jbe    c0024d6c <block_get_role+0x2a>
c0024d4e:	83 ec 0c             	sub    $0xc,%esp
c0024d51:	68 a2 f8 02 c0       	push   $0xc002f8a2
c0024d56:	68 75 f8 02 c0       	push   $0xc002f875
c0024d5b:	68 b4 f9 02 c0       	push   $0xc002f9b4
c0024d60:	6a 38                	push   $0x38
c0024d62:	68 8c f8 02 c0       	push   $0xc002f88c
c0024d67:	e8 bc 47 00 00       	call   c0029528 <debug_panic>
  return block_by_role[role];
c0024d6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0024d6f:	8b 04 85 68 89 03 c0 	mov    -0x3ffc7698(,%eax,4),%eax
}
c0024d76:	c9                   	leave  
c0024d77:	c3                   	ret    

c0024d78 <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c0024d78:	55                   	push   %ebp
c0024d79:	89 e5                	mov    %esp,%ebp
c0024d7b:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c0024d7e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0024d82:	76 1e                	jbe    c0024da2 <block_set_role+0x2a>
c0024d84:	83 ec 0c             	sub    $0xc,%esp
c0024d87:	68 a2 f8 02 c0       	push   $0xc002f8a2
c0024d8c:	68 75 f8 02 c0       	push   $0xc002f875
c0024d91:	68 c4 f9 02 c0       	push   $0xc002f9c4
c0024d96:	6a 40                	push   $0x40
c0024d98:	68 8c f8 02 c0       	push   $0xc002f88c
c0024d9d:	e8 86 47 00 00       	call   c0029528 <debug_panic>
  block_by_role[role] = block;
c0024da2:	8b 45 08             	mov    0x8(%ebp),%eax
c0024da5:	8b 55 0c             	mov    0xc(%ebp),%edx
c0024da8:	89 14 85 68 89 03 c0 	mov    %edx,-0x3ffc7698(,%eax,4)
}
c0024daf:	90                   	nop
c0024db0:	c9                   	leave  
c0024db1:	c3                   	ret    

c0024db2 <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c0024db2:	55                   	push   %ebp
c0024db3:	89 e5                	mov    %esp,%ebp
c0024db5:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0024db8:	83 ec 0c             	sub    $0xc,%esp
c0024dbb:	68 4c 6c 03 c0       	push   $0xc0036c4c
c0024dc0:	e8 29 4a 00 00       	call   c00297ee <list_begin>
c0024dc5:	83 c4 10             	add    $0x10,%esp
c0024dc8:	83 ec 0c             	sub    $0xc,%esp
c0024dcb:	50                   	push   %eax
c0024dcc:	e8 6a 03 00 00       	call   c002513b <list_elem_to_block>
c0024dd1:	83 c4 10             	add    $0x10,%esp
}
c0024dd4:	c9                   	leave  
c0024dd5:	c3                   	ret    

c0024dd6 <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c0024dd6:	55                   	push   %ebp
c0024dd7:	89 e5                	mov    %esp,%ebp
c0024dd9:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0024ddc:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ddf:	83 ec 0c             	sub    $0xc,%esp
c0024de2:	50                   	push   %eax
c0024de3:	e8 38 4a 00 00       	call   c0029820 <list_next>
c0024de8:	83 c4 10             	add    $0x10,%esp
c0024deb:	83 ec 0c             	sub    $0xc,%esp
c0024dee:	50                   	push   %eax
c0024def:	e8 47 03 00 00       	call   c002513b <list_elem_to_block>
c0024df4:	83 c4 10             	add    $0x10,%esp
}
c0024df7:	c9                   	leave  
c0024df8:	c3                   	ret    

c0024df9 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0024df9:	55                   	push   %ebp
c0024dfa:	89 e5                	mov    %esp,%ebp
c0024dfc:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024dff:	83 ec 0c             	sub    $0xc,%esp
c0024e02:	68 4c 6c 03 c0       	push   $0xc0036c4c
c0024e07:	e8 e2 49 00 00       	call   c00297ee <list_begin>
c0024e0c:	83 c4 10             	add    $0x10,%esp
c0024e0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0024e12:	eb 3b                	jmp    c0024e4f <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c0024e14:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024e17:	83 c0 04             	add    $0x4,%eax
c0024e1a:	83 e8 04             	sub    $0x4,%eax
c0024e1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0024e20:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024e23:	83 c0 08             	add    $0x8,%eax
c0024e26:	83 ec 08             	sub    $0x8,%esp
c0024e29:	50                   	push   %eax
c0024e2a:	ff 75 08             	pushl  0x8(%ebp)
c0024e2d:	e8 33 37 00 00       	call   c0028565 <strcmp>
c0024e32:	83 c4 10             	add    $0x10,%esp
c0024e35:	85 c0                	test   %eax,%eax
c0024e37:	75 05                	jne    c0024e3e <block_get_by_name+0x45>
        return block;
c0024e39:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024e3c:	eb 2b                	jmp    c0024e69 <block_get_by_name+0x70>
       e = list_next (e))
c0024e3e:	83 ec 0c             	sub    $0xc,%esp
c0024e41:	ff 75 f4             	pushl  -0xc(%ebp)
c0024e44:	e8 d7 49 00 00       	call   c0029820 <list_next>
c0024e49:	83 c4 10             	add    $0x10,%esp
c0024e4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0024e4f:	83 ec 0c             	sub    $0xc,%esp
c0024e52:	68 4c 6c 03 c0       	push   $0xc0036c4c
c0024e57:	e8 0e 4a 00 00       	call   c002986a <list_end>
c0024e5c:	83 c4 10             	add    $0x10,%esp
c0024e5f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0024e62:	75 b0                	jne    c0024e14 <block_get_by_name+0x1b>
    }

  return NULL;
c0024e64:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024e69:	c9                   	leave  
c0024e6a:	c3                   	ret    

c0024e6b <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c0024e6b:	55                   	push   %ebp
c0024e6c:	89 e5                	mov    %esp,%ebp
c0024e6e:	53                   	push   %ebx
c0024e6f:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c0024e72:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e75:	8b 40 1c             	mov    0x1c(%eax),%eax
c0024e78:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024e7b:	77 32                	ja     c0024eaf <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c0024e7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e80:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0024e83:	83 ec 0c             	sub    $0xc,%esp
c0024e86:	ff 75 08             	pushl  0x8(%ebp)
c0024e89:	e8 fd 00 00 00       	call   c0024f8b <block_name>
c0024e8e:	83 c4 10             	add    $0x10,%esp
c0024e91:	83 ec 04             	sub    $0x4,%esp
c0024e94:	53                   	push   %ebx
c0024e95:	ff 75 0c             	pushl  0xc(%ebp)
c0024e98:	50                   	push   %eax
c0024e99:	68 b8 f8 02 c0       	push   $0xc002f8b8
c0024e9e:	68 d4 f9 02 c0       	push   $0xc002f9d4
c0024ea3:	6a 70                	push   $0x70
c0024ea5:	68 8c f8 02 c0       	push   $0xc002f88c
c0024eaa:	e8 79 46 00 00       	call   c0029528 <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0024eaf:	90                   	nop
c0024eb0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024eb3:	c9                   	leave  
c0024eb4:	c3                   	ret    

c0024eb5 <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c0024eb5:	55                   	push   %ebp
c0024eb6:	89 e5                	mov    %esp,%ebp
c0024eb8:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0024ebb:	83 ec 08             	sub    $0x8,%esp
c0024ebe:	ff 75 0c             	pushl  0xc(%ebp)
c0024ec1:	ff 75 08             	pushl  0x8(%ebp)
c0024ec4:	e8 a2 ff ff ff       	call   c0024e6b <check_sector>
c0024ec9:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0024ecc:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ecf:	8b 40 20             	mov    0x20(%eax),%eax
c0024ed2:	8b 00                	mov    (%eax),%eax
c0024ed4:	8b 55 08             	mov    0x8(%ebp),%edx
c0024ed7:	8b 52 24             	mov    0x24(%edx),%edx
c0024eda:	83 ec 04             	sub    $0x4,%esp
c0024edd:	ff 75 10             	pushl  0x10(%ebp)
c0024ee0:	ff 75 0c             	pushl  0xc(%ebp)
c0024ee3:	52                   	push   %edx
c0024ee4:	ff d0                	call   *%eax
c0024ee6:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c0024ee9:	8b 45 08             	mov    0x8(%ebp),%eax
c0024eec:	8b 50 2c             	mov    0x2c(%eax),%edx
c0024eef:	8b 40 28             	mov    0x28(%eax),%eax
c0024ef2:	83 c0 01             	add    $0x1,%eax
c0024ef5:	83 d2 00             	adc    $0x0,%edx
c0024ef8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024efb:	89 41 28             	mov    %eax,0x28(%ecx)
c0024efe:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c0024f01:	90                   	nop
c0024f02:	c9                   	leave  
c0024f03:	c3                   	ret    

c0024f04 <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c0024f04:	55                   	push   %ebp
c0024f05:	89 e5                	mov    %esp,%ebp
c0024f07:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0024f0a:	83 ec 08             	sub    $0x8,%esp
c0024f0d:	ff 75 0c             	pushl  0xc(%ebp)
c0024f10:	ff 75 08             	pushl  0x8(%ebp)
c0024f13:	e8 53 ff ff ff       	call   c0024e6b <check_sector>
c0024f18:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c0024f1b:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f1e:	8b 40 18             	mov    0x18(%eax),%eax
c0024f21:	83 f8 05             	cmp    $0x5,%eax
c0024f24:	75 21                	jne    c0024f47 <block_write+0x43>
c0024f26:	83 ec 0c             	sub    $0xc,%esp
c0024f29:	68 eb f8 02 c0       	push   $0xc002f8eb
c0024f2e:	68 75 f8 02 c0       	push   $0xc002f875
c0024f33:	68 e4 f9 02 c0       	push   $0xc002f9e4
c0024f38:	68 89 00 00 00       	push   $0x89
c0024f3d:	68 8c f8 02 c0       	push   $0xc002f88c
c0024f42:	e8 e1 45 00 00       	call   c0029528 <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c0024f47:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f4a:	8b 40 20             	mov    0x20(%eax),%eax
c0024f4d:	8b 40 04             	mov    0x4(%eax),%eax
c0024f50:	8b 55 08             	mov    0x8(%ebp),%edx
c0024f53:	8b 52 24             	mov    0x24(%edx),%edx
c0024f56:	83 ec 04             	sub    $0x4,%esp
c0024f59:	ff 75 10             	pushl  0x10(%ebp)
c0024f5c:	ff 75 0c             	pushl  0xc(%ebp)
c0024f5f:	52                   	push   %edx
c0024f60:	ff d0                	call   *%eax
c0024f62:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c0024f65:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f68:	8b 50 34             	mov    0x34(%eax),%edx
c0024f6b:	8b 40 30             	mov    0x30(%eax),%eax
c0024f6e:	83 c0 01             	add    $0x1,%eax
c0024f71:	83 d2 00             	adc    $0x0,%edx
c0024f74:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024f77:	89 41 30             	mov    %eax,0x30(%ecx)
c0024f7a:	89 51 34             	mov    %edx,0x34(%ecx)
}
c0024f7d:	90                   	nop
c0024f7e:	c9                   	leave  
c0024f7f:	c3                   	ret    

c0024f80 <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c0024f80:	55                   	push   %ebp
c0024f81:	89 e5                	mov    %esp,%ebp
  return block->size;
c0024f83:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f86:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c0024f89:	5d                   	pop    %ebp
c0024f8a:	c3                   	ret    

c0024f8b <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c0024f8b:	55                   	push   %ebp
c0024f8c:	89 e5                	mov    %esp,%ebp
  return block->name;
c0024f8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f91:	83 c0 08             	add    $0x8,%eax
}
c0024f94:	5d                   	pop    %ebp
c0024f95:	c3                   	ret    

c0024f96 <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c0024f96:	55                   	push   %ebp
c0024f97:	89 e5                	mov    %esp,%ebp
  return block->type;
c0024f99:	8b 45 08             	mov    0x8(%ebp),%eax
c0024f9c:	8b 40 18             	mov    0x18(%eax),%eax
}
c0024f9f:	5d                   	pop    %ebp
c0024fa0:	c3                   	ret    

c0024fa1 <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c0024fa1:	55                   	push   %ebp
c0024fa2:	89 e5                	mov    %esp,%ebp
c0024fa4:	56                   	push   %esi
c0024fa5:	53                   	push   %ebx
c0024fa6:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0024fa9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0024fb0:	eb 60                	jmp    c0025012 <block_print_stats+0x71>
    {
      struct block *block = block_by_role[i];
c0024fb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024fb5:	8b 04 85 68 89 03 c0 	mov    -0x3ffc7698(,%eax,4),%eax
c0024fbc:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c0024fbf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0024fc3:	74 4a                	je     c002500f <block_print_stats+0x6e>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c0024fc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024fc8:	8b 50 34             	mov    0x34(%eax),%edx
c0024fcb:	8b 40 30             	mov    0x30(%eax),%eax
c0024fce:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0024fd1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0024fd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024fd7:	8b 58 28             	mov    0x28(%eax),%ebx
c0024fda:	8b 70 2c             	mov    0x2c(%eax),%esi
c0024fdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024fe0:	8b 40 18             	mov    0x18(%eax),%eax
c0024fe3:	83 ec 0c             	sub    $0xc,%esp
c0024fe6:	50                   	push   %eax
c0024fe7:	e8 20 fd ff ff       	call   c0024d0c <block_type_name>
c0024fec:	83 c4 10             	add    $0x10,%esp
                  block->name, block_type_name (block->type),
c0024fef:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0024ff2:	83 c2 08             	add    $0x8,%edx
          printf ("%s (%s): %llu reads, %llu writes\n",
c0024ff5:	83 ec 04             	sub    $0x4,%esp
c0024ff8:	ff 75 e4             	pushl  -0x1c(%ebp)
c0024ffb:	ff 75 e0             	pushl  -0x20(%ebp)
c0024ffe:	56                   	push   %esi
c0024fff:	53                   	push   %ebx
c0025000:	50                   	push   %eax
c0025001:	52                   	push   %edx
c0025002:	68 08 f9 02 c0       	push   $0xc002f908
c0025007:	e8 5d 21 00 00       	call   c0027169 <printf>
c002500c:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c002500f:	ff 45 f4             	incl   -0xc(%ebp)
c0025012:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025016:	7e 9a                	jle    c0024fb2 <block_print_stats+0x11>
                  block->read_cnt, block->write_cnt);
        }
    }
}
c0025018:	90                   	nop
c0025019:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002501c:	5b                   	pop    %ebx
c002501d:	5e                   	pop    %esi
c002501e:	5d                   	pop    %ebp
c002501f:	c3                   	ret    

c0025020 <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c0025020:	55                   	push   %ebp
c0025021:	89 e5                	mov    %esp,%ebp
c0025023:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c0025026:	83 ec 0c             	sub    $0xc,%esp
c0025029:	6a 38                	push   $0x38
c002502b:	e8 2b e4 ff ff       	call   c002345b <malloc>
c0025030:	83 c4 10             	add    $0x10,%esp
c0025033:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c0025036:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002503a:	75 19                	jne    c0025055 <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c002503c:	68 2c f9 02 c0       	push   $0xc002f92c
c0025041:	68 f0 f9 02 c0       	push   $0xc002f9f0
c0025046:	68 c1 00 00 00       	push   $0xc1
c002504b:	68 8c f8 02 c0       	push   $0xc002f88c
c0025050:	e8 d3 44 00 00       	call   c0029528 <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c0025055:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025058:	83 ec 08             	sub    $0x8,%esp
c002505b:	50                   	push   %eax
c002505c:	68 4c 6c 03 c0       	push   $0xc0036c4c
c0025061:	e8 13 4b 00 00       	call   c0029b79 <list_push_back>
c0025066:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c0025069:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002506c:	83 c0 08             	add    $0x8,%eax
c002506f:	83 ec 04             	sub    $0x4,%esp
c0025072:	6a 10                	push   $0x10
c0025074:	ff 75 08             	pushl  0x8(%ebp)
c0025077:	50                   	push   %eax
c0025078:	e8 98 39 00 00       	call   c0028a15 <strlcpy>
c002507d:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c0025080:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025083:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025086:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c0025089:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002508c:	8b 55 14             	mov    0x14(%ebp),%edx
c002508f:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c0025092:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025095:	8b 55 18             	mov    0x18(%ebp),%edx
c0025098:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c002509b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002509e:	8b 55 1c             	mov    0x1c(%ebp),%edx
c00250a1:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c00250a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250a7:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c00250ae:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c00250b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250b8:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c00250bf:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c00250c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250c9:	8b 40 1c             	mov    0x1c(%eax),%eax
c00250cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00250cf:	83 c2 08             	add    $0x8,%edx
c00250d2:	83 ec 04             	sub    $0x4,%esp
c00250d5:	50                   	push   %eax
c00250d6:	52                   	push   %edx
c00250d7:	68 62 f9 02 c0       	push   $0xc002f962
c00250dc:	e8 88 20 00 00       	call   c0027169 <printf>
c00250e1:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c00250e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00250e7:	8b 40 1c             	mov    0x1c(%eax),%eax
c00250ea:	ba 00 00 00 00       	mov    $0x0,%edx
c00250ef:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c00250f3:	c1 e0 09             	shl    $0x9,%eax
c00250f6:	83 ec 08             	sub    $0x8,%esp
c00250f9:	52                   	push   %edx
c00250fa:	50                   	push   %eax
c00250fb:	e8 7f 2d 00 00       	call   c0027e7f <print_human_readable_size>
c0025100:	83 c4 10             	add    $0x10,%esp
  printf (")");
c0025103:	83 ec 0c             	sub    $0xc,%esp
c0025106:	6a 29                	push   $0x29
c0025108:	e8 61 66 00 00       	call   c002b76e <putchar>
c002510d:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c0025110:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025114:	74 13                	je     c0025129 <block_register+0x109>
    printf (", %s", extra_info);
c0025116:	83 ec 08             	sub    $0x8,%esp
c0025119:	ff 75 10             	pushl  0x10(%ebp)
c002511c:	68 74 f9 02 c0       	push   $0xc002f974
c0025121:	e8 43 20 00 00       	call   c0027169 <printf>
c0025126:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025129:	83 ec 0c             	sub    $0xc,%esp
c002512c:	6a 0a                	push   $0xa
c002512e:	e8 3b 66 00 00       	call   c002b76e <putchar>
c0025133:	83 c4 10             	add    $0x10,%esp

  return block;
c0025136:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0025139:	c9                   	leave  
c002513a:	c3                   	ret    

c002513b <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c002513b:	55                   	push   %ebp
c002513c:	89 e5                	mov    %esp,%ebp
c002513e:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c0025141:	83 ec 0c             	sub    $0xc,%esp
c0025144:	68 4c 6c 03 c0       	push   $0xc0036c4c
c0025149:	e8 1c 47 00 00       	call   c002986a <list_end>
c002514e:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c0025151:	3b 45 08             	cmp    0x8(%ebp),%eax
c0025154:	74 0b                	je     c0025161 <list_elem_to_block+0x26>
          ? list_entry (list_elem, struct block, list_elem)
c0025156:	8b 45 08             	mov    0x8(%ebp),%eax
c0025159:	83 c0 04             	add    $0x4,%eax
          : NULL);
c002515c:	83 e8 04             	sub    $0x4,%eax
c002515f:	eb 05                	jmp    c0025166 <list_elem_to_block+0x2b>
c0025161:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025166:	c9                   	leave  
c0025167:	c3                   	ret    

c0025168 <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c0025168:	55                   	push   %ebp
c0025169:	89 e5                	mov    %esp,%ebp
c002516b:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c002516e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c0025175:	8d 45 f4             	lea    -0xc(%ebp),%eax
c0025178:	50                   	push   %eax
c0025179:	6a 00                	push   $0x0
c002517b:	6a 00                	push   $0x0
c002517d:	ff 75 08             	pushl  0x8(%ebp)
c0025180:	e8 2c 00 00 00       	call   c00251b1 <read_partition_table>
c0025185:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c0025188:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002518b:	85 c0                	test   %eax,%eax
c002518d:	75 1f                	jne    c00251ae <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c002518f:	83 ec 0c             	sub    $0xc,%esp
c0025192:	ff 75 08             	pushl  0x8(%ebp)
c0025195:	e8 f1 fd ff ff       	call   c0024f8b <block_name>
c002519a:	83 c4 10             	add    $0x10,%esp
c002519d:	83 ec 08             	sub    $0x8,%esp
c00251a0:	50                   	push   %eax
c00251a1:	68 00 fa 02 c0       	push   $0xc002fa00
c00251a6:	e8 be 1f 00 00       	call   c0027169 <printf>
c00251ab:	83 c4 10             	add    $0x10,%esp
}
c00251ae:	90                   	nop
c00251af:	c9                   	leave  
c00251b0:	c3                   	ret    

c00251b1 <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c00251b1:	55                   	push   %ebp
c00251b2:	89 e5                	mov    %esp,%ebp
c00251b4:	53                   	push   %ebx
c00251b5:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c00251b8:	83 ec 0c             	sub    $0xc,%esp
c00251bb:	ff 75 08             	pushl  0x8(%ebp)
c00251be:	e8 bd fd ff ff       	call   c0024f80 <block_size>
c00251c3:	83 c4 10             	add    $0x10,%esp
c00251c6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00251c9:	77 27                	ja     c00251f2 <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c00251cb:	83 ec 0c             	sub    $0xc,%esp
c00251ce:	ff 75 08             	pushl  0x8(%ebp)
c00251d1:	e8 b5 fd ff ff       	call   c0024f8b <block_name>
c00251d6:	83 c4 10             	add    $0x10,%esp
c00251d9:	83 ec 04             	sub    $0x4,%esp
c00251dc:	ff 75 0c             	pushl  0xc(%ebp)
c00251df:	50                   	push   %eax
c00251e0:	68 24 fa 02 c0       	push   $0xc002fa24
c00251e5:	e8 7f 1f 00 00       	call   c0027169 <printf>
c00251ea:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c00251ed:	e9 d2 01 00 00       	jmp    c00253c4 <read_partition_table+0x213>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c00251f2:	83 ec 0c             	sub    $0xc,%esp
c00251f5:	68 00 02 00 00       	push   $0x200
c00251fa:	e8 5c e2 ff ff       	call   c002345b <malloc>
c00251ff:	83 c4 10             	add    $0x10,%esp
c0025202:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c0025205:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025209:	75 16                	jne    c0025221 <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c002520b:	68 5c fa 02 c0       	push   $0xc002fa5c
c0025210:	68 e4 fb 02 c0       	push   $0xc002fbe4
c0025215:	6a 5a                	push   $0x5a
c0025217:	68 8b fa 02 c0       	push   $0xc002fa8b
c002521c:	e8 07 43 00 00       	call   c0029528 <debug_panic>
  block_read (block, 0, pt);
c0025221:	83 ec 04             	sub    $0x4,%esp
c0025224:	ff 75 f0             	pushl  -0x10(%ebp)
c0025227:	6a 00                	push   $0x0
c0025229:	ff 75 08             	pushl  0x8(%ebp)
c002522c:	e8 84 fc ff ff       	call   c0024eb5 <block_read>
c0025231:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c0025234:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025237:	66 8b 80 fe 01 00 00 	mov    0x1fe(%eax),%ax
c002523e:	66 3d 55 aa          	cmp    $0xaa55,%ax
c0025242:	74 5c                	je     c00252a0 <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c0025244:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0025248:	75 21                	jne    c002526b <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c002524a:	83 ec 0c             	sub    $0xc,%esp
c002524d:	ff 75 08             	pushl  0x8(%ebp)
c0025250:	e8 36 fd ff ff       	call   c0024f8b <block_name>
c0025255:	83 c4 10             	add    $0x10,%esp
c0025258:	83 ec 08             	sub    $0x8,%esp
c002525b:	50                   	push   %eax
c002525c:	68 a8 fa 02 c0       	push   $0xc002faa8
c0025261:	e8 03 1f 00 00       	call   c0027169 <printf>
c0025266:	83 c4 10             	add    $0x10,%esp
c0025269:	eb 22                	jmp    c002528d <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c002526b:	83 ec 0c             	sub    $0xc,%esp
c002526e:	ff 75 08             	pushl  0x8(%ebp)
c0025271:	e8 15 fd ff ff       	call   c0024f8b <block_name>
c0025276:	83 c4 10             	add    $0x10,%esp
c0025279:	83 ec 04             	sub    $0x4,%esp
c002527c:	ff 75 0c             	pushl  0xc(%ebp)
c002527f:	50                   	push   %eax
c0025280:	68 d0 fa 02 c0       	push   $0xc002fad0
c0025285:	e8 df 1e 00 00       	call   c0027169 <printf>
c002528a:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c002528d:	83 ec 0c             	sub    $0xc,%esp
c0025290:	ff 75 f0             	pushl  -0x10(%ebp)
c0025293:	e8 bd e4 ff ff       	call   c0023755 <free>
c0025298:	83 c4 10             	add    $0x10,%esp
      return;
c002529b:	e9 24 01 00 00       	jmp    c00253c4 <read_partition_table+0x213>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00252a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00252a7:	e9 00 01 00 00       	jmp    c00253ac <read_partition_table+0x1fb>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c00252ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00252af:	83 c0 1b             	add    $0x1b,%eax
c00252b2:	c1 e0 04             	shl    $0x4,%eax
c00252b5:	89 c2                	mov    %eax,%edx
c00252b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00252ba:	01 d0                	add    %edx,%eax
c00252bc:	83 c0 0e             	add    $0xe,%eax
c00252bf:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c00252c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252c5:	8b 40 0c             	mov    0xc(%eax),%eax
c00252c8:	85 c0                	test   %eax,%eax
c00252ca:	0f 84 d9 00 00 00    	je     c00253a9 <read_partition_table+0x1f8>
c00252d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252d3:	8a 40 04             	mov    0x4(%eax),%al
c00252d6:	84 c0                	test   %al,%al
c00252d8:	0f 84 cb 00 00 00    	je     c00253a9 <read_partition_table+0x1f8>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c00252de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252e1:	8a 40 04             	mov    0x4(%eax),%al
c00252e4:	3c 05                	cmp    $0x5,%al
c00252e6:	74 1e                	je     c0025306 <read_partition_table+0x155>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c00252e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252eb:	8a 40 04             	mov    0x4(%eax),%al
c00252ee:	3c 0f                	cmp    $0xf,%al
c00252f0:	74 14                	je     c0025306 <read_partition_table+0x155>
               || e->type == 0x85    /* Linux extended partition. */
c00252f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252f5:	8a 40 04             	mov    0x4(%eax),%al
c00252f8:	3c 85                	cmp    $0x85,%al
c00252fa:	74 0a                	je     c0025306 <read_partition_table+0x155>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c00252fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00252ff:	8a 40 04             	mov    0x4(%eax),%al
c0025302:	3c c5                	cmp    $0xc5,%al
c0025304:	75 65                	jne    c002536b <read_partition_table+0x1ba>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0025306:	83 ec 0c             	sub    $0xc,%esp
c0025309:	ff 75 08             	pushl  0x8(%ebp)
c002530c:	e8 7a fc ff ff       	call   c0024f8b <block_name>
c0025311:	83 c4 10             	add    $0x10,%esp
c0025314:	83 ec 04             	sub    $0x4,%esp
c0025317:	ff 75 0c             	pushl  0xc(%ebp)
c002531a:	50                   	push   %eax
c002531b:	68 04 fb 02 c0       	push   $0xc002fb04
c0025320:	e8 44 1e 00 00       	call   c0027169 <printf>
c0025325:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c0025328:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002532c:	75 1e                	jne    c002534c <read_partition_table+0x19b>
            read_partition_table (block, e->offset, e->offset, part_nr);
c002532e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025331:	8b 50 08             	mov    0x8(%eax),%edx
c0025334:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025337:	8b 40 08             	mov    0x8(%eax),%eax
c002533a:	ff 75 14             	pushl  0x14(%ebp)
c002533d:	52                   	push   %edx
c002533e:	50                   	push   %eax
c002533f:	ff 75 08             	pushl  0x8(%ebp)
c0025342:	e8 6a fe ff ff       	call   c00251b1 <read_partition_table>
c0025347:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c002534a:	eb 5d                	jmp    c00253a9 <read_partition_table+0x1f8>
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c002534c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002534f:	8b 50 08             	mov    0x8(%eax),%edx
c0025352:	8b 45 10             	mov    0x10(%ebp),%eax
c0025355:	01 d0                	add    %edx,%eax
c0025357:	ff 75 14             	pushl  0x14(%ebp)
c002535a:	ff 75 10             	pushl  0x10(%ebp)
c002535d:	50                   	push   %eax
c002535e:	ff 75 08             	pushl  0x8(%ebp)
c0025361:	e8 4b fe ff ff       	call   c00251b1 <read_partition_table>
c0025366:	83 c4 10             	add    $0x10,%esp
          if (sector == 0)
c0025369:	eb 3e                	jmp    c00253a9 <read_partition_table+0x1f8>
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c002536b:	8b 45 14             	mov    0x14(%ebp),%eax
c002536e:	8b 00                	mov    (%eax),%eax
c0025370:	8d 50 01             	lea    0x1(%eax),%edx
c0025373:	8b 45 14             	mov    0x14(%ebp),%eax
c0025376:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c0025378:	8b 45 14             	mov    0x14(%ebp),%eax
c002537b:	8b 08                	mov    (%eax),%ecx
c002537d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025380:	8b 50 0c             	mov    0xc(%eax),%edx
c0025383:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025386:	8b 58 08             	mov    0x8(%eax),%ebx
c0025389:	8b 45 0c             	mov    0xc(%ebp),%eax
c002538c:	01 c3                	add    %eax,%ebx
c002538e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025391:	8a 40 04             	mov    0x4(%eax),%al
c0025394:	0f b6 c0             	movzbl %al,%eax
c0025397:	83 ec 0c             	sub    $0xc,%esp
c002539a:	51                   	push   %ecx
c002539b:	52                   	push   %edx
c002539c:	53                   	push   %ebx
c002539d:	50                   	push   %eax
c002539e:	ff 75 08             	pushl  0x8(%ebp)
c00253a1:	e8 23 00 00 00       	call   c00253c9 <found_partition>
c00253a6:	83 c4 20             	add    $0x20,%esp
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00253a9:	ff 45 f4             	incl   -0xc(%ebp)
c00253ac:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c00253b0:	0f 86 f6 fe ff ff    	jbe    c00252ac <read_partition_table+0xfb>
                           e->size, *part_nr);
        }
    }

  free (pt);
c00253b6:	83 ec 0c             	sub    $0xc,%esp
c00253b9:	ff 75 f0             	pushl  -0x10(%ebp)
c00253bc:	e8 94 e3 ff ff       	call   c0023755 <free>
c00253c1:	83 c4 10             	add    $0x10,%esp
}
c00253c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00253c7:	c9                   	leave  
c00253c8:	c3                   	ret    

c00253c9 <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c00253c9:	55                   	push   %ebp
c00253ca:	89 e5                	mov    %esp,%ebp
c00253cc:	56                   	push   %esi
c00253cd:	53                   	push   %ebx
c00253ce:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c00253d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00253d7:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c00253dd:	83 ec 0c             	sub    $0xc,%esp
c00253e0:	ff 75 08             	pushl  0x8(%ebp)
c00253e3:	e8 98 fb ff ff       	call   c0024f80 <block_size>
c00253e8:	83 c4 10             	add    $0x10,%esp
c00253eb:	3b 45 10             	cmp    0x10(%ebp),%eax
c00253ee:	77 27                	ja     c0025417 <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c00253f0:	83 ec 0c             	sub    $0xc,%esp
c00253f3:	ff 75 08             	pushl  0x8(%ebp)
c00253f6:	e8 90 fb ff ff       	call   c0024f8b <block_name>
c00253fb:	83 c4 10             	add    $0x10,%esp
c00253fe:	ff 75 10             	pushl  0x10(%ebp)
c0025401:	ff 75 18             	pushl  0x18(%ebp)
c0025404:	50                   	push   %eax
c0025405:	68 2c fb 02 c0       	push   $0xc002fb2c
c002540a:	e8 5a 1d 00 00       	call   c0027169 <printf>
c002540f:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0025412:	e9 76 01 00 00       	jmp    c002558d <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
c0025417:	8b 55 10             	mov    0x10(%ebp),%edx
c002541a:	8b 45 14             	mov    0x14(%ebp),%eax
c002541d:	01 d0                	add    %edx,%eax
c002541f:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025422:	72 1b                	jb     c002543f <found_partition+0x76>
c0025424:	8b 55 10             	mov    0x10(%ebp),%edx
c0025427:	8b 45 14             	mov    0x14(%ebp),%eax
c002542a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c002542d:	83 ec 0c             	sub    $0xc,%esp
c0025430:	ff 75 08             	pushl  0x8(%ebp)
c0025433:	e8 48 fb ff ff       	call   c0024f80 <block_size>
c0025438:	83 c4 10             	add    $0x10,%esp
c002543b:	39 c3                	cmp    %eax,%ebx
c002543d:	76 42                	jbe    c0025481 <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c002543f:	83 ec 0c             	sub    $0xc,%esp
c0025442:	ff 75 08             	pushl  0x8(%ebp)
c0025445:	e8 36 fb ff ff       	call   c0024f80 <block_size>
c002544a:	83 c4 10             	add    $0x10,%esp
c002544d:	89 c3                	mov    %eax,%ebx
c002544f:	8b 55 10             	mov    0x10(%ebp),%edx
c0025452:	8b 45 14             	mov    0x14(%ebp),%eax
c0025455:	8d 34 02             	lea    (%edx,%eax,1),%esi
c0025458:	83 ec 0c             	sub    $0xc,%esp
c002545b:	ff 75 08             	pushl  0x8(%ebp)
c002545e:	e8 28 fb ff ff       	call   c0024f8b <block_name>
c0025463:	83 c4 10             	add    $0x10,%esp
c0025466:	83 ec 0c             	sub    $0xc,%esp
c0025469:	53                   	push   %ebx
c002546a:	56                   	push   %esi
c002546b:	ff 75 18             	pushl  0x18(%ebp)
c002546e:	50                   	push   %eax
c002546f:	68 64 fb 02 c0       	push   $0xc002fb64
c0025474:	e8 f0 1c 00 00       	call   c0027169 <printf>
c0025479:	83 c4 20             	add    $0x20,%esp
}
c002547c:	e9 0c 01 00 00       	jmp    c002558d <found_partition+0x1c4>
                              : part_type == 0x21 ? BLOCK_FILESYS
c0025481:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c0025488:	74 37                	je     c00254c1 <found_partition+0xf8>
c002548a:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c0025491:	74 27                	je     c00254ba <found_partition+0xf1>
c0025493:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c002549a:	74 17                	je     c00254b3 <found_partition+0xea>
c002549c:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c00254a3:	75 07                	jne    c00254ac <found_partition+0xe3>
c00254a5:	b8 03 00 00 00       	mov    $0x3,%eax
c00254aa:	eb 1a                	jmp    c00254c6 <found_partition+0xfd>
c00254ac:	b8 05 00 00 00       	mov    $0x5,%eax
c00254b1:	eb 13                	jmp    c00254c6 <found_partition+0xfd>
c00254b3:	b8 02 00 00 00       	mov    $0x2,%eax
c00254b8:	eb 0c                	jmp    c00254c6 <found_partition+0xfd>
c00254ba:	b8 01 00 00 00       	mov    $0x1,%eax
c00254bf:	eb 05                	jmp    c00254c6 <found_partition+0xfd>
c00254c1:	b8 00 00 00 00       	mov    $0x0,%eax
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c00254c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
      p = malloc (sizeof *p);
c00254c9:	83 ec 0c             	sub    $0xc,%esp
c00254cc:	6a 08                	push   $0x8
c00254ce:	e8 88 df ff ff       	call   c002345b <malloc>
c00254d3:	83 c4 10             	add    $0x10,%esp
c00254d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c00254d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00254dd:	75 19                	jne    c00254f8 <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c00254df:	68 98 fb 02 c0       	push   $0xc002fb98
c00254e4:	68 fc fb 02 c0       	push   $0xc002fbfc
c00254e9:	68 b1 00 00 00       	push   $0xb1
c00254ee:	68 8b fa 02 c0       	push   $0xc002fa8b
c00254f3:	e8 30 40 00 00       	call   c0029528 <debug_panic>
      p->block = block;
c00254f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00254fb:	8b 55 08             	mov    0x8(%ebp),%edx
c00254fe:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0025500:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025503:	8b 55 10             	mov    0x10(%ebp),%edx
c0025506:	89 50 04             	mov    %edx,0x4(%eax)
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025509:	83 ec 0c             	sub    $0xc,%esp
c002550c:	ff 75 08             	pushl  0x8(%ebp)
c002550f:	e8 77 fa ff ff       	call   c0024f8b <block_name>
c0025514:	83 c4 10             	add    $0x10,%esp
c0025517:	83 ec 0c             	sub    $0xc,%esp
c002551a:	ff 75 18             	pushl  0x18(%ebp)
c002551d:	50                   	push   %eax
c002551e:	68 cb fb 02 c0       	push   $0xc002fbcb
c0025523:	6a 10                	push   $0x10
c0025525:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025528:	50                   	push   %eax
c0025529:	e8 12 1c 00 00       	call   c0027140 <snprintf>
c002552e:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0025531:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c0025538:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c002553f:	83 ec 0c             	sub    $0xc,%esp
c0025542:	50                   	push   %eax
c0025543:	e8 4d 00 00 00       	call   c0025595 <partition_type_name>
c0025548:	83 c4 10             	add    $0x10,%esp
c002554b:	83 ec 0c             	sub    $0xc,%esp
c002554e:	53                   	push   %ebx
c002554f:	50                   	push   %eax
c0025550:	68 d0 fb 02 c0       	push   $0xc002fbd0
c0025555:	68 80 00 00 00       	push   $0x80
c002555a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025560:	50                   	push   %eax
c0025561:	e8 da 1b 00 00       	call   c0027140 <snprintf>
c0025566:	83 c4 20             	add    $0x20,%esp
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025569:	83 ec 08             	sub    $0x8,%esp
c002556c:	ff 75 f0             	pushl  -0x10(%ebp)
c002556f:	68 80 6c 03 c0       	push   $0xc0036c80
c0025574:	ff 75 14             	pushl  0x14(%ebp)
c0025577:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c002557d:	50                   	push   %eax
c002557e:	ff 75 f4             	pushl  -0xc(%ebp)
c0025581:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025584:	50                   	push   %eax
c0025585:	e8 96 fa ff ff       	call   c0025020 <block_register>
c002558a:	83 c4 20             	add    $0x20,%esp
}
c002558d:	90                   	nop
c002558e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025591:	5b                   	pop    %ebx
c0025592:	5e                   	pop    %esi
c0025593:	5d                   	pop    %ebp
c0025594:	c3                   	ret    

c0025595 <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c0025595:	55                   	push   %ebp
c0025596:	89 e5                	mov    %esp,%ebp
c0025598:	83 ec 04             	sub    $0x4,%esp
c002559b:	8b 45 08             	mov    0x8(%ebp),%eax
c002559e:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c00255a1:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00255a5:	8b 04 85 a0 6c 03 c0 	mov    -0x3ffc9360(,%eax,4),%eax
c00255ac:	85 c0                	test   %eax,%eax
c00255ae:	74 0d                	je     c00255bd <partition_type_name+0x28>
c00255b0:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00255b4:	8b 04 85 a0 6c 03 c0 	mov    -0x3ffc9360(,%eax,4),%eax
c00255bb:	eb 05                	jmp    c00255c2 <partition_type_name+0x2d>
c00255bd:	b8 da fb 02 c0       	mov    $0xc002fbda,%eax
}
c00255c2:	c9                   	leave  
c00255c3:	c3                   	ret    

c00255c4 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c00255c4:	55                   	push   %ebp
c00255c5:	89 e5                	mov    %esp,%ebp
c00255c7:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c00255ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00255cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c00255d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00255d3:	8b 50 04             	mov    0x4(%eax),%edx
c00255d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00255d9:	01 c2                	add    %eax,%edx
c00255db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00255de:	8b 00                	mov    (%eax),%eax
c00255e0:	83 ec 04             	sub    $0x4,%esp
c00255e3:	ff 75 10             	pushl  0x10(%ebp)
c00255e6:	52                   	push   %edx
c00255e7:	50                   	push   %eax
c00255e8:	e8 c8 f8 ff ff       	call   c0024eb5 <block_read>
c00255ed:	83 c4 10             	add    $0x10,%esp
}
c00255f0:	90                   	nop
c00255f1:	c9                   	leave  
c00255f2:	c3                   	ret    

c00255f3 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c00255f3:	55                   	push   %ebp
c00255f4:	89 e5                	mov    %esp,%ebp
c00255f6:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c00255f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00255fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c00255ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025602:	8b 50 04             	mov    0x4(%eax),%edx
c0025605:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025608:	01 c2                	add    %eax,%edx
c002560a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002560d:	8b 00                	mov    (%eax),%eax
c002560f:	83 ec 04             	sub    $0x4,%esp
c0025612:	ff 75 10             	pushl  0x10(%ebp)
c0025615:	52                   	push   %edx
c0025616:	50                   	push   %eax
c0025617:	e8 e8 f8 ff ff       	call   c0024f04 <block_write>
c002561c:	83 c4 10             	add    $0x10,%esp
}
c002561f:	90                   	nop
c0025620:	c9                   	leave  
c0025621:	c3                   	ret    

c0025622 <isspace>:
static inline int isspace (int c) {
c0025622:	55                   	push   %ebp
c0025623:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c0025625:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0025629:	74 1e                	je     c0025649 <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c002562b:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c002562f:	74 18                	je     c0025649 <isspace+0x27>
c0025631:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0025635:	74 12                	je     c0025649 <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0025637:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c002563b:	74 0c                	je     c0025649 <isspace+0x27>
c002563d:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0025641:	74 06                	je     c0025649 <isspace+0x27>
c0025643:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0025647:	75 07                	jne    c0025650 <isspace+0x2e>
c0025649:	b8 01 00 00 00       	mov    $0x1,%eax
c002564e:	eb 05                	jmp    c0025655 <isspace+0x33>
c0025650:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025655:	5d                   	pop    %ebp
c0025656:	c3                   	ret    

c0025657 <inb>:
{
c0025657:	55                   	push   %ebp
c0025658:	89 e5                	mov    %esp,%ebp
c002565a:	83 ec 14             	sub    $0x14,%esp
c002565d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025660:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025664:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025667:	89 c2                	mov    %eax,%edx
c0025669:	ec                   	in     (%dx),%al
c002566a:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002566d:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0025670:	c9                   	leave  
c0025671:	c3                   	ret    

c0025672 <insw>:
{
c0025672:	55                   	push   %ebp
c0025673:	89 e5                	mov    %esp,%ebp
c0025675:	57                   	push   %edi
c0025676:	53                   	push   %ebx
c0025677:	83 ec 04             	sub    $0x4,%esp
c002567a:	8b 45 08             	mov    0x8(%ebp),%eax
c002567d:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025681:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025684:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025687:	8b 45 10             	mov    0x10(%ebp),%eax
c002568a:	89 cb                	mov    %ecx,%ebx
c002568c:	89 df                	mov    %ebx,%edi
c002568e:	89 c1                	mov    %eax,%ecx
c0025690:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c0025693:	89 c8                	mov    %ecx,%eax
c0025695:	89 fb                	mov    %edi,%ebx
c0025697:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c002569a:	89 45 10             	mov    %eax,0x10(%ebp)
}
c002569d:	90                   	nop
c002569e:	83 c4 04             	add    $0x4,%esp
c00256a1:	5b                   	pop    %ebx
c00256a2:	5f                   	pop    %edi
c00256a3:	5d                   	pop    %ebp
c00256a4:	c3                   	ret    

c00256a5 <outb>:
{
c00256a5:	55                   	push   %ebp
c00256a6:	89 e5                	mov    %esp,%ebp
c00256a8:	83 ec 08             	sub    $0x8,%esp
c00256ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00256ae:	8b 55 0c             	mov    0xc(%ebp),%edx
c00256b1:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c00256b5:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00256b8:	8a 45 f8             	mov    -0x8(%ebp),%al
c00256bb:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00256be:	ee                   	out    %al,(%dx)
}
c00256bf:	90                   	nop
c00256c0:	c9                   	leave  
c00256c1:	c3                   	ret    

c00256c2 <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c00256c2:	55                   	push   %ebp
c00256c3:	89 e5                	mov    %esp,%ebp
c00256c5:	56                   	push   %esi
c00256c6:	53                   	push   %ebx
c00256c7:	83 ec 04             	sub    $0x4,%esp
c00256ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00256cd:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c00256d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00256d4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00256d7:	8b 45 10             	mov    0x10(%ebp),%eax
c00256da:	89 cb                	mov    %ecx,%ebx
c00256dc:	89 de                	mov    %ebx,%esi
c00256de:	89 c1                	mov    %eax,%ecx
c00256e0:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c00256e3:	89 c8                	mov    %ecx,%eax
c00256e5:	89 f3                	mov    %esi,%ebx
c00256e7:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00256ea:	89 45 10             	mov    %eax,0x10(%ebp)
}
c00256ed:	90                   	nop
c00256ee:	83 c4 04             	add    $0x4,%esp
c00256f1:	5b                   	pop    %ebx
c00256f2:	5e                   	pop    %esi
c00256f3:	5d                   	pop    %ebp
c00256f4:	c3                   	ret    

c00256f5 <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c00256f5:	55                   	push   %ebp
c00256f6:	89 e5                	mov    %esp,%ebp
c00256f8:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c00256fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025702:	e9 ba 01 00 00       	jmp    c00258c1 <ide_init+0x1cc>
    {
      struct channel *c = &channels[chan_no];
c0025707:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002570a:	89 d0                	mov    %edx,%eax
c002570c:	c1 e0 02             	shl    $0x2,%eax
c002570f:	01 d0                	add    %edx,%eax
c0025711:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0025718:	01 d0                	add    %edx,%eax
c002571a:	c1 e0 02             	shl    $0x2,%eax
c002571d:	05 80 89 03 c0       	add    $0xc0038980,%eax
c0025722:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025725:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025728:	ff 75 f4             	pushl  -0xc(%ebp)
c002572b:	68 d0 00 03 c0       	push   $0xc00300d0
c0025730:	6a 08                	push   $0x8
c0025732:	50                   	push   %eax
c0025733:	e8 08 1a 00 00       	call   c0027140 <snprintf>
c0025738:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c002573b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002573e:	85 c0                	test   %eax,%eax
c0025740:	74 07                	je     c0025749 <ide_init+0x54>
c0025742:	83 f8 01             	cmp    $0x1,%eax
c0025745:	74 14                	je     c002575b <ide_init+0x66>
c0025747:	eb 24                	jmp    c002576d <ide_init+0x78>
        {
        case 0:
          c->reg_base = 0x1f0;
c0025749:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002574c:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c0025752:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025755:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c0025759:	eb 28                	jmp    c0025783 <ide_init+0x8e>
        case 1:
          c->reg_base = 0x170;
c002575b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002575e:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c0025764:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025767:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c002576b:	eb 16                	jmp    c0025783 <ide_init+0x8e>
        default:
          NOT_REACHED ();
c002576d:	68 d8 00 03 c0       	push   $0xc00300d8
c0025772:	68 2c 02 03 c0       	push   $0xc003022c
c0025777:	6a 7c                	push   $0x7c
c0025779:	68 fa 00 03 c0       	push   $0xc00300fa
c002577e:	e8 a5 3d 00 00       	call   c0029528 <debug_panic>
        }
      lock_init (&c->lock);
c0025783:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025786:	83 c0 0c             	add    $0xc,%eax
c0025789:	83 ec 0c             	sub    $0xc,%esp
c002578c:	50                   	push   %eax
c002578d:	e8 b1 d2 ff ff       	call   c0022a43 <lock_init>
c0025792:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c0025795:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025798:	c6 40 24 00          	movb   $0x0,0x24(%eax)
      sema_init (&c->completion_wait, 0);
c002579c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002579f:	83 c0 28             	add    $0x28,%eax
c00257a2:	83 ec 08             	sub    $0x8,%esp
c00257a5:	6a 00                	push   $0x0
c00257a7:	50                   	push   %eax
c00257a8:	e8 de cf ff ff       	call   c002278b <sema_init>
c00257ad:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c00257b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00257b7:	eb 5a                	jmp    c0025813 <ide_init+0x11e>
        {
          struct ata_disk *d = &c->devices[dev_no];
c00257b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00257bc:	89 d0                	mov    %edx,%eax
c00257be:	c1 e0 02             	shl    $0x2,%eax
c00257c1:	01 d0                	add    %edx,%eax
c00257c3:	c1 e0 02             	shl    $0x2,%eax
c00257c6:	8d 50 30             	lea    0x30(%eax),%edx
c00257c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00257cc:	01 d0                	add    %edx,%eax
c00257ce:	83 c0 0c             	add    $0xc,%eax
c00257d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c00257d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00257d7:	01 c0                	add    %eax,%eax
c00257d9:	89 c2                	mov    %eax,%edx
c00257db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00257de:	01 d0                	add    %edx,%eax
          snprintf (d->name, sizeof d->name,
c00257e0:	8d 50 61             	lea    0x61(%eax),%edx
c00257e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00257e6:	52                   	push   %edx
c00257e7:	68 0e 01 03 c0       	push   $0xc003010e
c00257ec:	6a 08                	push   $0x8
c00257ee:	50                   	push   %eax
c00257ef:	e8 4c 19 00 00       	call   c0027140 <snprintf>
c00257f4:	83 c4 10             	add    $0x10,%esp
          d->channel = c;
c00257f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00257fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00257fd:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c0025800:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025803:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025806:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c0025809:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002580c:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025810:	ff 45 f0             	incl   -0x10(%ebp)
c0025813:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025817:	7e a0                	jle    c00257b9 <ide_init+0xc4>
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025819:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002581c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002581f:	8a 40 0a             	mov    0xa(%eax),%al
c0025822:	0f b6 c0             	movzbl %al,%eax
c0025825:	83 ec 04             	sub    $0x4,%esp
c0025828:	52                   	push   %edx
c0025829:	68 39 63 02 c0       	push   $0xc0026339
c002582e:	50                   	push   %eax
c002582f:	e8 77 bd ff ff       	call   c00215ab <intr_register_ext>
c0025834:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c0025837:	83 ec 0c             	sub    $0xc,%esp
c002583a:	ff 75 ec             	pushl  -0x14(%ebp)
c002583d:	e8 8c 00 00 00       	call   c00258ce <reset_channel>
c0025842:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c0025845:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025848:	83 c0 3c             	add    $0x3c,%eax
c002584b:	83 ec 0c             	sub    $0xc,%esp
c002584e:	50                   	push   %eax
c002584f:	e8 f8 02 00 00       	call   c0025b4c <check_device_type>
c0025854:	83 c4 10             	add    $0x10,%esp
c0025857:	84 c0                	test   %al,%al
c0025859:	74 12                	je     c002586d <ide_init+0x178>
        check_device_type (&c->devices[1]);
c002585b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002585e:	83 c0 50             	add    $0x50,%eax
c0025861:	83 ec 0c             	sub    $0xc,%esp
c0025864:	50                   	push   %eax
c0025865:	e8 e2 02 00 00       	call   c0025b4c <check_device_type>
c002586a:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c002586d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025874:	eb 42                	jmp    c00258b8 <ide_init+0x1c3>
        if (c->devices[dev_no].is_ata)
c0025876:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0025879:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002587c:	89 d0                	mov    %edx,%eax
c002587e:	c1 e0 02             	shl    $0x2,%eax
c0025881:	01 d0                	add    %edx,%eax
c0025883:	c1 e0 02             	shl    $0x2,%eax
c0025886:	01 c8                	add    %ecx,%eax
c0025888:	83 c0 4c             	add    $0x4c,%eax
c002588b:	8a 00                	mov    (%eax),%al
c002588d:	84 c0                	test   %al,%al
c002588f:	74 24                	je     c00258b5 <ide_init+0x1c0>
          identify_ata_device (&c->devices[dev_no]);
c0025891:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025894:	89 d0                	mov    %edx,%eax
c0025896:	c1 e0 02             	shl    $0x2,%eax
c0025899:	01 d0                	add    %edx,%eax
c002589b:	c1 e0 02             	shl    $0x2,%eax
c002589e:	8d 50 30             	lea    0x30(%eax),%edx
c00258a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00258a4:	01 d0                	add    %edx,%eax
c00258a6:	83 c0 0c             	add    $0xc,%eax
c00258a9:	83 ec 0c             	sub    $0xc,%esp
c00258ac:	50                   	push   %eax
c00258ad:	e8 8b 03 00 00       	call   c0025c3d <identify_ata_device>
c00258b2:	83 c4 10             	add    $0x10,%esp
      for (dev_no = 0; dev_no < 2; dev_no++)
c00258b5:	ff 45 f0             	incl   -0x10(%ebp)
c00258b8:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c00258bc:	7e b8                	jle    c0025876 <ide_init+0x181>
  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c00258be:	ff 45 f4             	incl   -0xc(%ebp)
c00258c1:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00258c5:	0f 86 3c fe ff ff    	jbe    c0025707 <ide_init+0x12>
    }
}
c00258cb:	90                   	nop
c00258cc:	c9                   	leave  
c00258cd:	c3                   	ret    

c00258ce <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c00258ce:	55                   	push   %ebp
c00258cf:	89 e5                	mov    %esp,%ebp
c00258d1:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c00258d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00258db:	e9 22 01 00 00       	jmp    c0025a02 <reset_channel+0x134>
    {
      struct ata_disk *d = &c->devices[dev_no];
c00258e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00258e3:	89 d0                	mov    %edx,%eax
c00258e5:	c1 e0 02             	shl    $0x2,%eax
c00258e8:	01 d0                	add    %edx,%eax
c00258ea:	c1 e0 02             	shl    $0x2,%eax
c00258ed:	8d 50 30             	lea    0x30(%eax),%edx
c00258f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00258f3:	01 d0                	add    %edx,%eax
c00258f5:	83 c0 0c             	add    $0xc,%eax
c00258f8:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c00258fb:	83 ec 0c             	sub    $0xc,%esp
c00258fe:	ff 75 ec             	pushl  -0x14(%ebp)
c0025901:	e8 98 09 00 00       	call   c002629e <select_device>
c0025906:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025909:	8b 45 08             	mov    0x8(%ebp),%eax
c002590c:	8b 40 08             	mov    0x8(%eax),%eax
c002590f:	83 c0 02             	add    $0x2,%eax
c0025912:	0f b7 c0             	movzwl %ax,%eax
c0025915:	83 ec 08             	sub    $0x8,%esp
c0025918:	6a 55                	push   $0x55
c002591a:	50                   	push   %eax
c002591b:	e8 85 fd ff ff       	call   c00256a5 <outb>
c0025920:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025923:	8b 45 08             	mov    0x8(%ebp),%eax
c0025926:	8b 40 08             	mov    0x8(%eax),%eax
c0025929:	83 c0 03             	add    $0x3,%eax
c002592c:	0f b7 c0             	movzwl %ax,%eax
c002592f:	83 ec 08             	sub    $0x8,%esp
c0025932:	68 aa 00 00 00       	push   $0xaa
c0025937:	50                   	push   %eax
c0025938:	e8 68 fd ff ff       	call   c00256a5 <outb>
c002593d:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c0025940:	8b 45 08             	mov    0x8(%ebp),%eax
c0025943:	8b 40 08             	mov    0x8(%eax),%eax
c0025946:	83 c0 02             	add    $0x2,%eax
c0025949:	0f b7 c0             	movzwl %ax,%eax
c002594c:	83 ec 08             	sub    $0x8,%esp
c002594f:	68 aa 00 00 00       	push   $0xaa
c0025954:	50                   	push   %eax
c0025955:	e8 4b fd ff ff       	call   c00256a5 <outb>
c002595a:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c002595d:	8b 45 08             	mov    0x8(%ebp),%eax
c0025960:	8b 40 08             	mov    0x8(%eax),%eax
c0025963:	83 c0 03             	add    $0x3,%eax
c0025966:	0f b7 c0             	movzwl %ax,%eax
c0025969:	83 ec 08             	sub    $0x8,%esp
c002596c:	6a 55                	push   $0x55
c002596e:	50                   	push   %eax
c002596f:	e8 31 fd ff ff       	call   c00256a5 <outb>
c0025974:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025977:	8b 45 08             	mov    0x8(%ebp),%eax
c002597a:	8b 40 08             	mov    0x8(%eax),%eax
c002597d:	83 c0 02             	add    $0x2,%eax
c0025980:	0f b7 c0             	movzwl %ax,%eax
c0025983:	83 ec 08             	sub    $0x8,%esp
c0025986:	6a 55                	push   $0x55
c0025988:	50                   	push   %eax
c0025989:	e8 17 fd ff ff       	call   c00256a5 <outb>
c002598e:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025991:	8b 45 08             	mov    0x8(%ebp),%eax
c0025994:	8b 40 08             	mov    0x8(%eax),%eax
c0025997:	83 c0 03             	add    $0x3,%eax
c002599a:	0f b7 c0             	movzwl %ax,%eax
c002599d:	83 ec 08             	sub    $0x8,%esp
c00259a0:	68 aa 00 00 00       	push   $0xaa
c00259a5:	50                   	push   %eax
c00259a6:	e8 fa fc ff ff       	call   c00256a5 <outb>
c00259ab:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00259ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00259b1:	8b 40 08             	mov    0x8(%eax),%eax
c00259b4:	83 c0 02             	add    $0x2,%eax
c00259b7:	0f b7 c0             	movzwl %ax,%eax
c00259ba:	83 ec 0c             	sub    $0xc,%esp
c00259bd:	50                   	push   %eax
c00259be:	e8 94 fc ff ff       	call   c0025657 <inb>
c00259c3:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c00259c6:	3c 55                	cmp    $0x55,%al
c00259c8:	75 23                	jne    c00259ed <reset_channel+0x11f>
c00259ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00259cd:	8b 40 08             	mov    0x8(%eax),%eax
c00259d0:	83 c0 03             	add    $0x3,%eax
c00259d3:	0f b7 c0             	movzwl %ax,%eax
c00259d6:	83 ec 0c             	sub    $0xc,%esp
c00259d9:	50                   	push   %eax
c00259da:	e8 78 fc ff ff       	call   c0025657 <inb>
c00259df:	83 c4 10             	add    $0x10,%esp
c00259e2:	3c aa                	cmp    $0xaa,%al
c00259e4:	75 07                	jne    c00259ed <reset_channel+0x11f>
c00259e6:	b8 01 00 00 00       	mov    $0x1,%eax
c00259eb:	eb 05                	jmp    c00259f2 <reset_channel+0x124>
c00259ed:	b8 00 00 00 00       	mov    $0x0,%eax
c00259f2:	83 e0 01             	and    $0x1,%eax
      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c00259f5:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c00259f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00259fb:	01 ca                	add    %ecx,%edx
c00259fd:	88 02                	mov    %al,(%edx)
  for (dev_no = 0; dev_no < 2; dev_no++)
c00259ff:	ff 45 f4             	incl   -0xc(%ebp)
c0025a02:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025a06:	0f 8e d4 fe ff ff    	jle    c00258e0 <reset_channel+0x12>
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c0025a0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a0f:	8b 40 08             	mov    0x8(%eax),%eax
c0025a12:	05 06 02 00 00       	add    $0x206,%eax
c0025a17:	0f b7 c0             	movzwl %ax,%eax
c0025a1a:	83 ec 08             	sub    $0x8,%esp
c0025a1d:	6a 00                	push   $0x0
c0025a1f:	50                   	push   %eax
c0025a20:	e8 80 fc ff ff       	call   c00256a5 <outb>
c0025a25:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025a28:	83 ec 08             	sub    $0x8,%esp
c0025a2b:	6a 00                	push   $0x0
c0025a2d:	6a 0a                	push   $0xa
c0025a2f:	e8 56 e3 ff ff       	call   c0023d8a <timer_usleep>
c0025a34:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c0025a37:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a3a:	8b 40 08             	mov    0x8(%eax),%eax
c0025a3d:	05 06 02 00 00       	add    $0x206,%eax
c0025a42:	0f b7 c0             	movzwl %ax,%eax
c0025a45:	83 ec 08             	sub    $0x8,%esp
c0025a48:	6a 04                	push   $0x4
c0025a4a:	50                   	push   %eax
c0025a4b:	e8 55 fc ff ff       	call   c00256a5 <outb>
c0025a50:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c0025a53:	83 ec 08             	sub    $0x8,%esp
c0025a56:	6a 00                	push   $0x0
c0025a58:	6a 0a                	push   $0xa
c0025a5a:	e8 2b e3 ff ff       	call   c0023d8a <timer_usleep>
c0025a5f:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c0025a62:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a65:	8b 40 08             	mov    0x8(%eax),%eax
c0025a68:	05 06 02 00 00       	add    $0x206,%eax
c0025a6d:	0f b7 c0             	movzwl %ax,%eax
c0025a70:	83 ec 08             	sub    $0x8,%esp
c0025a73:	6a 00                	push   $0x0
c0025a75:	50                   	push   %eax
c0025a76:	e8 2a fc ff ff       	call   c00256a5 <outb>
c0025a7b:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c0025a7e:	83 ec 08             	sub    $0x8,%esp
c0025a81:	6a 00                	push   $0x0
c0025a83:	68 96 00 00 00       	push   $0x96
c0025a88:	e8 d2 e2 ff ff       	call   c0023d5f <timer_msleep>
c0025a8d:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c0025a90:	8a 45 ea             	mov    -0x16(%ebp),%al
c0025a93:	84 c0                	test   %al,%al
c0025a95:	74 24                	je     c0025abb <reset_channel+0x1ed>
    {
      select_device (&c->devices[0]);
c0025a97:	8b 45 08             	mov    0x8(%ebp),%eax
c0025a9a:	83 c0 3c             	add    $0x3c,%eax
c0025a9d:	83 ec 0c             	sub    $0xc,%esp
c0025aa0:	50                   	push   %eax
c0025aa1:	e8 f8 07 00 00       	call   c002629e <select_device>
c0025aa6:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c0025aa9:	8b 45 08             	mov    0x8(%ebp),%eax
c0025aac:	83 c0 3c             	add    $0x3c,%eax
c0025aaf:	83 ec 0c             	sub    $0xc,%esp
c0025ab2:	50                   	push   %eax
c0025ab3:	e8 1d 07 00 00       	call   c00261d5 <wait_while_busy>
c0025ab8:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0025abb:	8a 45 eb             	mov    -0x15(%ebp),%al
c0025abe:	84 c0                	test   %al,%al
c0025ac0:	0f 84 83 00 00 00    	je     c0025b49 <reset_channel+0x27b>
    {
      int i;

      select_device (&c->devices[1]);
c0025ac6:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ac9:	83 c0 50             	add    $0x50,%eax
c0025acc:	83 ec 0c             	sub    $0xc,%esp
c0025acf:	50                   	push   %eax
c0025ad0:	e8 c9 07 00 00       	call   c002629e <select_device>
c0025ad5:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025ad8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025adf:	eb 4a                	jmp    c0025b2b <reset_channel+0x25d>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0025ae1:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ae4:	8b 40 08             	mov    0x8(%eax),%eax
c0025ae7:	83 c0 02             	add    $0x2,%eax
c0025aea:	0f b7 c0             	movzwl %ax,%eax
c0025aed:	83 ec 0c             	sub    $0xc,%esp
c0025af0:	50                   	push   %eax
c0025af1:	e8 61 fb ff ff       	call   c0025657 <inb>
c0025af6:	83 c4 10             	add    $0x10,%esp
c0025af9:	3c 01                	cmp    $0x1,%al
c0025afb:	75 1c                	jne    c0025b19 <reset_channel+0x24b>
c0025afd:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b00:	8b 40 08             	mov    0x8(%eax),%eax
c0025b03:	83 c0 03             	add    $0x3,%eax
c0025b06:	0f b7 c0             	movzwl %ax,%eax
c0025b09:	83 ec 0c             	sub    $0xc,%esp
c0025b0c:	50                   	push   %eax
c0025b0d:	e8 45 fb ff ff       	call   c0025657 <inb>
c0025b12:	83 c4 10             	add    $0x10,%esp
c0025b15:	3c 01                	cmp    $0x1,%al
c0025b17:	74 1d                	je     c0025b36 <reset_channel+0x268>
            break;
          timer_msleep (10);
c0025b19:	83 ec 08             	sub    $0x8,%esp
c0025b1c:	6a 00                	push   $0x0
c0025b1e:	6a 0a                	push   $0xa
c0025b20:	e8 3a e2 ff ff       	call   c0023d5f <timer_msleep>
c0025b25:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c0025b28:	ff 45 f0             	incl   -0x10(%ebp)
c0025b2b:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c0025b32:	7e ad                	jle    c0025ae1 <reset_channel+0x213>
c0025b34:	eb 01                	jmp    c0025b37 <reset_channel+0x269>
            break;
c0025b36:	90                   	nop
        }
      wait_while_busy (&c->devices[1]);
c0025b37:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b3a:	83 c0 50             	add    $0x50,%eax
c0025b3d:	83 ec 0c             	sub    $0xc,%esp
c0025b40:	50                   	push   %eax
c0025b41:	e8 8f 06 00 00       	call   c00261d5 <wait_while_busy>
c0025b46:	83 c4 10             	add    $0x10,%esp
    }
}
c0025b49:	90                   	nop
c0025b4a:	c9                   	leave  
c0025b4b:	c3                   	ret    

c0025b4c <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c0025b4c:	55                   	push   %ebp
c0025b4d:	89 e5                	mov    %esp,%ebp
c0025b4f:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0025b52:	8b 45 08             	mov    0x8(%ebp),%eax
c0025b55:	8b 40 08             	mov    0x8(%eax),%eax
c0025b58:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c0025b5b:	83 ec 0c             	sub    $0xc,%esp
c0025b5e:	ff 75 08             	pushl  0x8(%ebp)
c0025b61:	e8 38 07 00 00       	call   c002629e <select_device>
c0025b66:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c0025b69:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025b6c:	8b 40 08             	mov    0x8(%eax),%eax
c0025b6f:	40                   	inc    %eax
c0025b70:	0f b7 c0             	movzwl %ax,%eax
c0025b73:	83 ec 0c             	sub    $0xc,%esp
c0025b76:	50                   	push   %eax
c0025b77:	e8 db fa ff ff       	call   c0025657 <inb>
c0025b7c:	83 c4 10             	add    $0x10,%esp
c0025b7f:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c0025b82:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025b85:	8b 40 08             	mov    0x8(%eax),%eax
c0025b88:	83 c0 04             	add    $0x4,%eax
c0025b8b:	0f b7 c0             	movzwl %ax,%eax
c0025b8e:	83 ec 0c             	sub    $0xc,%esp
c0025b91:	50                   	push   %eax
c0025b92:	e8 c0 fa ff ff       	call   c0025657 <inb>
c0025b97:	83 c4 10             	add    $0x10,%esp
c0025b9a:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c0025b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ba0:	8b 40 08             	mov    0x8(%eax),%eax
c0025ba3:	83 c0 05             	add    $0x5,%eax
c0025ba6:	0f b7 c0             	movzwl %ax,%eax
c0025ba9:	83 ec 0c             	sub    $0xc,%esp
c0025bac:	50                   	push   %eax
c0025bad:	e8 a5 fa ff ff       	call   c0025657 <inb>
c0025bb2:	83 c4 10             	add    $0x10,%esp
c0025bb5:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c0025bb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025bbb:	8b 40 08             	mov    0x8(%eax),%eax
c0025bbe:	83 c0 07             	add    $0x7,%eax
c0025bc1:	0f b7 c0             	movzwl %ax,%eax
c0025bc4:	83 ec 0c             	sub    $0xc,%esp
c0025bc7:	50                   	push   %eax
c0025bc8:	e8 8a fa ff ff       	call   c0025657 <inb>
c0025bcd:	83 c4 10             	add    $0x10,%esp
c0025bd0:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0025bd3:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c0025bd7:	74 11                	je     c0025bea <check_device_type+0x9e>
c0025bd9:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025bdd:	75 1d                	jne    c0025bfc <check_device_type+0xb0>
c0025bdf:	8b 45 08             	mov    0x8(%ebp),%eax
c0025be2:	8b 40 0c             	mov    0xc(%eax),%eax
c0025be5:	83 f8 01             	cmp    $0x1,%eax
c0025be8:	74 12                	je     c0025bfc <check_device_type+0xb0>
      || (status & STA_DRDY) == 0
c0025bea:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0025bee:	83 e0 40             	and    $0x40,%eax
c0025bf1:	85 c0                	test   %eax,%eax
c0025bf3:	74 07                	je     c0025bfc <check_device_type+0xb0>
      || (status & STA_BSY) != 0)
c0025bf5:	8a 45 f0             	mov    -0x10(%ebp),%al
c0025bf8:	84 c0                	test   %al,%al
c0025bfa:	79 10                	jns    c0025c0c <check_device_type+0xc0>
    {
      d->is_ata = false;
c0025bfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0025bff:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c0025c03:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0025c07:	0f 95 c0             	setne  %al
c0025c0a:	eb 2f                	jmp    c0025c3b <check_device_type+0xef>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c0025c0c:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0025c10:	75 06                	jne    c0025c18 <check_device_type+0xcc>
c0025c12:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0025c16:	74 0c                	je     c0025c24 <check_device_type+0xd8>
c0025c18:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c0025c1c:	75 0d                	jne    c0025c2b <check_device_type+0xdf>
c0025c1e:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c0025c22:	75 07                	jne    c0025c2b <check_device_type+0xdf>
c0025c24:	b8 01 00 00 00       	mov    $0x1,%eax
c0025c29:	eb 05                	jmp    c0025c30 <check_device_type+0xe4>
c0025c2b:	b8 00 00 00 00       	mov    $0x0,%eax
c0025c30:	83 e0 01             	and    $0x1,%eax
c0025c33:	8b 55 08             	mov    0x8(%ebp),%edx
c0025c36:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c0025c39:	b0 01                	mov    $0x1,%al
    }
}
c0025c3b:	c9                   	leave  
c0025c3c:	c3                   	ret    

c0025c3d <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c0025c3d:	55                   	push   %ebp
c0025c3e:	89 e5                	mov    %esp,%ebp
c0025c40:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c0025c46:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c49:	8b 40 08             	mov    0x8(%eax),%eax
c0025c4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c0025c4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c52:	8a 40 10             	mov    0x10(%eax),%al
c0025c55:	84 c0                	test   %al,%al
c0025c57:	75 21                	jne    c0025c7a <identify_ata_device+0x3d>
c0025c59:	83 ec 0c             	sub    $0xc,%esp
c0025c5c:	68 13 01 03 c0       	push   $0xc0030113
c0025c61:	68 1d 01 03 c0       	push   $0xc003011d
c0025c66:	68 38 02 03 c0       	push   $0xc0030238
c0025c6b:	68 0d 01 00 00       	push   $0x10d
c0025c70:	68 fa 00 03 c0       	push   $0xc00300fa
c0025c75:	e8 ae 38 00 00       	call   c0029528 <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c0025c7a:	83 ec 0c             	sub    $0xc,%esp
c0025c7d:	ff 75 08             	pushl  0x8(%ebp)
c0025c80:	e8 81 06 00 00       	call   c0026306 <select_device_wait>
c0025c85:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c0025c88:	83 ec 08             	sub    $0x8,%esp
c0025c8b:	68 ec 00 00 00       	push   $0xec
c0025c90:	ff 75 f4             	pushl  -0xc(%ebp)
c0025c93:	e8 38 04 00 00       	call   c00260d0 <issue_pio_command>
c0025c98:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025c9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c9e:	83 c0 28             	add    $0x28,%eax
c0025ca1:	83 ec 0c             	sub    $0xc,%esp
c0025ca4:	50                   	push   %eax
c0025ca5:	e8 28 cb ff ff       	call   c00227d2 <sema_down>
c0025caa:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025cad:	83 ec 0c             	sub    $0xc,%esp
c0025cb0:	ff 75 08             	pushl  0x8(%ebp)
c0025cb3:	e8 1d 05 00 00       	call   c00261d5 <wait_while_busy>
c0025cb8:	83 c4 10             	add    $0x10,%esp
c0025cbb:	83 f0 01             	xor    $0x1,%eax
c0025cbe:	84 c0                	test   %al,%al
c0025cc0:	74 0c                	je     c0025cce <identify_ata_device+0x91>
    {
      d->is_ata = false;
c0025cc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cc5:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025cc9:	e9 fb 00 00 00       	jmp    c0025dc9 <identify_ata_device+0x18c>
    }
  input_sector (c, id);
c0025cce:	83 ec 08             	sub    $0x8,%esp
c0025cd1:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025cd7:	50                   	push   %eax
c0025cd8:	ff 75 f4             	pushl  -0xc(%ebp)
c0025cdb:	e8 4e 04 00 00       	call   c002612e <input_sector>
c0025ce0:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0025ce3:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025ce9:	83 c0 78             	add    $0x78,%eax
c0025cec:	8b 00                	mov    (%eax),%eax
c0025cee:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c0025cf1:	83 ec 08             	sub    $0x8,%esp
c0025cf4:	6a 14                	push   $0x14
c0025cf6:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025cfc:	83 c0 14             	add    $0x14,%eax
c0025cff:	50                   	push   %eax
c0025d00:	e8 c6 00 00 00       	call   c0025dcb <descramble_ata_string>
c0025d05:	83 c4 10             	add    $0x10,%esp
c0025d08:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c0025d0b:	83 ec 08             	sub    $0x8,%esp
c0025d0e:	6a 28                	push   $0x28
c0025d10:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0025d16:	83 c0 36             	add    $0x36,%eax
c0025d19:	50                   	push   %eax
c0025d1a:	e8 ac 00 00 00       	call   c0025dcb <descramble_ata_string>
c0025d1f:	83 c4 10             	add    $0x10,%esp
c0025d22:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c0025d25:	83 ec 0c             	sub    $0xc,%esp
c0025d28:	ff 75 e8             	pushl  -0x18(%ebp)
c0025d2b:	ff 75 ec             	pushl  -0x14(%ebp)
c0025d2e:	68 34 01 03 c0       	push   $0xc0030134
c0025d33:	68 80 00 00 00       	push   $0x80
c0025d38:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0025d3e:	50                   	push   %eax
c0025d3f:	e8 fc 13 00 00       	call   c0027140 <snprintf>
c0025d44:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c0025d47:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c0025d4e:	76 45                	jbe    c0025d95 <identify_ata_device+0x158>
    {
      printf ("%s: ignoring ", d->name);
c0025d50:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d53:	83 ec 08             	sub    $0x8,%esp
c0025d56:	50                   	push   %eax
c0025d57:	68 4c 01 03 c0       	push   $0xc003014c
c0025d5c:	e8 08 14 00 00       	call   c0027169 <printf>
c0025d61:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c0025d64:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025d67:	c1 e0 09             	shl    $0x9,%eax
c0025d6a:	ba 00 00 00 00       	mov    $0x0,%edx
c0025d6f:	83 ec 08             	sub    $0x8,%esp
c0025d72:	52                   	push   %edx
c0025d73:	50                   	push   %eax
c0025d74:	e8 06 21 00 00       	call   c0027e7f <print_human_readable_size>
c0025d79:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c0025d7c:	83 ec 0c             	sub    $0xc,%esp
c0025d7f:	68 5a 01 03 c0       	push   $0xc003015a
c0025d84:	e8 60 59 00 00       	call   c002b6e9 <puts>
c0025d89:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c0025d8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d8f:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0025d93:	eb 34                	jmp    c0025dc9 <identify_ata_device+0x18c>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c0025d95:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d98:	83 ec 08             	sub    $0x8,%esp
c0025d9b:	ff 75 08             	pushl  0x8(%ebp)
c0025d9e:	68 a0 70 03 c0       	push   $0xc00370a0
c0025da3:	ff 75 f0             	pushl  -0x10(%ebp)
c0025da6:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0025dac:	52                   	push   %edx
c0025dad:	6a 04                	push   $0x4
c0025daf:	50                   	push   %eax
c0025db0:	e8 6b f2 ff ff       	call   c0025020 <block_register>
c0025db5:	83 c4 20             	add    $0x20,%esp
c0025db8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c0025dbb:	83 ec 0c             	sub    $0xc,%esp
c0025dbe:	ff 75 e4             	pushl  -0x1c(%ebp)
c0025dc1:	e8 a2 f3 ff ff       	call   c0025168 <partition_scan>
c0025dc6:	83 c4 10             	add    $0x10,%esp
}
c0025dc9:	c9                   	leave  
c0025dca:	c3                   	ret    

c0025dcb <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0025dcb:	55                   	push   %ebp
c0025dcc:	89 e5                	mov    %esp,%ebp
c0025dce:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025dd1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0025dd8:	eb 38                	jmp    c0025e12 <descramble_ata_string+0x47>
    {
      char tmp = string[i];
c0025dda:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025ddd:	8b 45 08             	mov    0x8(%ebp),%eax
c0025de0:	01 d0                	add    %edx,%eax
c0025de2:	8a 00                	mov    (%eax),%al
c0025de4:	88 45 fb             	mov    %al,-0x5(%ebp)
      string[i] = string[i + 1];
c0025de7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0025dea:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ded:	01 c2                	add    %eax,%edx
c0025def:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025df2:	8d 48 01             	lea    0x1(%eax),%ecx
c0025df5:	8b 45 08             	mov    0x8(%ebp),%eax
c0025df8:	01 c8                	add    %ecx,%eax
c0025dfa:	8a 00                	mov    (%eax),%al
c0025dfc:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0025dfe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025e01:	8d 50 01             	lea    0x1(%eax),%edx
c0025e04:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e07:	01 c2                	add    %eax,%edx
c0025e09:	8a 45 fb             	mov    -0x5(%ebp),%al
c0025e0c:	88 02                	mov    %al,(%edx)
  for (i = 0; i + 1 < size; i += 2)
c0025e0e:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c0025e12:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0025e15:	40                   	inc    %eax
c0025e16:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025e19:	7c bf                	jl     c0025dda <descramble_ata_string+0xf>
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025e1b:	ff 4d 0c             	decl   0xc(%ebp)
c0025e1e:	eb 2b                	jmp    c0025e4b <descramble_ata_string+0x80>
    {
      int c = string[size - 1];
c0025e20:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025e23:	8d 50 ff             	lea    -0x1(%eax),%edx
c0025e26:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e29:	01 d0                	add    %edx,%eax
c0025e2b:	8a 00                	mov    (%eax),%al
c0025e2d:	0f be c0             	movsbl %al,%eax
c0025e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (c != '\0' && !isspace (c))
c0025e33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0025e37:	74 0f                	je     c0025e48 <descramble_ata_string+0x7d>
c0025e39:	ff 75 f4             	pushl  -0xc(%ebp)
c0025e3c:	e8 e1 f7 ff ff       	call   c0025622 <isspace>
c0025e41:	83 c4 04             	add    $0x4,%esp
c0025e44:	85 c0                	test   %eax,%eax
c0025e46:	74 0b                	je     c0025e53 <descramble_ata_string+0x88>
  for (size--; size > 0; size--)
c0025e48:	ff 4d 0c             	decl   0xc(%ebp)
c0025e4b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0025e4f:	7f cf                	jg     c0025e20 <descramble_ata_string+0x55>
c0025e51:	eb 01                	jmp    c0025e54 <descramble_ata_string+0x89>
        break; 
c0025e53:	90                   	nop
    }
  string[size] = '\0';
c0025e54:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025e57:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e5a:	01 d0                	add    %edx,%eax
c0025e5c:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c0025e5f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0025e62:	c9                   	leave  
c0025e63:	c3                   	ret    

c0025e64 <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c0025e64:	55                   	push   %ebp
c0025e65:	89 e5                	mov    %esp,%ebp
c0025e67:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0025e6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0025e6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0025e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025e73:	8b 40 08             	mov    0x8(%eax),%eax
c0025e76:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0025e79:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025e7c:	83 c0 0c             	add    $0xc,%eax
c0025e7f:	83 ec 0c             	sub    $0xc,%esp
c0025e82:	50                   	push   %eax
c0025e83:	e8 08 cc ff ff       	call   c0022a90 <lock_acquire>
c0025e88:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0025e8b:	83 ec 08             	sub    $0x8,%esp
c0025e8e:	ff 75 0c             	pushl  0xc(%ebp)
c0025e91:	ff 75 f4             	pushl  -0xc(%ebp)
c0025e94:	e8 3b 01 00 00       	call   c0025fd4 <select_sector>
c0025e99:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0025e9c:	83 ec 08             	sub    $0x8,%esp
c0025e9f:	6a 20                	push   $0x20
c0025ea1:	ff 75 f0             	pushl  -0x10(%ebp)
c0025ea4:	e8 27 02 00 00       	call   c00260d0 <issue_pio_command>
c0025ea9:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025eac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025eaf:	83 c0 28             	add    $0x28,%eax
c0025eb2:	83 ec 0c             	sub    $0xc,%esp
c0025eb5:	50                   	push   %eax
c0025eb6:	e8 17 c9 ff ff       	call   c00227d2 <sema_down>
c0025ebb:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025ebe:	83 ec 0c             	sub    $0xc,%esp
c0025ec1:	ff 75 f4             	pushl  -0xc(%ebp)
c0025ec4:	e8 0c 03 00 00       	call   c00261d5 <wait_while_busy>
c0025ec9:	83 c4 10             	add    $0x10,%esp
c0025ecc:	83 f0 01             	xor    $0x1,%eax
c0025ecf:	84 c0                	test   %al,%al
c0025ed1:	74 23                	je     c0025ef6 <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0025ed3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025ed6:	83 ec 08             	sub    $0x8,%esp
c0025ed9:	ff 75 0c             	pushl  0xc(%ebp)
c0025edc:	50                   	push   %eax
c0025edd:	68 6c 01 03 c0       	push   $0xc003016c
c0025ee2:	68 4c 02 03 c0       	push   $0xc003024c
c0025ee7:	68 62 01 00 00       	push   $0x162
c0025eec:	68 fa 00 03 c0       	push   $0xc00300fa
c0025ef1:	e8 32 36 00 00       	call   c0029528 <debug_panic>
  input_sector (c, buffer);
c0025ef6:	83 ec 08             	sub    $0x8,%esp
c0025ef9:	ff 75 10             	pushl  0x10(%ebp)
c0025efc:	ff 75 f0             	pushl  -0x10(%ebp)
c0025eff:	e8 2a 02 00 00       	call   c002612e <input_sector>
c0025f04:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0025f07:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f0a:	83 c0 0c             	add    $0xc,%eax
c0025f0d:	83 ec 0c             	sub    $0xc,%esp
c0025f10:	50                   	push   %eax
c0025f11:	e8 ba cc ff ff       	call   c0022bd0 <lock_release>
c0025f16:	83 c4 10             	add    $0x10,%esp
}
c0025f19:	90                   	nop
c0025f1a:	c9                   	leave  
c0025f1b:	c3                   	ret    

c0025f1c <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0025f1c:	55                   	push   %ebp
c0025f1d:	89 e5                	mov    %esp,%ebp
c0025f1f:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c0025f22:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f25:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c0025f28:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025f2b:	8b 40 08             	mov    0x8(%eax),%eax
c0025f2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c0025f31:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025f34:	83 c0 0c             	add    $0xc,%eax
c0025f37:	83 ec 0c             	sub    $0xc,%esp
c0025f3a:	50                   	push   %eax
c0025f3b:	e8 50 cb ff ff       	call   c0022a90 <lock_acquire>
c0025f40:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0025f43:	83 ec 08             	sub    $0x8,%esp
c0025f46:	ff 75 0c             	pushl  0xc(%ebp)
c0025f49:	ff 75 f4             	pushl  -0xc(%ebp)
c0025f4c:	e8 83 00 00 00       	call   c0025fd4 <select_sector>
c0025f51:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c0025f54:	83 ec 08             	sub    $0x8,%esp
c0025f57:	6a 30                	push   $0x30
c0025f59:	ff 75 f0             	pushl  -0x10(%ebp)
c0025f5c:	e8 6f 01 00 00       	call   c00260d0 <issue_pio_command>
c0025f61:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0025f64:	83 ec 0c             	sub    $0xc,%esp
c0025f67:	ff 75 f4             	pushl  -0xc(%ebp)
c0025f6a:	e8 66 02 00 00       	call   c00261d5 <wait_while_busy>
c0025f6f:	83 c4 10             	add    $0x10,%esp
c0025f72:	83 f0 01             	xor    $0x1,%eax
c0025f75:	84 c0                	test   %al,%al
c0025f77:	74 23                	je     c0025f9c <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c0025f79:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025f7c:	83 ec 08             	sub    $0x8,%esp
c0025f7f:	ff 75 0c             	pushl  0xc(%ebp)
c0025f82:	50                   	push   %eax
c0025f83:	68 8c 01 03 c0       	push   $0xc003018c
c0025f88:	68 58 02 03 c0       	push   $0xc0030258
c0025f8d:	68 75 01 00 00       	push   $0x175
c0025f92:	68 fa 00 03 c0       	push   $0xc00300fa
c0025f97:	e8 8c 35 00 00       	call   c0029528 <debug_panic>
  output_sector (c, buffer);
c0025f9c:	83 ec 08             	sub    $0x8,%esp
c0025f9f:	ff 75 10             	pushl  0x10(%ebp)
c0025fa2:	ff 75 f0             	pushl  -0x10(%ebp)
c0025fa5:	e8 a4 01 00 00       	call   c002614e <output_sector>
c0025faa:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0025fad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025fb0:	83 c0 28             	add    $0x28,%eax
c0025fb3:	83 ec 0c             	sub    $0xc,%esp
c0025fb6:	50                   	push   %eax
c0025fb7:	e8 16 c8 ff ff       	call   c00227d2 <sema_down>
c0025fbc:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0025fbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025fc2:	83 c0 0c             	add    $0xc,%eax
c0025fc5:	83 ec 0c             	sub    $0xc,%esp
c0025fc8:	50                   	push   %eax
c0025fc9:	e8 02 cc ff ff       	call   c0022bd0 <lock_release>
c0025fce:	83 c4 10             	add    $0x10,%esp
}
c0025fd1:	90                   	nop
c0025fd2:	c9                   	leave  
c0025fd3:	c3                   	ret    

c0025fd4 <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c0025fd4:	55                   	push   %ebp
c0025fd5:	89 e5                	mov    %esp,%ebp
c0025fd7:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0025fda:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fdd:	8b 40 08             	mov    0x8(%eax),%eax
c0025fe0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c0025fe3:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c0025fea:	76 21                	jbe    c002600d <select_sector+0x39>
c0025fec:	83 ec 0c             	sub    $0xc,%esp
c0025fef:	68 ad 01 03 c0       	push   $0xc00301ad
c0025ff4:	68 1d 01 03 c0       	push   $0xc003011d
c0025ff9:	68 64 02 03 c0       	push   $0xc0030264
c0025ffe:	68 89 01 00 00       	push   $0x189
c0026003:	68 fa 00 03 c0       	push   $0xc00300fa
c0026008:	e8 1b 35 00 00       	call   c0029528 <debug_panic>
  
  select_device_wait (d);
c002600d:	83 ec 0c             	sub    $0xc,%esp
c0026010:	ff 75 08             	pushl  0x8(%ebp)
c0026013:	e8 ee 02 00 00       	call   c0026306 <select_device_wait>
c0026018:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c002601b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002601e:	8b 40 08             	mov    0x8(%eax),%eax
c0026021:	83 c0 02             	add    $0x2,%eax
c0026024:	0f b7 c0             	movzwl %ax,%eax
c0026027:	83 ec 08             	sub    $0x8,%esp
c002602a:	6a 01                	push   $0x1
c002602c:	50                   	push   %eax
c002602d:	e8 73 f6 ff ff       	call   c00256a5 <outb>
c0026032:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c0026035:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026038:	0f b6 d0             	movzbl %al,%edx
c002603b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002603e:	8b 40 08             	mov    0x8(%eax),%eax
c0026041:	83 c0 03             	add    $0x3,%eax
c0026044:	0f b7 c0             	movzwl %ax,%eax
c0026047:	83 ec 08             	sub    $0x8,%esp
c002604a:	52                   	push   %edx
c002604b:	50                   	push   %eax
c002604c:	e8 54 f6 ff ff       	call   c00256a5 <outb>
c0026051:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c0026054:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026057:	c1 e8 08             	shr    $0x8,%eax
c002605a:	0f b6 d0             	movzbl %al,%edx
c002605d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026060:	8b 40 08             	mov    0x8(%eax),%eax
c0026063:	83 c0 04             	add    $0x4,%eax
c0026066:	0f b7 c0             	movzwl %ax,%eax
c0026069:	83 ec 08             	sub    $0x8,%esp
c002606c:	52                   	push   %edx
c002606d:	50                   	push   %eax
c002606e:	e8 32 f6 ff ff       	call   c00256a5 <outb>
c0026073:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c0026076:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026079:	c1 e8 10             	shr    $0x10,%eax
c002607c:	0f b6 d0             	movzbl %al,%edx
c002607f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026082:	8b 40 08             	mov    0x8(%eax),%eax
c0026085:	83 c0 05             	add    $0x5,%eax
c0026088:	0f b7 c0             	movzwl %ax,%eax
c002608b:	83 ec 08             	sub    $0x8,%esp
c002608e:	52                   	push   %edx
c002608f:	50                   	push   %eax
c0026090:	e8 10 f6 ff ff       	call   c00256a5 <outb>
c0026095:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0026098:	8b 45 08             	mov    0x8(%ebp),%eax
c002609b:	8b 40 0c             	mov    0xc(%eax),%eax
c002609e:	83 f8 01             	cmp    $0x1,%eax
c00260a1:	75 04                	jne    c00260a7 <select_sector+0xd3>
c00260a3:	b0 f0                	mov    $0xf0,%al
c00260a5:	eb 02                	jmp    c00260a9 <select_sector+0xd5>
c00260a7:	b0 e0                	mov    $0xe0,%al
c00260a9:	8b 55 0c             	mov    0xc(%ebp),%edx
c00260ac:	c1 ea 18             	shr    $0x18,%edx
c00260af:	09 d0                	or     %edx,%eax
  outb (reg_device (c),
c00260b1:	0f b6 d0             	movzbl %al,%edx
c00260b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00260b7:	8b 40 08             	mov    0x8(%eax),%eax
c00260ba:	83 c0 06             	add    $0x6,%eax
c00260bd:	0f b7 c0             	movzwl %ax,%eax
c00260c0:	83 ec 08             	sub    $0x8,%esp
c00260c3:	52                   	push   %edx
c00260c4:	50                   	push   %eax
c00260c5:	e8 db f5 ff ff       	call   c00256a5 <outb>
c00260ca:	83 c4 10             	add    $0x10,%esp
}
c00260cd:	90                   	nop
c00260ce:	c9                   	leave  
c00260cf:	c3                   	ret    

c00260d0 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c00260d0:	55                   	push   %ebp
c00260d1:	89 e5                	mov    %esp,%ebp
c00260d3:	83 ec 18             	sub    $0x18,%esp
c00260d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00260d9:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c00260dc:	e8 36 b2 ff ff       	call   c0021317 <intr_get_level>
c00260e1:	83 f8 01             	cmp    $0x1,%eax
c00260e4:	74 21                	je     c0026107 <issue_pio_command+0x37>
c00260e6:	83 ec 0c             	sub    $0xc,%esp
c00260e9:	68 c2 01 03 c0       	push   $0xc00301c2
c00260ee:	68 1d 01 03 c0       	push   $0xc003011d
c00260f3:	68 74 02 03 c0       	push   $0xc0030274
c00260f8:	68 9b 01 00 00       	push   $0x19b
c00260fd:	68 fa 00 03 c0       	push   $0xc00300fa
c0026102:	e8 21 34 00 00       	call   c0029528 <debug_panic>

  c->expecting_interrupt = true;
c0026107:	8b 45 08             	mov    0x8(%ebp),%eax
c002610a:	c6 40 24 01          	movb   $0x1,0x24(%eax)
  outb (reg_command (c), command);
c002610e:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0026112:	8b 45 08             	mov    0x8(%ebp),%eax
c0026115:	8b 40 08             	mov    0x8(%eax),%eax
c0026118:	83 c0 07             	add    $0x7,%eax
c002611b:	0f b7 c0             	movzwl %ax,%eax
c002611e:	83 ec 08             	sub    $0x8,%esp
c0026121:	52                   	push   %edx
c0026122:	50                   	push   %eax
c0026123:	e8 7d f5 ff ff       	call   c00256a5 <outb>
c0026128:	83 c4 10             	add    $0x10,%esp
}
c002612b:	90                   	nop
c002612c:	c9                   	leave  
c002612d:	c3                   	ret    

c002612e <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c002612e:	55                   	push   %ebp
c002612f:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026131:	8b 45 08             	mov    0x8(%ebp),%eax
c0026134:	8b 40 08             	mov    0x8(%eax),%eax
c0026137:	0f b7 c0             	movzwl %ax,%eax
c002613a:	68 00 01 00 00       	push   $0x100
c002613f:	ff 75 0c             	pushl  0xc(%ebp)
c0026142:	50                   	push   %eax
c0026143:	e8 2a f5 ff ff       	call   c0025672 <insw>
c0026148:	83 c4 0c             	add    $0xc,%esp
}
c002614b:	90                   	nop
c002614c:	c9                   	leave  
c002614d:	c3                   	ret    

c002614e <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c002614e:	55                   	push   %ebp
c002614f:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c0026151:	8b 45 08             	mov    0x8(%ebp),%eax
c0026154:	8b 40 08             	mov    0x8(%eax),%eax
c0026157:	0f b7 c0             	movzwl %ax,%eax
c002615a:	68 00 01 00 00       	push   $0x100
c002615f:	ff 75 0c             	pushl  0xc(%ebp)
c0026162:	50                   	push   %eax
c0026163:	e8 5a f5 ff ff       	call   c00256c2 <outsw>
c0026168:	83 c4 0c             	add    $0xc,%esp
}
c002616b:	90                   	nop
c002616c:	c9                   	leave  
c002616d:	c3                   	ret    

c002616e <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c002616e:	55                   	push   %ebp
c002616f:	89 e5                	mov    %esp,%ebp
c0026171:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c0026174:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002617b:	eb 36                	jmp    c00261b3 <wait_until_idle+0x45>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c002617d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026180:	8b 40 08             	mov    0x8(%eax),%eax
c0026183:	8b 40 08             	mov    0x8(%eax),%eax
c0026186:	83 c0 07             	add    $0x7,%eax
c0026189:	0f b7 c0             	movzwl %ax,%eax
c002618c:	50                   	push   %eax
c002618d:	e8 c5 f4 ff ff       	call   c0025657 <inb>
c0026192:	83 c4 04             	add    $0x4,%esp
c0026195:	0f b6 c0             	movzbl %al,%eax
c0026198:	25 88 00 00 00       	and    $0x88,%eax
c002619d:	85 c0                	test   %eax,%eax
c002619f:	74 31                	je     c00261d2 <wait_until_idle+0x64>
        return;
      timer_usleep (10);
c00261a1:	83 ec 08             	sub    $0x8,%esp
c00261a4:	6a 00                	push   $0x0
c00261a6:	6a 0a                	push   $0xa
c00261a8:	e8 dd db ff ff       	call   c0023d8a <timer_usleep>
c00261ad:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 1000; i++) 
c00261b0:	ff 45 f4             	incl   -0xc(%ebp)
c00261b3:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c00261ba:	7e c1                	jle    c002617d <wait_until_idle+0xf>
    }

  printf ("%s: idle timeout\n", d->name);
c00261bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00261bf:	83 ec 08             	sub    $0x8,%esp
c00261c2:	50                   	push   %eax
c00261c3:	68 df 01 03 c0       	push   $0xc00301df
c00261c8:	e8 9c 0f 00 00       	call   c0027169 <printf>
c00261cd:	83 c4 10             	add    $0x10,%esp
c00261d0:	eb 01                	jmp    c00261d3 <wait_until_idle+0x65>
        return;
c00261d2:	90                   	nop
}
c00261d3:	c9                   	leave  
c00261d4:	c3                   	ret    

c00261d5 <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c00261d5:	55                   	push   %ebp
c00261d6:	89 e5                	mov    %esp,%ebp
c00261d8:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00261db:	8b 45 08             	mov    0x8(%ebp),%eax
c00261de:	8b 40 08             	mov    0x8(%eax),%eax
c00261e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c00261e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00261eb:	e9 8d 00 00 00       	jmp    c002627d <wait_while_busy+0xa8>
    {
      if (i == 700)
c00261f0:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c00261f7:	75 14                	jne    c002620d <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c00261f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00261fc:	83 ec 08             	sub    $0x8,%esp
c00261ff:	50                   	push   %eax
c0026200:	68 f1 01 03 c0       	push   $0xc00301f1
c0026205:	e8 5f 0f 00 00       	call   c0027169 <printf>
c002620a:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c002620d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026210:	8b 40 08             	mov    0x8(%eax),%eax
c0026213:	05 06 02 00 00       	add    $0x206,%eax
c0026218:	0f b7 c0             	movzwl %ax,%eax
c002621b:	83 ec 0c             	sub    $0xc,%esp
c002621e:	50                   	push   %eax
c002621f:	e8 33 f4 ff ff       	call   c0025657 <inb>
c0026224:	83 c4 10             	add    $0x10,%esp
c0026227:	84 c0                	test   %al,%al
c0026229:	78 40                	js     c002626b <wait_while_busy+0x96>
        {
          if (i >= 700)
c002622b:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c0026232:	7e 10                	jle    c0026244 <wait_while_busy+0x6f>
            printf ("ok\n");
c0026234:	83 ec 0c             	sub    $0xc,%esp
c0026237:	68 06 02 03 c0       	push   $0xc0030206
c002623c:	e8 a8 54 00 00       	call   c002b6e9 <puts>
c0026241:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c0026244:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026247:	8b 40 08             	mov    0x8(%eax),%eax
c002624a:	05 06 02 00 00       	add    $0x206,%eax
c002624f:	0f b7 c0             	movzwl %ax,%eax
c0026252:	83 ec 0c             	sub    $0xc,%esp
c0026255:	50                   	push   %eax
c0026256:	e8 fc f3 ff ff       	call   c0025657 <inb>
c002625b:	83 c4 10             	add    $0x10,%esp
c002625e:	0f b6 c0             	movzbl %al,%eax
c0026261:	83 e0 08             	and    $0x8,%eax
c0026264:	85 c0                	test   %eax,%eax
c0026266:	0f 95 c0             	setne  %al
c0026269:	eb 31                	jmp    c002629c <wait_while_busy+0xc7>
        }
      timer_msleep (10);
c002626b:	83 ec 08             	sub    $0x8,%esp
c002626e:	6a 00                	push   $0x0
c0026270:	6a 0a                	push   $0xa
c0026272:	e8 e8 da ff ff       	call   c0023d5f <timer_msleep>
c0026277:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 3000; i++)
c002627a:	ff 45 f4             	incl   -0xc(%ebp)
c002627d:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c0026284:	0f 8e 66 ff ff ff    	jle    c00261f0 <wait_while_busy+0x1b>
    }

  printf ("failed\n");
c002628a:	83 ec 0c             	sub    $0xc,%esp
c002628d:	68 09 02 03 c0       	push   $0xc0030209
c0026292:	e8 52 54 00 00       	call   c002b6e9 <puts>
c0026297:	83 c4 10             	add    $0x10,%esp
  return false;
c002629a:	b0 00                	mov    $0x0,%al
}
c002629c:	c9                   	leave  
c002629d:	c3                   	ret    

c002629e <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c002629e:	55                   	push   %ebp
c002629f:	89 e5                	mov    %esp,%ebp
c00262a1:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00262a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00262a7:	8b 40 08             	mov    0x8(%eax),%eax
c00262aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c00262ad:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c00262b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00262b4:	8b 40 0c             	mov    0xc(%eax),%eax
c00262b7:	83 f8 01             	cmp    $0x1,%eax
c00262ba:	75 04                	jne    c00262c0 <select_device+0x22>
    dev |= DEV_DEV;
c00262bc:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c00262c0:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c00262c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00262c7:	8b 40 08             	mov    0x8(%eax),%eax
c00262ca:	83 c0 06             	add    $0x6,%eax
c00262cd:	0f b7 c0             	movzwl %ax,%eax
c00262d0:	52                   	push   %edx
c00262d1:	50                   	push   %eax
c00262d2:	e8 ce f3 ff ff       	call   c00256a5 <outb>
c00262d7:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c00262da:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00262dd:	8b 40 08             	mov    0x8(%eax),%eax
c00262e0:	05 06 02 00 00       	add    $0x206,%eax
c00262e5:	0f b7 c0             	movzwl %ax,%eax
c00262e8:	50                   	push   %eax
c00262e9:	e8 69 f3 ff ff       	call   c0025657 <inb>
c00262ee:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c00262f1:	83 ec 08             	sub    $0x8,%esp
c00262f4:	6a 00                	push   $0x0
c00262f6:	68 90 01 00 00       	push   $0x190
c00262fb:	e8 b5 da ff ff       	call   c0023db5 <timer_nsleep>
c0026300:	83 c4 10             	add    $0x10,%esp
}
c0026303:	90                   	nop
c0026304:	c9                   	leave  
c0026305:	c3                   	ret    

c0026306 <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c0026306:	55                   	push   %ebp
c0026307:	89 e5                	mov    %esp,%ebp
c0026309:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c002630c:	83 ec 0c             	sub    $0xc,%esp
c002630f:	ff 75 08             	pushl  0x8(%ebp)
c0026312:	e8 57 fe ff ff       	call   c002616e <wait_until_idle>
c0026317:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c002631a:	83 ec 0c             	sub    $0xc,%esp
c002631d:	ff 75 08             	pushl  0x8(%ebp)
c0026320:	e8 79 ff ff ff       	call   c002629e <select_device>
c0026325:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c0026328:	83 ec 0c             	sub    $0xc,%esp
c002632b:	ff 75 08             	pushl  0x8(%ebp)
c002632e:	e8 3b fe ff ff       	call   c002616e <wait_until_idle>
c0026333:	83 c4 10             	add    $0x10,%esp
}
c0026336:	90                   	nop
c0026337:	c9                   	leave  
c0026338:	c3                   	ret    

c0026339 <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c0026339:	55                   	push   %ebp
c002633a:	89 e5                	mov    %esp,%ebp
c002633c:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c002633f:	c7 45 f4 80 89 03 c0 	movl   $0xc0038980,-0xc(%ebp)
c0026346:	eb 60                	jmp    c00263a8 <interrupt_handler+0x6f>
    if (f->vec_no == c->irq)
c0026348:	8b 45 08             	mov    0x8(%ebp),%eax
c002634b:	8b 50 30             	mov    0x30(%eax),%edx
c002634e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026351:	8a 40 0a             	mov    0xa(%eax),%al
c0026354:	0f b6 c0             	movzbl %al,%eax
c0026357:	39 c2                	cmp    %eax,%edx
c0026359:	75 49                	jne    c00263a4 <interrupt_handler+0x6b>
      {
        if (c->expecting_interrupt) 
c002635b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002635e:	8a 40 24             	mov    0x24(%eax),%al
c0026361:	84 c0                	test   %al,%al
c0026363:	74 29                	je     c002638e <interrupt_handler+0x55>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c0026365:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026368:	8b 40 08             	mov    0x8(%eax),%eax
c002636b:	83 c0 07             	add    $0x7,%eax
c002636e:	0f b7 c0             	movzwl %ax,%eax
c0026371:	50                   	push   %eax
c0026372:	e8 e0 f2 ff ff       	call   c0025657 <inb>
c0026377:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c002637a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002637d:	83 c0 28             	add    $0x28,%eax
c0026380:	83 ec 0c             	sub    $0xc,%esp
c0026383:	50                   	push   %eax
c0026384:	e8 53 c5 ff ff       	call   c00228dc <sema_up>
c0026389:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c002638c:	eb 3d                	jmp    c00263cb <interrupt_handler+0x92>
          printf ("%s: unexpected interrupt\n", c->name);
c002638e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026391:	83 ec 08             	sub    $0x8,%esp
c0026394:	50                   	push   %eax
c0026395:	68 10 02 03 c0       	push   $0xc0030210
c002639a:	e8 ca 0d 00 00       	call   c0027169 <printf>
c002639f:	83 c4 10             	add    $0x10,%esp
        return;
c00263a2:	eb 27                	jmp    c00263cb <interrupt_handler+0x92>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00263a4:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
c00263a8:	b8 48 8a 03 c0       	mov    $0xc0038a48,%eax
c00263ad:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c00263b0:	72 96                	jb     c0026348 <interrupt_handler+0xf>
      }

  NOT_REACHED ();
c00263b2:	68 d8 00 03 c0       	push   $0xc00300d8
c00263b7:	68 88 02 03 c0       	push   $0xc0030288
c00263bc:	68 0c 02 00 00       	push   $0x20c
c00263c1:	68 fa 00 03 c0       	push   $0xc00300fa
c00263c6:	e8 5d 31 00 00       	call   c0029528 <debug_panic>
}
c00263cb:	c9                   	leave  
c00263cc:	c3                   	ret    

c00263cd <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c00263cd:	55                   	push   %ebp
c00263ce:	89 e5                	mov    %esp,%ebp
c00263d0:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c00263d3:	83 ec 0c             	sub    $0xc,%esp
c00263d6:	68 60 8a 03 c0       	push   $0xc0038a60
c00263db:	e8 03 01 00 00       	call   c00264e3 <intq_init>
c00263e0:	83 c4 10             	add    $0x10,%esp
}
c00263e3:	90                   	nop
c00263e4:	c9                   	leave  
c00263e5:	c3                   	ret    

c00263e6 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c00263e6:	55                   	push   %ebp
c00263e7:	89 e5                	mov    %esp,%ebp
c00263e9:	83 ec 18             	sub    $0x18,%esp
c00263ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00263ef:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c00263f2:	e8 20 af ff ff       	call   c0021317 <intr_get_level>
c00263f7:	85 c0                	test   %eax,%eax
c00263f9:	74 1e                	je     c0026419 <input_putc+0x33>
c00263fb:	83 ec 0c             	sub    $0xc,%esp
c00263fe:	68 9c 02 03 c0       	push   $0xc003029c
c0026403:	68 ba 02 03 c0       	push   $0xc00302ba
c0026408:	68 fc 02 03 c0       	push   $0xc00302fc
c002640d:	6a 15                	push   $0x15
c002640f:	68 d1 02 03 c0       	push   $0xc00302d1
c0026414:	e8 0f 31 00 00       	call   c0029528 <debug_panic>
  ASSERT (!intq_full (&buffer));
c0026419:	83 ec 0c             	sub    $0xc,%esp
c002641c:	68 60 8a 03 c0       	push   $0xc0038a60
c0026421:	e8 41 01 00 00       	call   c0026567 <intq_full>
c0026426:	83 c4 10             	add    $0x10,%esp
c0026429:	83 f0 01             	xor    $0x1,%eax
c002642c:	84 c0                	test   %al,%al
c002642e:	75 1e                	jne    c002644e <input_putc+0x68>
c0026430:	83 ec 0c             	sub    $0xc,%esp
c0026433:	68 e7 02 03 c0       	push   $0xc00302e7
c0026438:	68 ba 02 03 c0       	push   $0xc00302ba
c002643d:	68 fc 02 03 c0       	push   $0xc00302fc
c0026442:	6a 16                	push   $0x16
c0026444:	68 d1 02 03 c0       	push   $0xc00302d1
c0026449:	e8 da 30 00 00       	call   c0029528 <debug_panic>

  intq_putc (&buffer, key);
c002644e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0026452:	83 ec 08             	sub    $0x8,%esp
c0026455:	50                   	push   %eax
c0026456:	68 60 8a 03 c0       	push   $0xc0038a60
c002645b:	e8 35 02 00 00       	call   c0026695 <intq_putc>
c0026460:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c0026463:	e8 23 e6 ff ff       	call   c0024a8b <serial_notify>
}
c0026468:	90                   	nop
c0026469:	c9                   	leave  
c002646a:	c3                   	ret    

c002646b <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c002646b:	55                   	push   %ebp
c002646c:	89 e5                	mov    %esp,%ebp
c002646e:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0026471:	e8 16 af ff ff       	call   c002138c <intr_disable>
c0026476:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c0026479:	83 ec 0c             	sub    $0xc,%esp
c002647c:	68 60 8a 03 c0       	push   $0xc0038a60
c0026481:	e8 2f 01 00 00       	call   c00265b5 <intq_getc>
c0026486:	83 c4 10             	add    $0x10,%esp
c0026489:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c002648c:	e8 fa e5 ff ff       	call   c0024a8b <serial_notify>
  intr_set_level (old_level);
c0026491:	83 ec 0c             	sub    $0xc,%esp
c0026494:	ff 75 f4             	pushl  -0xc(%ebp)
c0026497:	e8 98 ae ff ff       	call   c0021334 <intr_set_level>
c002649c:	83 c4 10             	add    $0x10,%esp
  
  return key;
c002649f:	8a 45 f3             	mov    -0xd(%ebp),%al
}
c00264a2:	c9                   	leave  
c00264a3:	c3                   	ret    

c00264a4 <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c00264a4:	55                   	push   %ebp
c00264a5:	89 e5                	mov    %esp,%ebp
c00264a7:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00264aa:	e8 68 ae ff ff       	call   c0021317 <intr_get_level>
c00264af:	85 c0                	test   %eax,%eax
c00264b1:	74 1e                	je     c00264d1 <input_full+0x2d>
c00264b3:	83 ec 0c             	sub    $0xc,%esp
c00264b6:	68 9c 02 03 c0       	push   $0xc003029c
c00264bb:	68 ba 02 03 c0       	push   $0xc00302ba
c00264c0:	68 08 03 03 c0       	push   $0xc0030308
c00264c5:	6a 32                	push   $0x32
c00264c7:	68 d1 02 03 c0       	push   $0xc00302d1
c00264cc:	e8 57 30 00 00       	call   c0029528 <debug_panic>
  return intq_full (&buffer);
c00264d1:	83 ec 0c             	sub    $0xc,%esp
c00264d4:	68 60 8a 03 c0       	push   $0xc0038a60
c00264d9:	e8 89 00 00 00       	call   c0026567 <intq_full>
c00264de:	83 c4 10             	add    $0x10,%esp
}
c00264e1:	c9                   	leave  
c00264e2:	c3                   	ret    

c00264e3 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c00264e3:	55                   	push   %ebp
c00264e4:	89 e5                	mov    %esp,%ebp
c00264e6:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c00264e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00264ec:	83 ec 0c             	sub    $0xc,%esp
c00264ef:	50                   	push   %eax
c00264f0:	e8 4e c5 ff ff       	call   c0022a43 <lock_init>
c00264f5:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c00264f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00264fb:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
c0026502:	8b 45 08             	mov    0x8(%ebp),%eax
c0026505:	8b 50 1c             	mov    0x1c(%eax),%edx
c0026508:	8b 45 08             	mov    0x8(%ebp),%eax
c002650b:	89 50 18             	mov    %edx,0x18(%eax)
  q->head = q->tail = 0;
c002650e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026511:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
c0026518:	8b 45 08             	mov    0x8(%ebp),%eax
c002651b:	8b 50 64             	mov    0x64(%eax),%edx
c002651e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026521:	89 50 60             	mov    %edx,0x60(%eax)
}
c0026524:	90                   	nop
c0026525:	c9                   	leave  
c0026526:	c3                   	ret    

c0026527 <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0026527:	55                   	push   %ebp
c0026528:	89 e5                	mov    %esp,%ebp
c002652a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c002652d:	e8 e5 ad ff ff       	call   c0021317 <intr_get_level>
c0026532:	85 c0                	test   %eax,%eax
c0026534:	74 1e                	je     c0026554 <intq_empty+0x2d>
c0026536:	83 ec 0c             	sub    $0xc,%esp
c0026539:	68 14 03 03 c0       	push   $0xc0030314
c002653e:	68 32 03 03 c0       	push   $0xc0030332
c0026543:	68 28 04 03 c0       	push   $0xc0030428
c0026548:	6a 16                	push   $0x16
c002654a:	68 49 03 03 c0       	push   $0xc0030349
c002654f:	e8 d4 2f 00 00       	call   c0029528 <debug_panic>
  return q->head == q->tail;
c0026554:	8b 45 08             	mov    0x8(%ebp),%eax
c0026557:	8b 50 60             	mov    0x60(%eax),%edx
c002655a:	8b 45 08             	mov    0x8(%ebp),%eax
c002655d:	8b 40 64             	mov    0x64(%eax),%eax
c0026560:	39 c2                	cmp    %eax,%edx
c0026562:	0f 94 c0             	sete   %al
}
c0026565:	c9                   	leave  
c0026566:	c3                   	ret    

c0026567 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0026567:	55                   	push   %ebp
c0026568:	89 e5                	mov    %esp,%ebp
c002656a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c002656d:	e8 a5 ad ff ff       	call   c0021317 <intr_get_level>
c0026572:	85 c0                	test   %eax,%eax
c0026574:	74 1e                	je     c0026594 <intq_full+0x2d>
c0026576:	83 ec 0c             	sub    $0xc,%esp
c0026579:	68 14 03 03 c0       	push   $0xc0030314
c002657e:	68 32 03 03 c0       	push   $0xc0030332
c0026583:	68 34 04 03 c0       	push   $0xc0030434
c0026588:	6a 1e                	push   $0x1e
c002658a:	68 49 03 03 c0       	push   $0xc0030349
c002658f:	e8 94 2f 00 00       	call   c0029528 <debug_panic>
  return next (q->head) == q->tail;
c0026594:	8b 45 08             	mov    0x8(%ebp),%eax
c0026597:	8b 40 60             	mov    0x60(%eax),%eax
c002659a:	83 ec 0c             	sub    $0xc,%esp
c002659d:	50                   	push   %eax
c002659e:	e8 d6 01 00 00       	call   c0026779 <next>
c00265a3:	83 c4 10             	add    $0x10,%esp
c00265a6:	89 c2                	mov    %eax,%edx
c00265a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00265ab:	8b 40 64             	mov    0x64(%eax),%eax
c00265ae:	39 c2                	cmp    %eax,%edx
c00265b0:	0f 94 c0             	sete   %al
}
c00265b3:	c9                   	leave  
c00265b4:	c3                   	ret    

c00265b5 <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c00265b5:	55                   	push   %ebp
c00265b6:	89 e5                	mov    %esp,%ebp
c00265b8:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c00265bb:	e8 57 ad ff ff       	call   c0021317 <intr_get_level>
c00265c0:	85 c0                	test   %eax,%eax
c00265c2:	74 7b                	je     c002663f <intq_getc+0x8a>
c00265c4:	83 ec 0c             	sub    $0xc,%esp
c00265c7:	68 14 03 03 c0       	push   $0xc0030314
c00265cc:	68 32 03 03 c0       	push   $0xc0030332
c00265d1:	68 40 04 03 c0       	push   $0xc0030440
c00265d6:	6a 2a                	push   $0x2a
c00265d8:	68 49 03 03 c0       	push   $0xc0030349
c00265dd:	e8 46 2f 00 00       	call   c0029528 <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c00265e2:	e8 72 b0 ff ff       	call   c0021659 <intr_context>
c00265e7:	83 f0 01             	xor    $0x1,%eax
c00265ea:	84 c0                	test   %al,%al
c00265ec:	75 1e                	jne    c002660c <intq_getc+0x57>
c00265ee:	83 ec 0c             	sub    $0xc,%esp
c00265f1:	68 5e 03 03 c0       	push   $0xc003035e
c00265f6:	68 32 03 03 c0       	push   $0xc0030332
c00265fb:	68 40 04 03 c0       	push   $0xc0030440
c0026600:	6a 2d                	push   $0x2d
c0026602:	68 49 03 03 c0       	push   $0xc0030349
c0026607:	e8 1c 2f 00 00       	call   c0029528 <debug_panic>
      lock_acquire (&q->lock);
c002660c:	8b 45 08             	mov    0x8(%ebp),%eax
c002660f:	83 ec 0c             	sub    $0xc,%esp
c0026612:	50                   	push   %eax
c0026613:	e8 78 c4 ff ff       	call   c0022a90 <lock_acquire>
c0026618:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c002661b:	8b 45 08             	mov    0x8(%ebp),%eax
c002661e:	83 c0 1c             	add    $0x1c,%eax
c0026621:	83 ec 08             	sub    $0x8,%esp
c0026624:	50                   	push   %eax
c0026625:	ff 75 08             	pushl  0x8(%ebp)
c0026628:	e8 63 01 00 00       	call   c0026790 <wait>
c002662d:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026630:	8b 45 08             	mov    0x8(%ebp),%eax
c0026633:	83 ec 0c             	sub    $0xc,%esp
c0026636:	50                   	push   %eax
c0026637:	e8 94 c5 ff ff       	call   c0022bd0 <lock_release>
c002663c:	83 c4 10             	add    $0x10,%esp
  while (intq_empty (q)) 
c002663f:	83 ec 0c             	sub    $0xc,%esp
c0026642:	ff 75 08             	pushl  0x8(%ebp)
c0026645:	e8 dd fe ff ff       	call   c0026527 <intq_empty>
c002664a:	83 c4 10             	add    $0x10,%esp
c002664d:	84 c0                	test   %al,%al
c002664f:	75 91                	jne    c00265e2 <intq_getc+0x2d>
    }
  
  byte = q->buf[q->tail];
c0026651:	8b 45 08             	mov    0x8(%ebp),%eax
c0026654:	8b 40 64             	mov    0x64(%eax),%eax
c0026657:	8b 55 08             	mov    0x8(%ebp),%edx
c002665a:	8a 44 02 20          	mov    0x20(%edx,%eax,1),%al
c002665e:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0026661:	8b 45 08             	mov    0x8(%ebp),%eax
c0026664:	8b 40 64             	mov    0x64(%eax),%eax
c0026667:	83 ec 0c             	sub    $0xc,%esp
c002666a:	50                   	push   %eax
c002666b:	e8 09 01 00 00       	call   c0026779 <next>
c0026670:	83 c4 10             	add    $0x10,%esp
c0026673:	89 c2                	mov    %eax,%edx
c0026675:	8b 45 08             	mov    0x8(%ebp),%eax
c0026678:	89 50 64             	mov    %edx,0x64(%eax)
  signal (q, &q->not_full);
c002667b:	8b 45 08             	mov    0x8(%ebp),%eax
c002667e:	83 c0 18             	add    $0x18,%eax
c0026681:	83 ec 08             	sub    $0x8,%esp
c0026684:	50                   	push   %eax
c0026685:	ff 75 08             	pushl  0x8(%ebp)
c0026688:	e8 c6 01 00 00       	call   c0026853 <signal>
c002668d:	83 c4 10             	add    $0x10,%esp
  return byte;
c0026690:	8a 45 f7             	mov    -0x9(%ebp),%al
}
c0026693:	c9                   	leave  
c0026694:	c3                   	ret    

c0026695 <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c0026695:	55                   	push   %ebp
c0026696:	89 e5                	mov    %esp,%ebp
c0026698:	83 ec 18             	sub    $0x18,%esp
c002669b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002669e:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c00266a1:	e8 71 ac ff ff       	call   c0021317 <intr_get_level>
c00266a6:	85 c0                	test   %eax,%eax
c00266a8:	74 7b                	je     c0026725 <intq_putc+0x90>
c00266aa:	83 ec 0c             	sub    $0xc,%esp
c00266ad:	68 14 03 03 c0       	push   $0xc0030314
c00266b2:	68 32 03 03 c0       	push   $0xc0030332
c00266b7:	68 4c 04 03 c0       	push   $0xc003044c
c00266bc:	6a 3f                	push   $0x3f
c00266be:	68 49 03 03 c0       	push   $0xc0030349
c00266c3:	e8 60 2e 00 00       	call   c0029528 <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c00266c8:	e8 8c af ff ff       	call   c0021659 <intr_context>
c00266cd:	83 f0 01             	xor    $0x1,%eax
c00266d0:	84 c0                	test   %al,%al
c00266d2:	75 1e                	jne    c00266f2 <intq_putc+0x5d>
c00266d4:	83 ec 0c             	sub    $0xc,%esp
c00266d7:	68 5e 03 03 c0       	push   $0xc003035e
c00266dc:	68 32 03 03 c0       	push   $0xc0030332
c00266e1:	68 4c 04 03 c0       	push   $0xc003044c
c00266e6:	6a 42                	push   $0x42
c00266e8:	68 49 03 03 c0       	push   $0xc0030349
c00266ed:	e8 36 2e 00 00       	call   c0029528 <debug_panic>
      lock_acquire (&q->lock);
c00266f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00266f5:	83 ec 0c             	sub    $0xc,%esp
c00266f8:	50                   	push   %eax
c00266f9:	e8 92 c3 ff ff       	call   c0022a90 <lock_acquire>
c00266fe:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c0026701:	8b 45 08             	mov    0x8(%ebp),%eax
c0026704:	83 c0 18             	add    $0x18,%eax
c0026707:	83 ec 08             	sub    $0x8,%esp
c002670a:	50                   	push   %eax
c002670b:	ff 75 08             	pushl  0x8(%ebp)
c002670e:	e8 7d 00 00 00       	call   c0026790 <wait>
c0026713:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026716:	8b 45 08             	mov    0x8(%ebp),%eax
c0026719:	83 ec 0c             	sub    $0xc,%esp
c002671c:	50                   	push   %eax
c002671d:	e8 ae c4 ff ff       	call   c0022bd0 <lock_release>
c0026722:	83 c4 10             	add    $0x10,%esp
  while (intq_full (q))
c0026725:	83 ec 0c             	sub    $0xc,%esp
c0026728:	ff 75 08             	pushl  0x8(%ebp)
c002672b:	e8 37 fe ff ff       	call   c0026567 <intq_full>
c0026730:	83 c4 10             	add    $0x10,%esp
c0026733:	84 c0                	test   %al,%al
c0026735:	75 91                	jne    c00266c8 <intq_putc+0x33>
    }

  q->buf[q->head] = byte;
c0026737:	8b 45 08             	mov    0x8(%ebp),%eax
c002673a:	8b 40 60             	mov    0x60(%eax),%eax
c002673d:	8b 55 08             	mov    0x8(%ebp),%edx
c0026740:	8a 4d f4             	mov    -0xc(%ebp),%cl
c0026743:	88 4c 02 20          	mov    %cl,0x20(%edx,%eax,1)
  q->head = next (q->head);
c0026747:	8b 45 08             	mov    0x8(%ebp),%eax
c002674a:	8b 40 60             	mov    0x60(%eax),%eax
c002674d:	83 ec 0c             	sub    $0xc,%esp
c0026750:	50                   	push   %eax
c0026751:	e8 23 00 00 00       	call   c0026779 <next>
c0026756:	83 c4 10             	add    $0x10,%esp
c0026759:	89 c2                	mov    %eax,%edx
c002675b:	8b 45 08             	mov    0x8(%ebp),%eax
c002675e:	89 50 60             	mov    %edx,0x60(%eax)
  signal (q, &q->not_empty);
c0026761:	8b 45 08             	mov    0x8(%ebp),%eax
c0026764:	83 c0 1c             	add    $0x1c,%eax
c0026767:	83 ec 08             	sub    $0x8,%esp
c002676a:	50                   	push   %eax
c002676b:	ff 75 08             	pushl  0x8(%ebp)
c002676e:	e8 e0 00 00 00       	call   c0026853 <signal>
c0026773:	83 c4 10             	add    $0x10,%esp
}
c0026776:	90                   	nop
c0026777:	c9                   	leave  
c0026778:	c3                   	ret    

c0026779 <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c0026779:	55                   	push   %ebp
c002677a:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c002677c:	8b 45 08             	mov    0x8(%ebp),%eax
c002677f:	40                   	inc    %eax
c0026780:	25 3f 00 00 80       	and    $0x8000003f,%eax
c0026785:	85 c0                	test   %eax,%eax
c0026787:	79 05                	jns    c002678e <next+0x15>
c0026789:	48                   	dec    %eax
c002678a:	83 c8 c0             	or     $0xffffffc0,%eax
c002678d:	40                   	inc    %eax
}
c002678e:	5d                   	pop    %ebp
c002678f:	c3                   	ret    

c0026790 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0026790:	55                   	push   %ebp
c0026791:	89 e5                	mov    %esp,%ebp
c0026793:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0026796:	e8 be ae ff ff       	call   c0021659 <intr_context>
c002679b:	83 f0 01             	xor    $0x1,%eax
c002679e:	84 c0                	test   %al,%al
c00267a0:	75 1e                	jne    c00267c0 <wait+0x30>
c00267a2:	83 ec 0c             	sub    $0xc,%esp
c00267a5:	68 5e 03 03 c0       	push   $0xc003035e
c00267aa:	68 32 03 03 c0       	push   $0xc0030332
c00267af:	68 58 04 03 c0       	push   $0xc0030458
c00267b4:	6a 59                	push   $0x59
c00267b6:	68 49 03 03 c0       	push   $0xc0030349
c00267bb:	e8 68 2d 00 00       	call   c0029528 <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c00267c0:	e8 52 ab ff ff       	call   c0021317 <intr_get_level>
c00267c5:	85 c0                	test   %eax,%eax
c00267c7:	74 1e                	je     c00267e7 <wait+0x57>
c00267c9:	83 ec 0c             	sub    $0xc,%esp
c00267cc:	68 14 03 03 c0       	push   $0xc0030314
c00267d1:	68 32 03 03 c0       	push   $0xc0030332
c00267d6:	68 58 04 03 c0       	push   $0xc0030458
c00267db:	6a 5a                	push   $0x5a
c00267dd:	68 49 03 03 c0       	push   $0xc0030349
c00267e2:	e8 41 2d 00 00       	call   c0029528 <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c00267e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00267ea:	83 c0 1c             	add    $0x1c,%eax
c00267ed:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00267f0:	75 12                	jne    c0026804 <wait+0x74>
c00267f2:	83 ec 0c             	sub    $0xc,%esp
c00267f5:	ff 75 08             	pushl  0x8(%ebp)
c00267f8:	e8 2a fd ff ff       	call   c0026527 <intq_empty>
c00267fd:	83 c4 10             	add    $0x10,%esp
c0026800:	84 c0                	test   %al,%al
c0026802:	75 3b                	jne    c002683f <wait+0xaf>
c0026804:	8b 45 08             	mov    0x8(%ebp),%eax
c0026807:	83 c0 18             	add    $0x18,%eax
c002680a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002680d:	75 12                	jne    c0026821 <wait+0x91>
c002680f:	83 ec 0c             	sub    $0xc,%esp
c0026812:	ff 75 08             	pushl  0x8(%ebp)
c0026815:	e8 4d fd ff ff       	call   c0026567 <intq_full>
c002681a:	83 c4 10             	add    $0x10,%esp
c002681d:	84 c0                	test   %al,%al
c002681f:	75 1e                	jne    c002683f <wait+0xaf>
c0026821:	83 ec 0c             	sub    $0xc,%esp
c0026824:	68 70 03 03 c0       	push   $0xc0030370
c0026829:	68 32 03 03 c0       	push   $0xc0030332
c002682e:	68 58 04 03 c0       	push   $0xc0030458
c0026833:	6a 5c                	push   $0x5c
c0026835:	68 49 03 03 c0       	push   $0xc0030349
c002683a:	e8 e9 2c 00 00       	call   c0029528 <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c002683f:	e8 1f a4 ff ff       	call   c0020c63 <thread_current>
c0026844:	89 c2                	mov    %eax,%edx
c0026846:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026849:	89 10                	mov    %edx,(%eax)
  thread_block ();
c002684b:	e8 f3 a2 ff ff       	call   c0020b43 <thread_block>
}
c0026850:	90                   	nop
c0026851:	c9                   	leave  
c0026852:	c3                   	ret    

c0026853 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026853:	55                   	push   %ebp
c0026854:	89 e5                	mov    %esp,%ebp
c0026856:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026859:	e8 b9 aa ff ff       	call   c0021317 <intr_get_level>
c002685e:	85 c0                	test   %eax,%eax
c0026860:	74 1e                	je     c0026880 <signal+0x2d>
c0026862:	83 ec 0c             	sub    $0xc,%esp
c0026865:	68 14 03 03 c0       	push   $0xc0030314
c002686a:	68 32 03 03 c0       	push   $0xc0030332
c002686f:	68 60 04 03 c0       	push   $0xc0030460
c0026874:	6a 69                	push   $0x69
c0026876:	68 49 03 03 c0       	push   $0xc0030349
c002687b:	e8 a8 2c 00 00       	call   c0029528 <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026880:	8b 45 08             	mov    0x8(%ebp),%eax
c0026883:	83 c0 1c             	add    $0x1c,%eax
c0026886:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026889:	75 15                	jne    c00268a0 <signal+0x4d>
c002688b:	83 ec 0c             	sub    $0xc,%esp
c002688e:	ff 75 08             	pushl  0x8(%ebp)
c0026891:	e8 91 fc ff ff       	call   c0026527 <intq_empty>
c0026896:	83 c4 10             	add    $0x10,%esp
c0026899:	83 f0 01             	xor    $0x1,%eax
c002689c:	84 c0                	test   %al,%al
c002689e:	75 3e                	jne    c00268de <signal+0x8b>
c00268a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00268a3:	83 c0 18             	add    $0x18,%eax
c00268a6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00268a9:	75 15                	jne    c00268c0 <signal+0x6d>
c00268ab:	83 ec 0c             	sub    $0xc,%esp
c00268ae:	ff 75 08             	pushl  0x8(%ebp)
c00268b1:	e8 b1 fc ff ff       	call   c0026567 <intq_full>
c00268b6:	83 c4 10             	add    $0x10,%esp
c00268b9:	83 f0 01             	xor    $0x1,%eax
c00268bc:	84 c0                	test   %al,%al
c00268be:	75 1e                	jne    c00268de <signal+0x8b>
c00268c0:	83 ec 0c             	sub    $0xc,%esp
c00268c3:	68 cc 03 03 c0       	push   $0xc00303cc
c00268c8:	68 32 03 03 c0       	push   $0xc0030332
c00268cd:	68 60 04 03 c0       	push   $0xc0030460
c00268d2:	6a 6b                	push   $0x6b
c00268d4:	68 49 03 03 c0       	push   $0xc0030349
c00268d9:	e8 4a 2c 00 00       	call   c0029528 <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c00268de:	8b 45 0c             	mov    0xc(%ebp),%eax
c00268e1:	8b 00                	mov    (%eax),%eax
c00268e3:	85 c0                	test   %eax,%eax
c00268e5:	74 1a                	je     c0026901 <signal+0xae>
    {
      thread_unblock (*waiter);
c00268e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00268ea:	8b 00                	mov    (%eax),%eax
c00268ec:	83 ec 0c             	sub    $0xc,%esp
c00268ef:	50                   	push   %eax
c00268f0:	e8 bf a2 ff ff       	call   c0020bb4 <thread_unblock>
c00268f5:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c00268f8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00268fb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c0026901:	90                   	nop
c0026902:	c9                   	leave  
c0026903:	c3                   	ret    

c0026904 <inb>:
{
c0026904:	55                   	push   %ebp
c0026905:	89 e5                	mov    %esp,%ebp
c0026907:	83 ec 14             	sub    $0x14,%esp
c002690a:	8b 45 08             	mov    0x8(%ebp),%eax
c002690d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026911:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026914:	89 c2                	mov    %eax,%edx
c0026916:	ec                   	in     (%dx),%al
c0026917:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002691a:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c002691d:	c9                   	leave  
c002691e:	c3                   	ret    

c002691f <outb>:
{
c002691f:	55                   	push   %ebp
c0026920:	89 e5                	mov    %esp,%ebp
c0026922:	83 ec 08             	sub    $0x8,%esp
c0026925:	8b 45 08             	mov    0x8(%ebp),%eax
c0026928:	8b 55 0c             	mov    0xc(%ebp),%edx
c002692b:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c002692f:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026932:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026935:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026938:	ee                   	out    %al,(%dx)
}
c0026939:	90                   	nop
c002693a:	c9                   	leave  
c002693b:	c3                   	ret    

c002693c <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c002693c:	55                   	push   %ebp
c002693d:	89 e5                	mov    %esp,%ebp
c002693f:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c0026942:	83 ec 0c             	sub    $0xc,%esp
c0026945:	6a 00                	push   $0x0
c0026947:	e8 01 02 00 00       	call   c0026b4d <cmos_read>
c002694c:	83 c4 10             	add    $0x10,%esp
c002694f:	0f b6 c0             	movzbl %al,%eax
c0026952:	83 ec 0c             	sub    $0xc,%esp
c0026955:	50                   	push   %eax
c0026956:	e8 c7 01 00 00       	call   c0026b22 <bcd_to_bin>
c002695b:	83 c4 10             	add    $0x10,%esp
c002695e:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c0026961:	83 ec 0c             	sub    $0xc,%esp
c0026964:	6a 02                	push   $0x2
c0026966:	e8 e2 01 00 00       	call   c0026b4d <cmos_read>
c002696b:	83 c4 10             	add    $0x10,%esp
c002696e:	0f b6 c0             	movzbl %al,%eax
c0026971:	83 ec 0c             	sub    $0xc,%esp
c0026974:	50                   	push   %eax
c0026975:	e8 a8 01 00 00       	call   c0026b22 <bcd_to_bin>
c002697a:	83 c4 10             	add    $0x10,%esp
c002697d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c0026980:	83 ec 0c             	sub    $0xc,%esp
c0026983:	6a 04                	push   $0x4
c0026985:	e8 c3 01 00 00       	call   c0026b4d <cmos_read>
c002698a:	83 c4 10             	add    $0x10,%esp
c002698d:	0f b6 c0             	movzbl %al,%eax
c0026990:	83 ec 0c             	sub    $0xc,%esp
c0026993:	50                   	push   %eax
c0026994:	e8 89 01 00 00       	call   c0026b22 <bcd_to_bin>
c0026999:	83 c4 10             	add    $0x10,%esp
c002699c:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c002699f:	83 ec 0c             	sub    $0xc,%esp
c00269a2:	6a 07                	push   $0x7
c00269a4:	e8 a4 01 00 00       	call   c0026b4d <cmos_read>
c00269a9:	83 c4 10             	add    $0x10,%esp
c00269ac:	0f b6 c0             	movzbl %al,%eax
c00269af:	83 ec 0c             	sub    $0xc,%esp
c00269b2:	50                   	push   %eax
c00269b3:	e8 6a 01 00 00       	call   c0026b22 <bcd_to_bin>
c00269b8:	83 c4 10             	add    $0x10,%esp
c00269bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c00269be:	83 ec 0c             	sub    $0xc,%esp
c00269c1:	6a 08                	push   $0x8
c00269c3:	e8 85 01 00 00       	call   c0026b4d <cmos_read>
c00269c8:	83 c4 10             	add    $0x10,%esp
c00269cb:	0f b6 c0             	movzbl %al,%eax
c00269ce:	83 ec 0c             	sub    $0xc,%esp
c00269d1:	50                   	push   %eax
c00269d2:	e8 4b 01 00 00       	call   c0026b22 <bcd_to_bin>
c00269d7:	83 c4 10             	add    $0x10,%esp
c00269da:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c00269dd:	83 ec 0c             	sub    $0xc,%esp
c00269e0:	6a 09                	push   $0x9
c00269e2:	e8 66 01 00 00       	call   c0026b4d <cmos_read>
c00269e7:	83 c4 10             	add    $0x10,%esp
c00269ea:	0f b6 c0             	movzbl %al,%eax
c00269ed:	83 ec 0c             	sub    $0xc,%esp
c00269f0:	50                   	push   %eax
c00269f1:	e8 2c 01 00 00       	call   c0026b22 <bcd_to_bin>
c00269f6:	83 c4 10             	add    $0x10,%esp
c00269f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c00269fc:	83 ec 0c             	sub    $0xc,%esp
c00269ff:	6a 00                	push   $0x0
c0026a01:	e8 47 01 00 00       	call   c0026b4d <cmos_read>
c0026a06:	83 c4 10             	add    $0x10,%esp
c0026a09:	0f b6 c0             	movzbl %al,%eax
c0026a0c:	83 ec 0c             	sub    $0xc,%esp
c0026a0f:	50                   	push   %eax
c0026a10:	e8 0d 01 00 00       	call   c0026b22 <bcd_to_bin>
c0026a15:	83 c4 10             	add    $0x10,%esp
c0026a18:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0026a1b:	0f 85 21 ff ff ff    	jne    c0026942 <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c0026a21:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c0026a25:	7f 04                	jg     c0026a2b <rtc_get_time+0xef>
    year += 100;
c0026a27:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c0026a2b:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c0026a2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0026a32:	89 d0                	mov    %edx,%eax
c0026a34:	c1 e0 03             	shl    $0x3,%eax
c0026a37:	01 d0                	add    %edx,%eax
c0026a39:	c1 e0 03             	shl    $0x3,%eax
c0026a3c:	01 d0                	add    %edx,%eax
c0026a3e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0026a45:	01 c2                	add    %eax,%edx
c0026a47:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a4a:	48                   	dec    %eax
c0026a4b:	85 c0                	test   %eax,%eax
c0026a4d:	79 03                	jns    c0026a52 <rtc_get_time+0x116>
c0026a4f:	83 c0 03             	add    $0x3,%eax
c0026a52:	c1 f8 02             	sar    $0x2,%eax
c0026a55:	01 c2                	add    %eax,%edx
c0026a57:	89 d0                	mov    %edx,%eax
c0026a59:	c1 e0 02             	shl    $0x2,%eax
c0026a5c:	01 d0                	add    %edx,%eax
c0026a5e:	c1 e0 02             	shl    $0x2,%eax
c0026a61:	01 d0                	add    %edx,%eax
c0026a63:	c1 e0 03             	shl    $0x3,%eax
c0026a66:	01 d0                	add    %edx,%eax
c0026a68:	c1 e0 02             	shl    $0x2,%eax
c0026a6b:	29 d0                	sub    %edx,%eax
c0026a6d:	c1 e0 07             	shl    $0x7,%eax
c0026a70:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026a73:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c0026a7a:	eb 2a                	jmp    c0026aa6 <rtc_get_time+0x16a>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c0026a7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026a7f:	48                   	dec    %eax
c0026a80:	8b 14 85 80 04 03 c0 	mov    -0x3ffcfb80(,%eax,4),%edx
c0026a87:	89 d0                	mov    %edx,%eax
c0026a89:	c1 e0 02             	shl    $0x2,%eax
c0026a8c:	01 d0                	add    %edx,%eax
c0026a8e:	c1 e0 02             	shl    $0x2,%eax
c0026a91:	01 d0                	add    %edx,%eax
c0026a93:	c1 e0 03             	shl    $0x3,%eax
c0026a96:	01 d0                	add    %edx,%eax
c0026a98:	c1 e0 02             	shl    $0x2,%eax
c0026a9b:	29 d0                	sub    %edx,%eax
c0026a9d:	c1 e0 07             	shl    $0x7,%eax
c0026aa0:	01 45 f0             	add    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c0026aa3:	ff 45 ec             	incl   -0x14(%ebp)
c0026aa6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026aa9:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0026aac:	7e ce                	jle    c0026a7c <rtc_get_time+0x140>
  if (mon > 2 && year % 4 == 0)
c0026aae:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c0026ab2:	7e 11                	jle    c0026ac5 <rtc_get_time+0x189>
c0026ab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026ab7:	83 e0 03             	and    $0x3,%eax
c0026aba:	85 c0                	test   %eax,%eax
c0026abc:	75 07                	jne    c0026ac5 <rtc_get_time+0x189>
    time += 24 * 60 * 60;
c0026abe:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c0026ac5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0026ac8:	8d 50 ff             	lea    -0x1(%eax),%edx
c0026acb:	89 d0                	mov    %edx,%eax
c0026acd:	c1 e0 02             	shl    $0x2,%eax
c0026ad0:	01 d0                	add    %edx,%eax
c0026ad2:	c1 e0 02             	shl    $0x2,%eax
c0026ad5:	01 d0                	add    %edx,%eax
c0026ad7:	c1 e0 03             	shl    $0x3,%eax
c0026ada:	01 d0                	add    %edx,%eax
c0026adc:	c1 e0 02             	shl    $0x2,%eax
c0026adf:	29 d0                	sub    %edx,%eax
c0026ae1:	c1 e0 07             	shl    $0x7,%eax
c0026ae4:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c0026ae7:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0026aea:	89 d0                	mov    %edx,%eax
c0026aec:	01 c0                	add    %eax,%eax
c0026aee:	01 d0                	add    %edx,%eax
c0026af0:	01 c0                	add    %eax,%eax
c0026af2:	01 d0                	add    %edx,%eax
c0026af4:	c1 e0 05             	shl    $0x5,%eax
c0026af7:	01 d0                	add    %edx,%eax
c0026af9:	c1 e0 04             	shl    $0x4,%eax
c0026afc:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c0026aff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0026b02:	89 d0                	mov    %edx,%eax
c0026b04:	01 c0                	add    %eax,%eax
c0026b06:	01 d0                	add    %edx,%eax
c0026b08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0026b0f:	01 d0                	add    %edx,%eax
c0026b11:	c1 e0 02             	shl    $0x2,%eax
c0026b14:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c0026b17:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0026b1a:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c0026b1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0026b20:	c9                   	leave  
c0026b21:	c3                   	ret    

c0026b22 <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c0026b22:	55                   	push   %ebp
c0026b23:	89 e5                	mov    %esp,%ebp
c0026b25:	83 ec 04             	sub    $0x4,%esp
c0026b28:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b2b:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c0026b2e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026b32:	83 e0 0f             	and    $0xf,%eax
c0026b35:	89 c1                	mov    %eax,%ecx
c0026b37:	8a 45 fc             	mov    -0x4(%ebp),%al
c0026b3a:	c0 e8 04             	shr    $0x4,%al
c0026b3d:	0f b6 d0             	movzbl %al,%edx
c0026b40:	89 d0                	mov    %edx,%eax
c0026b42:	c1 e0 02             	shl    $0x2,%eax
c0026b45:	01 d0                	add    %edx,%eax
c0026b47:	01 c0                	add    %eax,%eax
c0026b49:	01 c8                	add    %ecx,%eax
}
c0026b4b:	c9                   	leave  
c0026b4c:	c3                   	ret    

c0026b4d <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c0026b4d:	55                   	push   %ebp
c0026b4e:	89 e5                	mov    %esp,%ebp
c0026b50:	83 ec 04             	sub    $0x4,%esp
c0026b53:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b56:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c0026b59:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0026b5d:	50                   	push   %eax
c0026b5e:	6a 70                	push   $0x70
c0026b60:	e8 ba fd ff ff       	call   c002691f <outb>
c0026b65:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c0026b68:	6a 71                	push   $0x71
c0026b6a:	e8 95 fd ff ff       	call   c0026904 <inb>
c0026b6f:	83 c4 04             	add    $0x4,%esp
}
c0026b72:	c9                   	leave  
c0026b73:	c3                   	ret    

c0026b74 <inb>:
{
c0026b74:	55                   	push   %ebp
c0026b75:	89 e5                	mov    %esp,%ebp
c0026b77:	83 ec 14             	sub    $0x14,%esp
c0026b7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b7d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026b81:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026b84:	89 c2                	mov    %eax,%edx
c0026b86:	ec                   	in     (%dx),%al
c0026b87:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026b8a:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026b8d:	c9                   	leave  
c0026b8e:	c3                   	ret    

c0026b8f <outb>:
{
c0026b8f:	55                   	push   %ebp
c0026b90:	89 e5                	mov    %esp,%ebp
c0026b92:	83 ec 08             	sub    $0x8,%esp
c0026b95:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b98:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026b9b:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026b9f:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026ba2:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026ba8:	ee                   	out    %al,(%dx)
}
c0026ba9:	90                   	nop
c0026baa:	c9                   	leave  
c0026bab:	c3                   	ret    

c0026bac <outw>:
{
c0026bac:	55                   	push   %ebp
c0026bad:	89 e5                	mov    %esp,%ebp
c0026baf:	83 ec 08             	sub    $0x8,%esp
c0026bb2:	8b 55 08             	mov    0x8(%ebp),%edx
c0026bb5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026bb8:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026bbc:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0026bc0:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0026bc3:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026bc6:	66 ef                	out    %ax,(%dx)
}
c0026bc8:	90                   	nop
c0026bc9:	c9                   	leave  
c0026bca:	c3                   	ret    

c0026bcb <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0026bcb:	55                   	push   %ebp
c0026bcc:	89 e5                	mov    %esp,%ebp
c0026bce:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c0026bd1:	a1 c8 8a 03 c0       	mov    0xc0038ac8,%eax
c0026bd6:	83 f8 01             	cmp    $0x1,%eax
c0026bd9:	74 07                	je     c0026be2 <shutdown+0x17>
c0026bdb:	83 f8 02             	cmp    $0x2,%eax
c0026bde:	74 07                	je     c0026be7 <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0026be0:	eb 0a                	jmp    c0026bec <shutdown+0x21>
      shutdown_power_off ();
c0026be2:	e8 9c 00 00 00       	call   c0026c83 <shutdown_power_off>
      shutdown_reboot ();
c0026be7:	e8 11 00 00 00       	call   c0026bfd <shutdown_reboot>
    }
}
c0026bec:	90                   	nop
c0026bed:	c9                   	leave  
c0026bee:	c3                   	ret    

c0026bef <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0026bef:	55                   	push   %ebp
c0026bf0:	89 e5                	mov    %esp,%ebp
  how = type;
c0026bf2:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bf5:	a3 c8 8a 03 c0       	mov    %eax,0xc0038ac8
}
c0026bfa:	90                   	nop
c0026bfb:	5d                   	pop    %ebp
c0026bfc:	c3                   	ret    

c0026bfd <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0026bfd:	55                   	push   %ebp
c0026bfe:	89 e5                	mov    %esp,%ebp
c0026c00:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c0026c03:	83 ec 0c             	sub    $0xc,%esp
c0026c06:	68 b0 04 03 c0       	push   $0xc00304b0
c0026c0b:	e8 d9 4a 00 00       	call   c002b6e9 <puts>
c0026c10:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0026c13:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026c1a:	eb 29                	jmp    c0026c45 <shutdown_reboot+0x48>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0026c1c:	83 ec 0c             	sub    $0xc,%esp
c0026c1f:	6a 64                	push   $0x64
c0026c21:	e8 4e ff ff ff       	call   c0026b74 <inb>
c0026c26:	83 c4 10             	add    $0x10,%esp
c0026c29:	0f b6 c0             	movzbl %al,%eax
c0026c2c:	83 e0 02             	and    $0x2,%eax
c0026c2f:	85 c0                	test   %eax,%eax
c0026c31:	74 1d                	je     c0026c50 <shutdown_reboot+0x53>
            break;
          timer_udelay (2);
c0026c33:	83 ec 08             	sub    $0x8,%esp
c0026c36:	6a 00                	push   $0x0
c0026c38:	6a 02                	push   $0x2
c0026c3a:	e8 cc d1 ff ff       	call   c0023e0b <timer_udelay>
c0026c3f:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 0x10000; i++)
c0026c42:	ff 45 f4             	incl   -0xc(%ebp)
c0026c45:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c0026c4c:	7e ce                	jle    c0026c1c <shutdown_reboot+0x1f>
c0026c4e:	eb 01                	jmp    c0026c51 <shutdown_reboot+0x54>
            break;
c0026c50:	90                   	nop
        }

      timer_udelay (50);
c0026c51:	83 ec 08             	sub    $0x8,%esp
c0026c54:	6a 00                	push   $0x0
c0026c56:	6a 32                	push   $0x32
c0026c58:	e8 ae d1 ff ff       	call   c0023e0b <timer_udelay>
c0026c5d:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c0026c60:	83 ec 08             	sub    $0x8,%esp
c0026c63:	68 fe 00 00 00       	push   $0xfe
c0026c68:	6a 64                	push   $0x64
c0026c6a:	e8 20 ff ff ff       	call   c0026b8f <outb>
c0026c6f:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c0026c72:	83 ec 08             	sub    $0x8,%esp
c0026c75:	6a 00                	push   $0x0
c0026c77:	6a 32                	push   $0x32
c0026c79:	e8 8d d1 ff ff       	call   c0023e0b <timer_udelay>
c0026c7e:	83 c4 10             	add    $0x10,%esp
    {
c0026c81:	eb 90                	jmp    c0026c13 <shutdown_reboot+0x16>

c0026c83 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c0026c83:	55                   	push   %ebp
c0026c84:	89 e5                	mov    %esp,%ebp
c0026c86:	57                   	push   %edi
c0026c87:	56                   	push   %esi
c0026c88:	53                   	push   %ebx
c0026c89:	83 ec 1c             	sub    $0x1c,%esp
  const char s[] = "Shutdown";
c0026c8c:	8d 45 db             	lea    -0x25(%ebp),%eax
c0026c8f:	bb de 04 03 c0       	mov    $0xc00304de,%ebx
c0026c94:	ba 09 00 00 00       	mov    $0x9,%edx
c0026c99:	89 c7                	mov    %eax,%edi
c0026c9b:	89 de                	mov    %ebx,%esi
c0026c9d:	89 d1                	mov    %edx,%ecx
c0026c9f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)

#ifdef FILESYS
  filesys_done ();
#endif

  print_stats ();
c0026ca1:	e8 7d 00 00 00       	call   c0026d23 <print_stats>

  printf ("Powering off...\n");
c0026ca6:	83 ec 0c             	sub    $0xc,%esp
c0026ca9:	68 bd 04 03 c0       	push   $0xc00304bd
c0026cae:	e8 36 4a 00 00       	call   c002b6e9 <puts>
c0026cb3:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0026cb6:	e8 79 dd ff ff       	call   c0024a34 <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c0026cbb:	83 ec 08             	sub    $0x8,%esp
c0026cbe:	68 00 20 00 00       	push   $0x2000
c0026cc3:	68 04 b0 00 00       	push   $0xb004
c0026cc8:	e8 df fe ff ff       	call   c0026bac <outw>
c0026ccd:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0026cd0:	8d 45 db             	lea    -0x25(%ebp),%eax
c0026cd3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0026cd6:	eb 1c                	jmp    c0026cf4 <shutdown_power_off+0x71>
    outb (0x8900, *p);
c0026cd8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026cdb:	8a 00                	mov    (%eax),%al
c0026cdd:	0f b6 c0             	movzbl %al,%eax
c0026ce0:	83 ec 08             	sub    $0x8,%esp
c0026ce3:	50                   	push   %eax
c0026ce4:	68 00 89 00 00       	push   $0x8900
c0026ce9:	e8 a1 fe ff ff       	call   c0026b8f <outb>
c0026cee:	83 c4 10             	add    $0x10,%esp
  for (p = s; *p != '\0'; p++)
c0026cf1:	ff 45 e4             	incl   -0x1c(%ebp)
c0026cf4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0026cf7:	8a 00                	mov    (%eax),%al
c0026cf9:	84 c0                	test   %al,%al
c0026cfb:	75 db                	jne    c0026cd8 <shutdown_power_off+0x55>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0026cfd:	83 ec 08             	sub    $0x8,%esp
c0026d00:	6a 31                	push   $0x31
c0026d02:	68 01 05 00 00       	push   $0x501
c0026d07:	e8 83 fe ff ff       	call   c0026b8f <outb>
c0026d0c:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c0026d0f:	fa                   	cli    
c0026d10:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c0026d11:	83 ec 0c             	sub    $0xc,%esp
c0026d14:	68 cd 04 03 c0       	push   $0xc00304cd
c0026d19:	e8 cb 49 00 00       	call   c002b6e9 <puts>
c0026d1e:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0026d21:	eb fe                	jmp    c0026d21 <shutdown_power_off+0x9e>

c0026d23 <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c0026d23:	55                   	push   %ebp
c0026d24:	89 e5                	mov    %esp,%ebp
c0026d26:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c0026d29:	e8 33 d1 ff ff       	call   c0023e61 <timer_print_stats>
  thread_print_stats ();
c0026d2e:	e8 cc 9c ff ff       	call   c00209ff <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0026d33:	e8 85 48 00 00       	call   c002b5bd <console_print_stats>
  kbd_print_stats ();
c0026d38:	e8 32 d4 ff ff       	call   c002416f <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
#endif
}
c0026d3d:	90                   	nop
c0026d3e:	c9                   	leave  
c0026d3f:	c3                   	ret    

c0026d40 <inb>:
{
c0026d40:	55                   	push   %ebp
c0026d41:	89 e5                	mov    %esp,%ebp
c0026d43:	83 ec 14             	sub    $0x14,%esp
c0026d46:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d49:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026d4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0026d50:	89 c2                	mov    %eax,%edx
c0026d52:	ec                   	in     (%dx),%al
c0026d53:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026d56:	8a 45 ff             	mov    -0x1(%ebp),%al
}
c0026d59:	c9                   	leave  
c0026d5a:	c3                   	ret    

c0026d5b <outb>:
{
c0026d5b:	55                   	push   %ebp
c0026d5c:	89 e5                	mov    %esp,%ebp
c0026d5e:	83 ec 08             	sub    $0x8,%esp
c0026d61:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d64:	8b 55 0c             	mov    0xc(%ebp),%edx
c0026d67:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
c0026d6b:	88 55 f8             	mov    %dl,-0x8(%ebp)
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026d6e:	8a 45 f8             	mov    -0x8(%ebp),%al
c0026d71:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026d74:	ee                   	out    %al,(%dx)
}
c0026d75:	90                   	nop
c0026d76:	c9                   	leave  
c0026d77:	c3                   	ret    

c0026d78 <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c0026d78:	55                   	push   %ebp
c0026d79:	89 e5                	mov    %esp,%ebp
c0026d7b:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c0026d7e:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c0026d82:	7e 54                	jle    c0026dd8 <speaker_on+0x60>
c0026d84:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c0026d8b:	7f 4b                	jg     c0026dd8 <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c0026d8d:	e8 fa a5 ff ff       	call   c002138c <intr_disable>
c0026d92:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c0026d95:	83 ec 04             	sub    $0x4,%esp
c0026d98:	ff 75 08             	pushl  0x8(%ebp)
c0026d9b:	6a 03                	push   $0x3
c0026d9d:	6a 02                	push   $0x2
c0026d9f:	e8 aa cc ff ff       	call   c0023a4e <pit_configure_channel>
c0026da4:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c0026da7:	83 ec 0c             	sub    $0xc,%esp
c0026daa:	6a 61                	push   $0x61
c0026dac:	e8 8f ff ff ff       	call   c0026d40 <inb>
c0026db1:	83 c4 10             	add    $0x10,%esp
c0026db4:	83 c8 03             	or     $0x3,%eax
c0026db7:	0f b6 c0             	movzbl %al,%eax
c0026dba:	83 ec 08             	sub    $0x8,%esp
c0026dbd:	50                   	push   %eax
c0026dbe:	6a 61                	push   $0x61
c0026dc0:	e8 96 ff ff ff       	call   c0026d5b <outb>
c0026dc5:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c0026dc8:	83 ec 0c             	sub    $0xc,%esp
c0026dcb:	ff 75 f4             	pushl  -0xc(%ebp)
c0026dce:	e8 61 a5 ff ff       	call   c0021334 <intr_set_level>
c0026dd3:	83 c4 10             	add    $0x10,%esp
    {
c0026dd6:	eb 05                	jmp    c0026ddd <speaker_on+0x65>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c0026dd8:	e8 03 00 00 00       	call   c0026de0 <speaker_off>
    }
}
c0026ddd:	90                   	nop
c0026dde:	c9                   	leave  
c0026ddf:	c3                   	ret    

c0026de0 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0026de0:	55                   	push   %ebp
c0026de1:	89 e5                	mov    %esp,%ebp
c0026de3:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0026de6:	e8 a1 a5 ff ff       	call   c002138c <intr_disable>
c0026deb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0026dee:	83 ec 0c             	sub    $0xc,%esp
c0026df1:	6a 61                	push   $0x61
c0026df3:	e8 48 ff ff ff       	call   c0026d40 <inb>
c0026df8:	83 c4 10             	add    $0x10,%esp
c0026dfb:	0f b6 c0             	movzbl %al,%eax
c0026dfe:	25 fc 00 00 00       	and    $0xfc,%eax
c0026e03:	83 ec 08             	sub    $0x8,%esp
c0026e06:	50                   	push   %eax
c0026e07:	6a 61                	push   $0x61
c0026e09:	e8 4d ff ff ff       	call   c0026d5b <outb>
c0026e0e:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0026e11:	83 ec 0c             	sub    $0xc,%esp
c0026e14:	ff 75 f4             	pushl  -0xc(%ebp)
c0026e17:	e8 18 a5 ff ff       	call   c0021334 <intr_set_level>
c0026e1c:	83 c4 10             	add    $0x10,%esp
}
c0026e1f:	90                   	nop
c0026e20:	c9                   	leave  
c0026e21:	c3                   	ret    

c0026e22 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0026e22:	55                   	push   %ebp
c0026e23:	89 e5                	mov    %esp,%ebp
c0026e25:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c0026e28:	e8 ea a4 ff ff       	call   c0021317 <intr_get_level>
c0026e2d:	83 f8 01             	cmp    $0x1,%eax
c0026e30:	75 27                	jne    c0026e59 <speaker_beep+0x37>
    {
      speaker_on (440);
c0026e32:	83 ec 0c             	sub    $0xc,%esp
c0026e35:	68 b8 01 00 00       	push   $0x1b8
c0026e3a:	e8 39 ff ff ff       	call   c0026d78 <speaker_on>
c0026e3f:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c0026e42:	83 ec 08             	sub    $0x8,%esp
c0026e45:	6a 00                	push   $0x0
c0026e47:	68 fa 00 00 00       	push   $0xfa
c0026e4c:	e8 0e cf ff ff       	call   c0023d5f <timer_msleep>
c0026e51:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c0026e54:	e8 87 ff ff ff       	call   c0026de0 <speaker_off>
    }
}
c0026e59:	90                   	nop
c0026e5a:	c9                   	leave  
c0026e5b:	c3                   	ret    

c0026e5c <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c0026e5c:	55                   	push   %ebp
c0026e5d:	89 e5                	mov    %esp,%ebp
c0026e5f:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c0026e62:	8b 45 04             	mov    0x4(%ebp),%eax
c0026e65:	83 ec 08             	sub    $0x8,%esp
c0026e68:	50                   	push   %eax
c0026e69:	68 e8 04 03 c0       	push   $0xc00304e8
c0026e6e:	e8 f6 02 00 00       	call   c0027169 <printf>
c0026e73:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c0026e76:	8b 45 00             	mov    0x0(%ebp),%eax
c0026e79:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0026e7c:	eb 21                	jmp    c0026e9f <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c0026e7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026e81:	83 c0 04             	add    $0x4,%eax
c0026e84:	8b 00                	mov    (%eax),%eax
c0026e86:	83 ec 08             	sub    $0x8,%esp
c0026e89:	50                   	push   %eax
c0026e8a:	68 f7 04 03 c0       	push   $0xc00304f7
c0026e8f:	e8 d5 02 00 00       	call   c0027169 <printf>
c0026e94:	83 c4 10             	add    $0x10,%esp
       frame = frame[0]) 
c0026e97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026e9a:	8b 00                	mov    (%eax),%eax
c0026e9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026e9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  for (frame = __builtin_frame_address (1);
c0026ea2:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0026ea7:	76 09                	jbe    c0026eb2 <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0026ea9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026eac:	8b 00                	mov    (%eax),%eax
c0026eae:	85 c0                	test   %eax,%eax
c0026eb0:	75 cc                	jne    c0026e7e <debug_backtrace+0x22>
  printf (".\n");
c0026eb2:	83 ec 0c             	sub    $0xc,%esp
c0026eb5:	68 fb 04 03 c0       	push   $0xc00304fb
c0026eba:	e8 2a 48 00 00       	call   c002b6e9 <puts>
c0026ebf:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0026ec2:	a0 cc 8a 03 c0       	mov    0xc0038acc,%al
c0026ec7:	83 f0 01             	xor    $0x1,%eax
c0026eca:	84 c0                	test   %al,%al
c0026ecc:	74 17                	je     c0026ee5 <debug_backtrace+0x89>
    {
      explained = true;
c0026ece:	c6 05 cc 8a 03 c0 01 	movb   $0x1,0xc0038acc
      printf ("The `backtrace' program can make call stacks useful.\n"
c0026ed5:	83 ec 0c             	sub    $0xc,%esp
c0026ed8:	68 00 05 03 c0       	push   $0xc0030500
c0026edd:	e8 07 48 00 00       	call   c002b6e9 <puts>
c0026ee2:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c0026ee5:	90                   	nop
c0026ee6:	c9                   	leave  
c0026ee7:	c3                   	ret    

c0026ee8 <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c0026ee8:	55                   	push   %ebp
c0026ee9:	89 e5                	mov    %esp,%ebp
c0026eeb:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c0026eee:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ef1:	8a 00                	mov    (%eax),%al
c0026ef3:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c0026ef6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026ef9:	8a 10                	mov    (%eax),%dl
c0026efb:	8b 45 08             	mov    0x8(%ebp),%eax
c0026efe:	88 10                	mov    %dl,(%eax)
  *b = t;
c0026f00:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f03:	8a 55 ff             	mov    -0x1(%ebp),%dl
c0026f06:	88 10                	mov    %dl,(%eax)
}
c0026f08:	90                   	nop
c0026f09:	c9                   	leave  
c0026f0a:	c3                   	ret    

c0026f0b <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0026f0b:	55                   	push   %ebp
c0026f0c:	89 e5                	mov    %esp,%ebp
c0026f0e:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c0026f11:	8d 45 08             	lea    0x8(%ebp),%eax
c0026f14:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0026f17:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0026f1e:	eb 12                	jmp    c0026f32 <random_init+0x27>
    s[i] = i;
c0026f20:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f23:	88 c2                	mov    %al,%dl
c0026f25:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f28:	05 e0 8a 03 c0       	add    $0xc0038ae0,%eax
c0026f2d:	88 10                	mov    %dl,(%eax)
  for (i = 0; i < 256; i++) 
c0026f2f:	ff 45 fc             	incl   -0x4(%ebp)
c0026f32:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0026f39:	7e e5                	jle    c0026f20 <random_init+0x15>
  for (i = j = 0; i < 256; i++) 
c0026f3b:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c0026f3f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0026f46:	eb 3d                	jmp    c0026f85 <random_init+0x7a>
    {
      j += s[i] + seedp[i % sizeof seed];
c0026f48:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f4b:	05 e0 8a 03 c0       	add    $0xc0038ae0,%eax
c0026f50:	8a 10                	mov    (%eax),%dl
c0026f52:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f55:	83 e0 03             	and    $0x3,%eax
c0026f58:	89 c1                	mov    %eax,%ecx
c0026f5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026f5d:	01 c8                	add    %ecx,%eax
c0026f5f:	8a 00                	mov    (%eax),%al
c0026f61:	01 d0                	add    %edx,%eax
c0026f63:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c0026f66:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0026f6a:	8d 90 e0 8a 03 c0    	lea    -0x3ffc7520(%eax),%edx
c0026f70:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026f73:	05 e0 8a 03 c0       	add    $0xc0038ae0,%eax
c0026f78:	52                   	push   %edx
c0026f79:	50                   	push   %eax
c0026f7a:	e8 69 ff ff ff       	call   c0026ee8 <swap_byte>
c0026f7f:	83 c4 08             	add    $0x8,%esp
  for (i = j = 0; i < 256; i++) 
c0026f82:	ff 45 fc             	incl   -0x4(%ebp)
c0026f85:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0026f8c:	7e ba                	jle    c0026f48 <random_init+0x3d>
    }

  s_i = s_j = 0;
c0026f8e:	c6 05 e1 8b 03 c0 00 	movb   $0x0,0xc0038be1
c0026f95:	a0 e1 8b 03 c0       	mov    0xc0038be1,%al
c0026f9a:	a2 e0 8b 03 c0       	mov    %al,0xc0038be0
  inited = true;
c0026f9f:	c6 05 e2 8b 03 c0 01 	movb   $0x1,0xc0038be2
}
c0026fa6:	90                   	nop
c0026fa7:	c9                   	leave  
c0026fa8:	c3                   	ret    

c0026fa9 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c0026fa9:	55                   	push   %ebp
c0026faa:	89 e5                	mov    %esp,%ebp
c0026fac:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c0026faf:	a0 e2 8b 03 c0       	mov    0xc0038be2,%al
c0026fb4:	83 f0 01             	xor    $0x1,%eax
c0026fb7:	84 c0                	test   %al,%al
c0026fb9:	74 0a                	je     c0026fc5 <random_bytes+0x1c>
    random_init (0);
c0026fbb:	6a 00                	push   $0x0
c0026fbd:	e8 49 ff ff ff       	call   c0026f0b <random_init>
c0026fc2:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c0026fc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0026fc8:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0026fcb:	eb 7d                	jmp    c002704a <random_bytes+0xa1>
    {
      uint8_t s_k;
      
      s_i++;
c0026fcd:	a0 e0 8b 03 c0       	mov    0xc0038be0,%al
c0026fd2:	40                   	inc    %eax
c0026fd3:	a2 e0 8b 03 c0       	mov    %al,0xc0038be0
      s_j += s[s_i];
c0026fd8:	a0 e0 8b 03 c0       	mov    0xc0038be0,%al
c0026fdd:	0f b6 c0             	movzbl %al,%eax
c0026fe0:	8a 90 e0 8a 03 c0    	mov    -0x3ffc7520(%eax),%dl
c0026fe6:	a0 e1 8b 03 c0       	mov    0xc0038be1,%al
c0026feb:	01 d0                	add    %edx,%eax
c0026fed:	a2 e1 8b 03 c0       	mov    %al,0xc0038be1
      swap_byte (s + s_i, s + s_j);
c0026ff2:	a0 e1 8b 03 c0       	mov    0xc0038be1,%al
c0026ff7:	0f b6 c0             	movzbl %al,%eax
c0026ffa:	8d 90 e0 8a 03 c0    	lea    -0x3ffc7520(%eax),%edx
c0027000:	a0 e0 8b 03 c0       	mov    0xc0038be0,%al
c0027005:	0f b6 c0             	movzbl %al,%eax
c0027008:	05 e0 8a 03 c0       	add    $0xc0038ae0,%eax
c002700d:	52                   	push   %edx
c002700e:	50                   	push   %eax
c002700f:	e8 d4 fe ff ff       	call   c0026ee8 <swap_byte>
c0027014:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c0027017:	a0 e0 8b 03 c0       	mov    0xc0038be0,%al
c002701c:	0f b6 c0             	movzbl %al,%eax
c002701f:	8a 90 e0 8a 03 c0    	mov    -0x3ffc7520(%eax),%dl
c0027025:	a0 e1 8b 03 c0       	mov    0xc0038be1,%al
c002702a:	0f b6 c0             	movzbl %al,%eax
c002702d:	8a 80 e0 8a 03 c0    	mov    -0x3ffc7520(%eax),%al
c0027033:	01 d0                	add    %edx,%eax
c0027035:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c0027038:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c002703c:	8a 90 e0 8a 03 c0    	mov    -0x3ffc7520(%eax),%dl
c0027042:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027045:	88 10                	mov    %dl,(%eax)
  for (buf = buf_; size-- > 0; buf++)
c0027047:	ff 45 fc             	incl   -0x4(%ebp)
c002704a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002704d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027050:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027053:	85 c0                	test   %eax,%eax
c0027055:	0f 85 72 ff ff ff    	jne    c0026fcd <random_bytes+0x24>
    }
}
c002705b:	90                   	nop
c002705c:	c9                   	leave  
c002705d:	c3                   	ret    

c002705e <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c002705e:	55                   	push   %ebp
c002705f:	89 e5                	mov    %esp,%ebp
c0027061:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c0027064:	6a 04                	push   $0x4
c0027066:	8d 45 fc             	lea    -0x4(%ebp),%eax
c0027069:	50                   	push   %eax
c002706a:	e8 3a ff ff ff       	call   c0026fa9 <random_bytes>
c002706f:	83 c4 08             	add    $0x8,%esp
  return ul;
c0027072:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0027075:	c9                   	leave  
c0027076:	c3                   	ret    

c0027077 <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027077:	55                   	push   %ebp
c0027078:	89 e5                	mov    %esp,%ebp
c002707a:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c002707e:	7e 0d                	jle    c002708d <isdigit+0x16>
c0027080:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027084:	7f 07                	jg     c002708d <isdigit+0x16>
c0027086:	b8 01 00 00 00       	mov    $0x1,%eax
c002708b:	eb 05                	jmp    c0027092 <isdigit+0x1b>
c002708d:	b8 00 00 00 00       	mov    $0x0,%eax
c0027092:	5d                   	pop    %ebp
c0027093:	c3                   	ret    

c0027094 <isprint>:
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027094:	55                   	push   %ebp
c0027095:	89 e5                	mov    %esp,%ebp
c0027097:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c002709b:	7e 0d                	jle    c00270aa <isprint+0x16>
c002709d:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c00270a1:	7f 07                	jg     c00270aa <isprint+0x16>
c00270a3:	b8 01 00 00 00       	mov    $0x1,%eax
c00270a8:	eb 05                	jmp    c00270af <isprint+0x1b>
c00270aa:	b8 00 00 00 00       	mov    $0x0,%eax
c00270af:	5d                   	pop    %ebp
c00270b0:	c3                   	ret    

c00270b1 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c00270b1:	55                   	push   %ebp
c00270b2:	89 e5                	mov    %esp,%ebp
c00270b4:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c00270b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00270ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c00270bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00270c4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00270c8:	74 06                	je     c00270d0 <vsnprintf+0x1f>
c00270ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c00270cd:	48                   	dec    %eax
c00270ce:	eb 05                	jmp    c00270d5 <vsnprintf+0x24>
c00270d0:	b8 00 00 00 00       	mov    $0x0,%eax
c00270d5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c00270d8:	8d 45 ec             	lea    -0x14(%ebp),%eax
c00270db:	50                   	push   %eax
c00270dc:	68 00 71 02 c0       	push   $0xc0027100
c00270e1:	ff 75 14             	pushl  0x14(%ebp)
c00270e4:	ff 75 10             	pushl  0x10(%ebp)
c00270e7:	e8 a3 00 00 00       	call   c002718f <__vprintf>
c00270ec:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c00270ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00270f3:	74 06                	je     c00270fb <vsnprintf+0x4a>
    *aux.p = '\0';
c00270f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00270f8:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c00270fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00270fe:	c9                   	leave  
c00270ff:	c3                   	ret    

c0027100 <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c0027100:	55                   	push   %ebp
c0027101:	89 e5                	mov    %esp,%ebp
c0027103:	83 ec 14             	sub    $0x14,%esp
c0027106:	8b 45 08             	mov    0x8(%ebp),%eax
c0027109:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c002710c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002710f:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c0027112:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027115:	8b 40 04             	mov    0x4(%eax),%eax
c0027118:	8d 48 01             	lea    0x1(%eax),%ecx
c002711b:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002711e:	89 4a 04             	mov    %ecx,0x4(%edx)
c0027121:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027124:	8b 52 08             	mov    0x8(%edx),%edx
c0027127:	39 d0                	cmp    %edx,%eax
c0027129:	7d 12                	jge    c002713d <vsnprintf_helper+0x3d>
    *aux->p++ = ch;
c002712b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002712e:	8b 00                	mov    (%eax),%eax
c0027130:	8d 48 01             	lea    0x1(%eax),%ecx
c0027133:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0027136:	89 0a                	mov    %ecx,(%edx)
c0027138:	8a 55 ec             	mov    -0x14(%ebp),%dl
c002713b:	88 10                	mov    %dl,(%eax)
}
c002713d:	90                   	nop
c002713e:	c9                   	leave  
c002713f:	c3                   	ret    

c0027140 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c0027140:	55                   	push   %ebp
c0027141:	89 e5                	mov    %esp,%ebp
c0027143:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c0027146:	8d 45 14             	lea    0x14(%ebp),%eax
c0027149:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c002714c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002714f:	50                   	push   %eax
c0027150:	ff 75 10             	pushl  0x10(%ebp)
c0027153:	ff 75 0c             	pushl  0xc(%ebp)
c0027156:	ff 75 08             	pushl  0x8(%ebp)
c0027159:	e8 53 ff ff ff       	call   c00270b1 <vsnprintf>
c002715e:	83 c4 10             	add    $0x10,%esp
c0027161:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0027164:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0027167:	c9                   	leave  
c0027168:	c3                   	ret    

c0027169 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c0027169:	55                   	push   %ebp
c002716a:	89 e5                	mov    %esp,%ebp
c002716c:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c002716f:	8d 45 0c             	lea    0xc(%ebp),%eax
c0027172:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c0027175:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027178:	83 ec 08             	sub    $0x8,%esp
c002717b:	50                   	push   %eax
c002717c:	ff 75 08             	pushl  0x8(%ebp)
c002717f:	e8 32 45 00 00       	call   c002b6b6 <vprintf>
c0027184:	83 c4 10             	add    $0x10,%esp
c0027187:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c002718a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002718d:	c9                   	leave  
c002718e:	c3                   	ret    

c002718f <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c002718f:	55                   	push   %ebp
c0027190:	89 e5                	mov    %esp,%ebp
c0027192:	53                   	push   %ebx
c0027193:	83 ec 34             	sub    $0x34,%esp
  for (; *format != '\0'; format++)
c0027196:	e9 25 04 00 00       	jmp    c00275c0 <__vprintf+0x431>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c002719b:	8b 45 08             	mov    0x8(%ebp),%eax
c002719e:	8a 00                	mov    (%eax),%al
c00271a0:	3c 25                	cmp    $0x25,%al
c00271a2:	74 1c                	je     c00271c0 <__vprintf+0x31>
        {
          output (*format, aux);
c00271a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00271a7:	8a 00                	mov    (%eax),%al
c00271a9:	0f be c0             	movsbl %al,%eax
c00271ac:	83 ec 08             	sub    $0x8,%esp
c00271af:	ff 75 14             	pushl  0x14(%ebp)
c00271b2:	50                   	push   %eax
c00271b3:	8b 45 10             	mov    0x10(%ebp),%eax
c00271b6:	ff d0                	call   *%eax
c00271b8:	83 c4 10             	add    $0x10,%esp
          continue;
c00271bb:	e9 fd 03 00 00       	jmp    c00275bd <__vprintf+0x42e>
        }
      format++;
c00271c0:	ff 45 08             	incl   0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c00271c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00271c6:	8a 00                	mov    (%eax),%al
c00271c8:	3c 25                	cmp    $0x25,%al
c00271ca:	75 15                	jne    c00271e1 <__vprintf+0x52>
        {
          output ('%', aux);
c00271cc:	83 ec 08             	sub    $0x8,%esp
c00271cf:	ff 75 14             	pushl  0x14(%ebp)
c00271d2:	6a 25                	push   $0x25
c00271d4:	8b 45 10             	mov    0x10(%ebp),%eax
c00271d7:	ff d0                	call   *%eax
c00271d9:	83 c4 10             	add    $0x10,%esp
          continue;
c00271dc:	e9 dc 03 00 00       	jmp    c00275bd <__vprintf+0x42e>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c00271e1:	83 ec 04             	sub    $0x4,%esp
c00271e4:	8d 45 0c             	lea    0xc(%ebp),%eax
c00271e7:	50                   	push   %eax
c00271e8:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00271eb:	50                   	push   %eax
c00271ec:	ff 75 08             	pushl  0x8(%ebp)
c00271ef:	e8 df 03 00 00       	call   c00275d3 <parse_conversion>
c00271f4:	83 c4 10             	add    $0x10,%esp
c00271f7:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c00271fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00271fd:	8a 00                	mov    (%eax),%al
c00271ff:	0f be c0             	movsbl %al,%eax
c0027202:	83 e8 45             	sub    $0x45,%eax
c0027205:	83 f8 33             	cmp    $0x33,%eax
c0027208:	0f 87 92 03 00 00    	ja     c00275a0 <__vprintf+0x411>
c002720e:	8b 04 85 84 06 03 c0 	mov    -0x3ffcf97c(,%eax,4),%eax
c0027215:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c0027217:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002721a:	83 f8 08             	cmp    $0x8,%eax
c002721d:	0f 87 d8 00 00 00    	ja     c00272fb <__vprintf+0x16c>
c0027223:	8b 04 85 54 07 03 c0 	mov    -0x3ffcf8ac(,%eax,4),%eax
c002722a:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c002722c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002722f:	8d 50 04             	lea    0x4(%eax),%edx
c0027232:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027235:	8b 00                	mov    (%eax),%eax
c0027237:	0f be c0             	movsbl %al,%eax
c002723a:	99                   	cltd   
c002723b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002723e:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027241:	e9 cf 00 00 00       	jmp    c0027315 <__vprintf+0x186>
              case SHORT:
                value = (short) va_arg (args, int);
c0027246:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027249:	8d 50 04             	lea    0x4(%eax),%edx
c002724c:	89 55 0c             	mov    %edx,0xc(%ebp)
c002724f:	8b 00                	mov    (%eax),%eax
c0027251:	98                   	cwtl   
c0027252:	99                   	cltd   
c0027253:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027256:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027259:	e9 b7 00 00 00       	jmp    c0027315 <__vprintf+0x186>
              case INT:
                value = va_arg (args, int);
c002725e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027261:	8d 50 04             	lea    0x4(%eax),%edx
c0027264:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027267:	8b 00                	mov    (%eax),%eax
c0027269:	99                   	cltd   
c002726a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002726d:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027270:	e9 a0 00 00 00       	jmp    c0027315 <__vprintf+0x186>
              case INTMAX:
                value = va_arg (args, intmax_t);
c0027275:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027278:	8d 50 08             	lea    0x8(%eax),%edx
c002727b:	89 55 0c             	mov    %edx,0xc(%ebp)
c002727e:	8b 50 04             	mov    0x4(%eax),%edx
c0027281:	8b 00                	mov    (%eax),%eax
c0027283:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0027286:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c0027289:	e9 87 00 00 00       	jmp    c0027315 <__vprintf+0x186>
              case LONG:
                value = va_arg (args, long);
c002728e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027291:	8d 50 04             	lea    0x4(%eax),%edx
c0027294:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027297:	8b 00                	mov    (%eax),%eax
c0027299:	99                   	cltd   
c002729a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002729d:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00272a0:	eb 73                	jmp    c0027315 <__vprintf+0x186>
              case LONGLONG:
                value = va_arg (args, long long);
c00272a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272a5:	8d 50 08             	lea    0x8(%eax),%edx
c00272a8:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272ab:	8b 50 04             	mov    0x4(%eax),%edx
c00272ae:	8b 00                	mov    (%eax),%eax
c00272b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00272b3:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00272b6:	eb 5d                	jmp    c0027315 <__vprintf+0x186>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c00272b8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272bb:	8d 50 04             	lea    0x4(%eax),%edx
c00272be:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272c1:	8b 00                	mov    (%eax),%eax
c00272c3:	99                   	cltd   
c00272c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00272c7:	89 55 f4             	mov    %edx,-0xc(%ebp)
                break;
c00272ca:	eb 49                	jmp    c0027315 <__vprintf+0x186>
              case SIZET:
                value = va_arg (args, size_t);
c00272cc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00272cf:	8d 50 04             	lea    0x4(%eax),%edx
c00272d2:	89 55 0c             	mov    %edx,0xc(%ebp)
c00272d5:	8b 00                	mov    (%eax),%eax
c00272d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00272da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
                if (value > SIZE_MAX / 2)
c00272e1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00272e5:	78 2d                	js     c0027314 <__vprintf+0x185>
c00272e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00272eb:	7f 09                	jg     c00272f6 <__vprintf+0x167>
c00272ed:	81 7d f0 ff ff ff 7f 	cmpl   $0x7fffffff,-0x10(%ebp)
c00272f4:	76 1e                	jbe    c0027314 <__vprintf+0x185>
                  value = value - SIZE_MAX - 1;
c00272f6:	ff 4d f4             	decl   -0xc(%ebp)
                break;
c00272f9:	eb 19                	jmp    c0027314 <__vprintf+0x185>
              default:
                NOT_REACHED ();
c00272fb:	68 1c 06 03 c0       	push   $0xc003061c
c0027300:	68 50 08 03 c0       	push   $0xc0030850
c0027305:	68 dc 00 00 00       	push   $0xdc
c002730a:	68 3e 06 03 c0       	push   $0xc003063e
c002730f:	e8 14 22 00 00       	call   c0029528 <debug_panic>
                break;
c0027314:	90                   	nop
              }

            format_integer (value < 0 ? -value : value,
c0027315:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027318:	c1 e8 1f             	shr    $0x1f,%eax
c002731b:	0f b6 c8             	movzbl %al,%ecx
c002731e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027321:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027324:	85 d2                	test   %edx,%edx
c0027326:	79 07                	jns    c002732f <__vprintf+0x1a0>
c0027328:	f7 d8                	neg    %eax
c002732a:	83 d2 00             	adc    $0x0,%edx
c002732d:	f7 da                	neg    %edx
c002732f:	ff 75 14             	pushl  0x14(%ebp)
c0027332:	ff 75 10             	pushl  0x10(%ebp)
c0027335:	8d 5d cc             	lea    -0x34(%ebp),%ebx
c0027338:	53                   	push   %ebx
c0027339:	68 a8 05 03 c0       	push   $0xc00305a8
c002733e:	51                   	push   %ecx
c002733f:	6a 01                	push   $0x1
c0027341:	52                   	push   %edx
c0027342:	50                   	push   %eax
c0027343:	e8 3f 05 00 00       	call   c0027887 <format_integer>
c0027348:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c002734b:	e9 6d 02 00 00       	jmp    c00275bd <__vprintf+0x42e>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c0027350:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0027353:	83 f8 08             	cmp    $0x8,%eax
c0027356:	0f 87 d3 00 00 00    	ja     c002742f <__vprintf+0x2a0>
c002735c:	8b 04 85 78 07 03 c0 	mov    -0x3ffcf888(,%eax,4),%eax
c0027363:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c0027365:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027368:	8d 50 04             	lea    0x4(%eax),%edx
c002736b:	89 55 0c             	mov    %edx,0xc(%ebp)
c002736e:	8b 00                	mov    (%eax),%eax
c0027370:	0f b6 c0             	movzbl %al,%eax
c0027373:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027376:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c002737d:	e9 c6 00 00 00       	jmp    c0027448 <__vprintf+0x2b9>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c0027382:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027385:	8d 50 04             	lea    0x4(%eax),%edx
c0027388:	89 55 0c             	mov    %edx,0xc(%ebp)
c002738b:	8b 00                	mov    (%eax),%eax
c002738d:	0f b7 c0             	movzwl %ax,%eax
c0027390:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027393:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c002739a:	e9 a9 00 00 00       	jmp    c0027448 <__vprintf+0x2b9>
              case INT:
                value = va_arg (args, unsigned);
c002739f:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273a2:	8d 50 04             	lea    0x4(%eax),%edx
c00273a5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273a8:	8b 00                	mov    (%eax),%eax
c00273aa:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00273b4:	e9 8f 00 00 00       	jmp    c0027448 <__vprintf+0x2b9>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c00273b9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273bc:	8d 50 08             	lea    0x8(%eax),%edx
c00273bf:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273c2:	8b 50 04             	mov    0x4(%eax),%edx
c00273c5:	8b 00                	mov    (%eax),%eax
c00273c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273ca:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c00273cd:	eb 79                	jmp    c0027448 <__vprintf+0x2b9>
              case LONG:
                value = va_arg (args, unsigned long);
c00273cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273d2:	8d 50 04             	lea    0x4(%eax),%edx
c00273d5:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273d8:	8b 00                	mov    (%eax),%eax
c00273da:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c00273e4:	eb 62                	jmp    c0027448 <__vprintf+0x2b9>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c00273e6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273e9:	8d 50 08             	lea    0x8(%eax),%edx
c00273ec:	89 55 0c             	mov    %edx,0xc(%ebp)
c00273ef:	8b 50 04             	mov    0x4(%eax),%edx
c00273f2:	8b 00                	mov    (%eax),%eax
c00273f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00273f7:	89 55 ec             	mov    %edx,-0x14(%ebp)
                break;
c00273fa:	eb 4c                	jmp    c0027448 <__vprintf+0x2b9>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c00273fc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273ff:	8d 50 04             	lea    0x4(%eax),%edx
c0027402:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027405:	8b 00                	mov    (%eax),%eax
c0027407:	99                   	cltd   
c0027408:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002740b:	89 55 ec             	mov    %edx,-0x14(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c002740e:	83 65 e8 ff          	andl   $0xffffffff,-0x18(%ebp)
c0027412:	83 65 ec 00          	andl   $0x0,-0x14(%ebp)
#endif
                break;
c0027416:	eb 30                	jmp    c0027448 <__vprintf+0x2b9>
              case SIZET:
                value = va_arg (args, size_t);
c0027418:	8b 45 0c             	mov    0xc(%ebp),%eax
c002741b:	8d 50 04             	lea    0x4(%eax),%edx
c002741e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027421:	8b 00                	mov    (%eax),%eax
c0027423:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0027426:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
                break;
c002742d:	eb 19                	jmp    c0027448 <__vprintf+0x2b9>
              default:
                NOT_REACHED ();
c002742f:	68 1c 06 03 c0       	push   $0xc003061c
c0027434:	68 50 08 03 c0       	push   $0xc0030850
c0027439:	68 0b 01 00 00       	push   $0x10b
c002743e:	68 3e 06 03 c0       	push   $0xc003063e
c0027443:	e8 e0 20 00 00       	call   c0029528 <debug_panic>
              }

            switch (*format) 
c0027448:	8b 45 08             	mov    0x8(%ebp),%eax
c002744b:	8a 00                	mov    (%eax),%al
c002744d:	0f be c0             	movsbl %al,%eax
c0027450:	83 f8 6f             	cmp    $0x6f,%eax
c0027453:	74 18                	je     c002746d <__vprintf+0x2de>
c0027455:	83 f8 6f             	cmp    $0x6f,%eax
c0027458:	7f 07                	jg     c0027461 <__vprintf+0x2d2>
c002745a:	83 f8 58             	cmp    $0x58,%eax
c002745d:	74 29                	je     c0027488 <__vprintf+0x2f9>
c002745f:	eb 30                	jmp    c0027491 <__vprintf+0x302>
c0027461:	83 f8 75             	cmp    $0x75,%eax
c0027464:	74 10                	je     c0027476 <__vprintf+0x2e7>
c0027466:	83 f8 78             	cmp    $0x78,%eax
c0027469:	74 14                	je     c002747f <__vprintf+0x2f0>
c002746b:	eb 24                	jmp    c0027491 <__vprintf+0x302>
              {
              case 'o': b = &base_o; break;
c002746d:	c7 45 e4 c4 05 03 c0 	movl   $0xc00305c4,-0x1c(%ebp)
c0027474:	eb 34                	jmp    c00274aa <__vprintf+0x31b>
              case 'u': b = &base_d; break;
c0027476:	c7 45 e4 a8 05 03 c0 	movl   $0xc00305a8,-0x1c(%ebp)
c002747d:	eb 2b                	jmp    c00274aa <__vprintf+0x31b>
              case 'x': b = &base_x; break;
c002747f:	c7 45 e4 e8 05 03 c0 	movl   $0xc00305e8,-0x1c(%ebp)
c0027486:	eb 22                	jmp    c00274aa <__vprintf+0x31b>
              case 'X': b = &base_X; break;
c0027488:	c7 45 e4 0c 06 03 c0 	movl   $0xc003060c,-0x1c(%ebp)
c002748f:	eb 19                	jmp    c00274aa <__vprintf+0x31b>
              default: NOT_REACHED ();
c0027491:	68 1c 06 03 c0       	push   $0xc003061c
c0027496:	68 50 08 03 c0       	push   $0xc0030850
c002749b:	68 14 01 00 00       	push   $0x114
c00274a0:	68 3e 06 03 c0       	push   $0xc003063e
c00274a5:	e8 7e 20 00 00       	call   c0029528 <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c00274aa:	ff 75 14             	pushl  0x14(%ebp)
c00274ad:	ff 75 10             	pushl  0x10(%ebp)
c00274b0:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00274b3:	50                   	push   %eax
c00274b4:	ff 75 e4             	pushl  -0x1c(%ebp)
c00274b7:	6a 00                	push   $0x0
c00274b9:	6a 00                	push   $0x0
c00274bb:	ff 75 ec             	pushl  -0x14(%ebp)
c00274be:	ff 75 e8             	pushl  -0x18(%ebp)
c00274c1:	e8 c1 03 00 00       	call   c0027887 <format_integer>
c00274c6:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00274c9:	e9 ef 00 00 00       	jmp    c00275bd <__vprintf+0x42e>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c00274ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274d1:	8d 50 04             	lea    0x4(%eax),%edx
c00274d4:	89 55 0c             	mov    %edx,0xc(%ebp)
c00274d7:	8b 00                	mov    (%eax),%eax
c00274d9:	88 45 cb             	mov    %al,-0x35(%ebp)
            format_string (&ch, 1, &c, output, aux);
c00274dc:	83 ec 0c             	sub    $0xc,%esp
c00274df:	ff 75 14             	pushl  0x14(%ebp)
c00274e2:	ff 75 10             	pushl  0x10(%ebp)
c00274e5:	8d 45 cc             	lea    -0x34(%ebp),%eax
c00274e8:	50                   	push   %eax
c00274e9:	6a 01                	push   $0x1
c00274eb:	8d 45 cb             	lea    -0x35(%ebp),%eax
c00274ee:	50                   	push   %eax
c00274ef:	e8 ed 06 00 00       	call   c0027be1 <format_string>
c00274f4:	83 c4 20             	add    $0x20,%esp
          }
          break;
c00274f7:	e9 c1 00 00 00       	jmp    c00275bd <__vprintf+0x42e>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c00274fc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00274ff:	8d 50 04             	lea    0x4(%eax),%edx
c0027502:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027505:	8b 00                	mov    (%eax),%eax
c0027507:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if (s == NULL)
c002750a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002750e:	75 07                	jne    c0027517 <__vprintf+0x388>
              s = "(null)";
c0027510:	c7 45 e0 50 06 03 c0 	movl   $0xc0030650,-0x20(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027517:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002751a:	83 ec 08             	sub    $0x8,%esp
c002751d:	50                   	push   %eax
c002751e:	ff 75 e0             	pushl  -0x20(%ebp)
c0027521:	e8 c2 14 00 00       	call   c00289e8 <strnlen>
c0027526:	83 c4 10             	add    $0x10,%esp
c0027529:	89 c2                	mov    %eax,%edx
c002752b:	83 ec 0c             	sub    $0xc,%esp
c002752e:	ff 75 14             	pushl  0x14(%ebp)
c0027531:	ff 75 10             	pushl  0x10(%ebp)
c0027534:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0027537:	50                   	push   %eax
c0027538:	52                   	push   %edx
c0027539:	ff 75 e0             	pushl  -0x20(%ebp)
c002753c:	e8 a0 06 00 00       	call   c0027be1 <format_string>
c0027541:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027544:	eb 77                	jmp    c00275bd <__vprintf+0x42e>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0027546:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027549:	8d 50 04             	lea    0x4(%eax),%edx
c002754c:	89 55 0c             	mov    %edx,0xc(%ebp)
c002754f:	8b 00                	mov    (%eax),%eax
c0027551:	89 45 dc             	mov    %eax,-0x24(%ebp)

            c.flags = POUND;
c0027554:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%ebp)
            format_integer ((uintptr_t) p, false, false,
c002755b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002755e:	ba 00 00 00 00       	mov    $0x0,%edx
c0027563:	ff 75 14             	pushl  0x14(%ebp)
c0027566:	ff 75 10             	pushl  0x10(%ebp)
c0027569:	8d 4d cc             	lea    -0x34(%ebp),%ecx
c002756c:	51                   	push   %ecx
c002756d:	68 e8 05 03 c0       	push   $0xc00305e8
c0027572:	6a 00                	push   $0x0
c0027574:	6a 00                	push   $0x0
c0027576:	52                   	push   %edx
c0027577:	50                   	push   %eax
c0027578:	e8 0a 03 00 00       	call   c0027887 <format_integer>
c002757d:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c0027580:	eb 3b                	jmp    c00275bd <__vprintf+0x42e>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027582:	8b 45 08             	mov    0x8(%ebp),%eax
c0027585:	8a 00                	mov    (%eax),%al
c0027587:	0f be c0             	movsbl %al,%eax
c002758a:	50                   	push   %eax
c002758b:	ff 75 14             	pushl  0x14(%ebp)
c002758e:	ff 75 10             	pushl  0x10(%ebp)
c0027591:	68 57 06 03 c0       	push   $0xc0030657
c0027596:	e8 e1 06 00 00       	call   c0027c7c <__printf>
c002759b:	83 c4 10             	add    $0x10,%esp
          break;
c002759e:	eb 1d                	jmp    c00275bd <__vprintf+0x42e>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c00275a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00275a3:	8a 00                	mov    (%eax),%al
c00275a5:	0f be c0             	movsbl %al,%eax
c00275a8:	50                   	push   %eax
c00275a9:	ff 75 14             	pushl  0x14(%ebp)
c00275ac:	ff 75 10             	pushl  0x10(%ebp)
c00275af:	68 6d 06 03 c0       	push   $0xc003066d
c00275b4:	e8 c3 06 00 00       	call   c0027c7c <__printf>
c00275b9:	83 c4 10             	add    $0x10,%esp
          break;
c00275bc:	90                   	nop
  for (; *format != '\0'; format++)
c00275bd:	ff 45 08             	incl   0x8(%ebp)
c00275c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00275c3:	8a 00                	mov    (%eax),%al
c00275c5:	84 c0                	test   %al,%al
c00275c7:	0f 85 ce fb ff ff    	jne    c002719b <__vprintf+0xc>
        }
    }
}
c00275cd:	90                   	nop
c00275ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00275d1:	c9                   	leave  
c00275d2:	c3                   	ret    

c00275d3 <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c00275d3:	55                   	push   %ebp
c00275d4:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c00275d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00275d9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c00275df:	8b 45 08             	mov    0x8(%ebp),%eax
c00275e2:	8d 50 01             	lea    0x1(%eax),%edx
c00275e5:	89 55 08             	mov    %edx,0x8(%ebp)
c00275e8:	8a 00                	mov    (%eax),%al
c00275ea:	0f be c0             	movsbl %al,%eax
c00275ed:	83 e8 20             	sub    $0x20,%eax
c00275f0:	83 f8 10             	cmp    $0x10,%eax
c00275f3:	77 6f                	ja     c0027664 <parse_conversion+0x91>
c00275f5:	8b 04 85 9c 07 03 c0 	mov    -0x3ffcf864(,%eax,4),%eax
c00275fc:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c00275fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027601:	8b 00                	mov    (%eax),%eax
c0027603:	83 c8 01             	or     $0x1,%eax
c0027606:	89 c2                	mov    %eax,%edx
c0027608:	8b 45 0c             	mov    0xc(%ebp),%eax
c002760b:	89 10                	mov    %edx,(%eax)
          break;
c002760d:	eb 67                	jmp    c0027676 <parse_conversion+0xa3>
        case '+':
          c->flags |= PLUS;
c002760f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027612:	8b 00                	mov    (%eax),%eax
c0027614:	83 c8 02             	or     $0x2,%eax
c0027617:	89 c2                	mov    %eax,%edx
c0027619:	8b 45 0c             	mov    0xc(%ebp),%eax
c002761c:	89 10                	mov    %edx,(%eax)
          break;
c002761e:	eb 56                	jmp    c0027676 <parse_conversion+0xa3>
        case ' ':
          c->flags |= SPACE;
c0027620:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027623:	8b 00                	mov    (%eax),%eax
c0027625:	83 c8 04             	or     $0x4,%eax
c0027628:	89 c2                	mov    %eax,%edx
c002762a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002762d:	89 10                	mov    %edx,(%eax)
          break;
c002762f:	eb 45                	jmp    c0027676 <parse_conversion+0xa3>
        case '#':
          c->flags |= POUND;
c0027631:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027634:	8b 00                	mov    (%eax),%eax
c0027636:	83 c8 08             	or     $0x8,%eax
c0027639:	89 c2                	mov    %eax,%edx
c002763b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002763e:	89 10                	mov    %edx,(%eax)
          break;
c0027640:	eb 34                	jmp    c0027676 <parse_conversion+0xa3>
        case '0':
          c->flags |= ZERO;
c0027642:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027645:	8b 00                	mov    (%eax),%eax
c0027647:	83 c8 10             	or     $0x10,%eax
c002764a:	89 c2                	mov    %eax,%edx
c002764c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002764f:	89 10                	mov    %edx,(%eax)
          break;
c0027651:	eb 23                	jmp    c0027676 <parse_conversion+0xa3>
        case '\'':
          c->flags |= GROUP;
c0027653:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027656:	8b 00                	mov    (%eax),%eax
c0027658:	83 c8 20             	or     $0x20,%eax
c002765b:	89 c2                	mov    %eax,%edx
c002765d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027660:	89 10                	mov    %edx,(%eax)
          break;
c0027662:	eb 12                	jmp    c0027676 <parse_conversion+0xa3>
        default:
          format--;
c0027664:	ff 4d 08             	decl   0x8(%ebp)
          goto not_a_flag;
c0027667:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c0027668:	8b 45 0c             	mov    0xc(%ebp),%eax
c002766b:	8b 00                	mov    (%eax),%eax
c002766d:	83 e0 01             	and    $0x1,%eax
c0027670:	85 c0                	test   %eax,%eax
c0027672:	74 16                	je     c002768a <parse_conversion+0xb7>
c0027674:	eb 05                	jmp    c002767b <parse_conversion+0xa8>
      switch (*format++) 
c0027676:	e9 64 ff ff ff       	jmp    c00275df <parse_conversion+0xc>
    c->flags &= ~ZERO;
c002767b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002767e:	8b 00                	mov    (%eax),%eax
c0027680:	83 e0 ef             	and    $0xffffffef,%eax
c0027683:	89 c2                	mov    %eax,%edx
c0027685:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027688:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c002768a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002768d:	8b 00                	mov    (%eax),%eax
c002768f:	83 e0 02             	and    $0x2,%eax
c0027692:	85 c0                	test   %eax,%eax
c0027694:	74 0f                	je     c00276a5 <parse_conversion+0xd2>
    c->flags &= ~SPACE;
c0027696:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027699:	8b 00                	mov    (%eax),%eax
c002769b:	83 e0 fb             	and    $0xfffffffb,%eax
c002769e:	89 c2                	mov    %eax,%edx
c00276a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276a3:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c00276a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276a8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c00276af:	8b 45 08             	mov    0x8(%ebp),%eax
c00276b2:	8a 00                	mov    (%eax),%al
c00276b4:	3c 2a                	cmp    $0x2a,%al
c00276b6:	75 41                	jne    c00276f9 <parse_conversion+0x126>
    {
      format++;
c00276b8:	ff 45 08             	incl   0x8(%ebp)
      c->width = va_arg (*args, int);
c00276bb:	8b 45 10             	mov    0x10(%ebp),%eax
c00276be:	8b 00                	mov    (%eax),%eax
c00276c0:	8d 48 04             	lea    0x4(%eax),%ecx
c00276c3:	8b 55 10             	mov    0x10(%ebp),%edx
c00276c6:	89 0a                	mov    %ecx,(%edx)
c00276c8:	8b 10                	mov    (%eax),%edx
c00276ca:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276cd:	89 50 04             	mov    %edx,0x4(%eax)
c00276d0:	eb 3c                	jmp    c002770e <parse_conversion+0x13b>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c00276d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276d5:	8b 50 04             	mov    0x4(%eax),%edx
c00276d8:	89 d0                	mov    %edx,%eax
c00276da:	c1 e0 02             	shl    $0x2,%eax
c00276dd:	01 d0                	add    %edx,%eax
c00276df:	01 c0                	add    %eax,%eax
c00276e1:	89 c2                	mov    %eax,%edx
c00276e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00276e6:	8a 00                	mov    (%eax),%al
c00276e8:	0f be c0             	movsbl %al,%eax
c00276eb:	01 d0                	add    %edx,%eax
c00276ed:	8d 50 d0             	lea    -0x30(%eax),%edx
c00276f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276f3:	89 50 04             	mov    %edx,0x4(%eax)
      for (; isdigit (*format); format++)
c00276f6:	ff 45 08             	incl   0x8(%ebp)
c00276f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00276fc:	8a 00                	mov    (%eax),%al
c00276fe:	0f be c0             	movsbl %al,%eax
c0027701:	50                   	push   %eax
c0027702:	e8 70 f9 ff ff       	call   c0027077 <isdigit>
c0027707:	83 c4 04             	add    $0x4,%esp
c002770a:	85 c0                	test   %eax,%eax
c002770c:	75 c4                	jne    c00276d2 <parse_conversion+0xff>
    }
  if (c->width < 0) 
c002770e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027711:	8b 40 04             	mov    0x4(%eax),%eax
c0027714:	85 c0                	test   %eax,%eax
c0027716:	79 1f                	jns    c0027737 <parse_conversion+0x164>
    {
      c->width = -c->width;
c0027718:	8b 45 0c             	mov    0xc(%ebp),%eax
c002771b:	8b 40 04             	mov    0x4(%eax),%eax
c002771e:	f7 d8                	neg    %eax
c0027720:	89 c2                	mov    %eax,%edx
c0027722:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027725:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c0027728:	8b 45 0c             	mov    0xc(%ebp),%eax
c002772b:	8b 00                	mov    (%eax),%eax
c002772d:	83 c8 01             	or     $0x1,%eax
c0027730:	89 c2                	mov    %eax,%edx
c0027732:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027735:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c0027737:	8b 45 0c             	mov    0xc(%ebp),%eax
c002773a:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0027741:	8b 45 08             	mov    0x8(%ebp),%eax
c0027744:	8a 00                	mov    (%eax),%al
c0027746:	3c 2e                	cmp    $0x2e,%al
c0027748:	0f 85 82 00 00 00    	jne    c00277d0 <parse_conversion+0x1fd>
    {
      format++;
c002774e:	ff 45 08             	incl   0x8(%ebp)
      if (*format == '*') 
c0027751:	8b 45 08             	mov    0x8(%ebp),%eax
c0027754:	8a 00                	mov    (%eax),%al
c0027756:	3c 2a                	cmp    $0x2a,%al
c0027758:	75 1a                	jne    c0027774 <parse_conversion+0x1a1>
        {
          format++;
c002775a:	ff 45 08             	incl   0x8(%ebp)
          c->precision = va_arg (*args, int);
c002775d:	8b 45 10             	mov    0x10(%ebp),%eax
c0027760:	8b 00                	mov    (%eax),%eax
c0027762:	8d 48 04             	lea    0x4(%eax),%ecx
c0027765:	8b 55 10             	mov    0x10(%ebp),%edx
c0027768:	89 0a                	mov    %ecx,(%edx)
c002776a:	8b 10                	mov    (%eax),%edx
c002776c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002776f:	89 50 08             	mov    %edx,0x8(%eax)
c0027772:	eb 48                	jmp    c00277bc <parse_conversion+0x1e9>
        }
      else 
        {
          c->precision = 0;
c0027774:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027777:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c002777e:	eb 27                	jmp    c00277a7 <parse_conversion+0x1d4>
            c->precision = c->precision * 10 + *format - '0';
c0027780:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027783:	8b 50 08             	mov    0x8(%eax),%edx
c0027786:	89 d0                	mov    %edx,%eax
c0027788:	c1 e0 02             	shl    $0x2,%eax
c002778b:	01 d0                	add    %edx,%eax
c002778d:	01 c0                	add    %eax,%eax
c002778f:	89 c2                	mov    %eax,%edx
c0027791:	8b 45 08             	mov    0x8(%ebp),%eax
c0027794:	8a 00                	mov    (%eax),%al
c0027796:	0f be c0             	movsbl %al,%eax
c0027799:	01 d0                	add    %edx,%eax
c002779b:	8d 50 d0             	lea    -0x30(%eax),%edx
c002779e:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277a1:	89 50 08             	mov    %edx,0x8(%eax)
          for (; isdigit (*format); format++)
c00277a4:	ff 45 08             	incl   0x8(%ebp)
c00277a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00277aa:	8a 00                	mov    (%eax),%al
c00277ac:	0f be c0             	movsbl %al,%eax
c00277af:	50                   	push   %eax
c00277b0:	e8 c2 f8 ff ff       	call   c0027077 <isdigit>
c00277b5:	83 c4 04             	add    $0x4,%esp
c00277b8:	85 c0                	test   %eax,%eax
c00277ba:	75 c4                	jne    c0027780 <parse_conversion+0x1ad>
        }
      if (c->precision < 0) 
c00277bc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277bf:	8b 40 08             	mov    0x8(%eax),%eax
c00277c2:	85 c0                	test   %eax,%eax
c00277c4:	79 0a                	jns    c00277d0 <parse_conversion+0x1fd>
        c->precision = -1;
c00277c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277c9:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c00277d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277d3:	8b 40 08             	mov    0x8(%eax),%eax
c00277d6:	85 c0                	test   %eax,%eax
c00277d8:	78 0f                	js     c00277e9 <parse_conversion+0x216>
    c->flags &= ~ZERO;
c00277da:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277dd:	8b 00                	mov    (%eax),%eax
c00277df:	83 e0 ef             	and    $0xffffffef,%eax
c00277e2:	89 c2                	mov    %eax,%edx
c00277e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277e7:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c00277e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00277ec:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c00277f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00277f6:	8d 50 01             	lea    0x1(%eax),%edx
c00277f9:	89 55 08             	mov    %edx,0x8(%ebp)
c00277fc:	8a 00                	mov    (%eax),%al
c00277fe:	0f be c0             	movsbl %al,%eax
c0027801:	83 e8 68             	sub    $0x68,%eax
c0027804:	83 f8 12             	cmp    $0x12,%eax
c0027807:	77 75                	ja     c002787e <parse_conversion+0x2ab>
c0027809:	8b 04 85 e0 07 03 c0 	mov    -0x3ffcf820(,%eax,4),%eax
c0027810:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c0027812:	8b 45 08             	mov    0x8(%ebp),%eax
c0027815:	8a 00                	mov    (%eax),%al
c0027817:	3c 68                	cmp    $0x68,%al
c0027819:	75 0f                	jne    c002782a <parse_conversion+0x257>
        {
          format++;
c002781b:	ff 45 08             	incl   0x8(%ebp)
          c->type = CHAR;
c002781e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027821:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c0027828:	eb 58                	jmp    c0027882 <parse_conversion+0x2af>
        c->type = SHORT;
c002782a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002782d:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0027834:	eb 4c                	jmp    c0027882 <parse_conversion+0x2af>
      
    case 'j':
      c->type = INTMAX;
c0027836:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027839:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0027840:	eb 40                	jmp    c0027882 <parse_conversion+0x2af>

    case 'l':
      if (*format == 'l')
c0027842:	8b 45 08             	mov    0x8(%ebp),%eax
c0027845:	8a 00                	mov    (%eax),%al
c0027847:	3c 6c                	cmp    $0x6c,%al
c0027849:	75 0f                	jne    c002785a <parse_conversion+0x287>
        {
          format++;
c002784b:	ff 45 08             	incl   0x8(%ebp)
          c->type = LONGLONG;
c002784e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027851:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c0027858:	eb 28                	jmp    c0027882 <parse_conversion+0x2af>
        c->type = LONG;
c002785a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002785d:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c0027864:	eb 1c                	jmp    c0027882 <parse_conversion+0x2af>

    case 't':
      c->type = PTRDIFFT;
c0027866:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027869:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c0027870:	eb 10                	jmp    c0027882 <parse_conversion+0x2af>

    case 'z':
      c->type = SIZET;
c0027872:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027875:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c002787c:	eb 04                	jmp    c0027882 <parse_conversion+0x2af>

    default:
      format--;
c002787e:	ff 4d 08             	decl   0x8(%ebp)
      break;
c0027881:	90                   	nop
    }

  return format;
c0027882:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0027885:	c9                   	leave  
c0027886:	c3                   	ret    

c0027887 <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0027887:	55                   	push   %ebp
c0027888:	89 e5                	mov    %esp,%ebp
c002788a:	57                   	push   %edi
c002788b:	56                   	push   %esi
c002788c:	53                   	push   %ebx
c002788d:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
c0027893:	8b 45 10             	mov    0x10(%ebp),%eax
c0027896:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
c002789c:	8b 5d 14             	mov    0x14(%ebp),%ebx
c002789f:	8b 45 08             	mov    0x8(%ebp),%eax
c00278a2:	89 45 80             	mov    %eax,-0x80(%ebp)
c00278a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278a8:	89 45 84             	mov    %eax,-0x7c(%ebp)
c00278ab:	8a 85 6c ff ff ff    	mov    -0x94(%ebp),%al
c00278b1:	88 85 7c ff ff ff    	mov    %al,-0x84(%ebp)
c00278b7:	88 9d 78 ff ff ff    	mov    %bl,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c00278bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c00278c4:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c00278cb:	74 5c                	je     c0027929 <format_integer+0xa2>
    {
      if (c->flags & PLUS)
c00278cd:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00278d0:	8b 00                	mov    (%eax),%eax
c00278d2:	83 e0 02             	and    $0x2,%eax
c00278d5:	85 c0                	test   %eax,%eax
c00278d7:	74 1a                	je     c00278f3 <format_integer+0x6c>
        sign = negative ? '-' : '+';
c00278d9:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c00278e0:	74 07                	je     c00278e9 <format_integer+0x62>
c00278e2:	b8 2d 00 00 00       	mov    $0x2d,%eax
c00278e7:	eb 05                	jmp    c00278ee <format_integer+0x67>
c00278e9:	b8 2b 00 00 00       	mov    $0x2b,%eax
c00278ee:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00278f1:	eb 36                	jmp    c0027929 <format_integer+0xa2>
      else if (c->flags & SPACE)
c00278f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00278f6:	8b 00                	mov    (%eax),%eax
c00278f8:	83 e0 04             	and    $0x4,%eax
c00278fb:	85 c0                	test   %eax,%eax
c00278fd:	74 1a                	je     c0027919 <format_integer+0x92>
        sign = negative ? '-' : ' ';
c00278ff:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027906:	74 07                	je     c002790f <format_integer+0x88>
c0027908:	b8 2d 00 00 00       	mov    $0x2d,%eax
c002790d:	eb 05                	jmp    c0027914 <format_integer+0x8d>
c002790f:	b8 20 00 00 00       	mov    $0x20,%eax
c0027914:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027917:	eb 10                	jmp    c0027929 <format_integer+0xa2>
      else if (negative)
c0027919:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027920:	74 07                	je     c0027929 <format_integer+0xa2>
        sign = '-';
c0027922:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0027929:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002792c:	8b 00                	mov    (%eax),%eax
c002792e:	83 e0 08             	and    $0x8,%eax
c0027931:	85 c0                	test   %eax,%eax
c0027933:	74 20                	je     c0027955 <format_integer+0xce>
c0027935:	8b 45 80             	mov    -0x80(%ebp),%eax
c0027938:	80 f4 00             	xor    $0x0,%ah
c002793b:	89 c2                	mov    %eax,%edx
c002793d:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027940:	80 f4 00             	xor    $0x0,%ah
c0027943:	89 c1                	mov    %eax,%ecx
c0027945:	89 c8                	mov    %ecx,%eax
c0027947:	09 d0                	or     %edx,%eax
c0027949:	85 c0                	test   %eax,%eax
c002794b:	74 08                	je     c0027955 <format_integer+0xce>
c002794d:	8b 45 18             	mov    0x18(%ebp),%eax
c0027950:	8b 40 08             	mov    0x8(%eax),%eax
c0027953:	eb 05                	jmp    c002795a <format_integer+0xd3>
c0027955:	b8 00 00 00 00       	mov    $0x0,%eax
c002795a:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c002795d:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027960:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c0027963:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c002796a:	e9 82 00 00 00       	jmp    c00279f1 <format_integer+0x16a>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c002796f:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027972:	8b 00                	mov    (%eax),%eax
c0027974:	83 e0 20             	and    $0x20,%eax
c0027977:	85 c0                	test   %eax,%eax
c0027979:	74 24                	je     c002799f <format_integer+0x118>
c002797b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c002797f:	7e 1e                	jle    c002799f <format_integer+0x118>
c0027981:	8b 45 18             	mov    0x18(%ebp),%eax
c0027984:	8b 48 0c             	mov    0xc(%eax),%ecx
c0027987:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002798a:	99                   	cltd   
c002798b:	f7 f9                	idiv   %ecx
c002798d:	89 d0                	mov    %edx,%eax
c002798f:	85 c0                	test   %eax,%eax
c0027991:	75 0c                	jne    c002799f <format_integer+0x118>
        *cp++ = ',';
c0027993:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027996:	8d 50 01             	lea    0x1(%eax),%edx
c0027999:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002799c:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c002799f:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c00279a2:	8d 46 01             	lea    0x1(%esi),%eax
c00279a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00279a8:	8b 45 18             	mov    0x18(%ebp),%eax
c00279ab:	8b 78 04             	mov    0x4(%eax),%edi
c00279ae:	8b 45 18             	mov    0x18(%ebp),%eax
c00279b1:	8b 00                	mov    (%eax),%eax
c00279b3:	89 c1                	mov    %eax,%ecx
c00279b5:	89 c3                	mov    %eax,%ebx
c00279b7:	c1 fb 1f             	sar    $0x1f,%ebx
c00279ba:	8b 45 80             	mov    -0x80(%ebp),%eax
c00279bd:	8b 55 84             	mov    -0x7c(%ebp),%edx
c00279c0:	53                   	push   %ebx
c00279c1:	51                   	push   %ecx
c00279c2:	52                   	push   %edx
c00279c3:	50                   	push   %eax
c00279c4:	e8 02 16 00 00       	call   c0028fcb <__umoddi3>
c00279c9:	83 c4 10             	add    $0x10,%esp
c00279cc:	01 f8                	add    %edi,%eax
c00279ce:	8a 00                	mov    (%eax),%al
c00279d0:	88 06                	mov    %al,(%esi)
      value /= b->base;
c00279d2:	8b 45 18             	mov    0x18(%ebp),%eax
c00279d5:	8b 00                	mov    (%eax),%eax
c00279d7:	99                   	cltd   
c00279d8:	52                   	push   %edx
c00279d9:	50                   	push   %eax
c00279da:	ff 75 84             	pushl  -0x7c(%ebp)
c00279dd:	ff 75 80             	pushl  -0x80(%ebp)
c00279e0:	e8 b2 15 00 00       	call   c0028f97 <__udivdi3>
c00279e5:	83 c4 10             	add    $0x10,%esp
c00279e8:	89 45 80             	mov    %eax,-0x80(%ebp)
c00279eb:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c00279ee:	ff 45 d8             	incl   -0x28(%ebp)
  while (value > 0) 
c00279f1:	8b 45 80             	mov    -0x80(%ebp),%eax
c00279f4:	80 f4 00             	xor    $0x0,%ah
c00279f7:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
c00279fd:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027a00:	80 f4 00             	xor    $0x0,%ah
c0027a03:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
c0027a09:	8b 9d 70 ff ff ff    	mov    -0x90(%ebp),%ebx
c0027a0f:	8b b5 74 ff ff ff    	mov    -0x8c(%ebp),%esi
c0027a15:	89 f0                	mov    %esi,%eax
c0027a17:	09 d8                	or     %ebx,%eax
c0027a19:	85 c0                	test   %eax,%eax
c0027a1b:	0f 85 4e ff ff ff    	jne    c002796f <format_integer+0xe8>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c0027a21:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a24:	8b 40 08             	mov    0x8(%eax),%eax
c0027a27:	85 c0                	test   %eax,%eax
c0027a29:	78 08                	js     c0027a33 <format_integer+0x1ac>
c0027a2b:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a2e:	8b 40 08             	mov    0x8(%eax),%eax
c0027a31:	eb 05                	jmp    c0027a38 <format_integer+0x1b1>
c0027a33:	b8 01 00 00 00       	mov    $0x1,%eax
c0027a38:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027a3b:	eb 0c                	jmp    c0027a49 <format_integer+0x1c2>
    *cp++ = '0';
c0027a3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a40:	8d 50 01             	lea    0x1(%eax),%edx
c0027a43:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027a46:	c6 00 30             	movb   $0x30,(%eax)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c0027a49:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027a4c:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027a4f:	29 c2                	sub    %eax,%edx
c0027a51:	89 d0                	mov    %edx,%eax
c0027a53:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c0027a56:	7d 0b                	jge    c0027a63 <format_integer+0x1dc>
c0027a58:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027a5b:	83 c0 3f             	add    $0x3f,%eax
c0027a5e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027a61:	77 da                	ja     c0027a3d <format_integer+0x1b6>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c0027a63:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a66:	8b 00                	mov    (%eax),%eax
c0027a68:	83 e0 08             	and    $0x8,%eax
c0027a6b:	85 c0                	test   %eax,%eax
c0027a6d:	74 28                	je     c0027a97 <format_integer+0x210>
c0027a6f:	8b 45 18             	mov    0x18(%ebp),%eax
c0027a72:	8b 00                	mov    (%eax),%eax
c0027a74:	83 f8 08             	cmp    $0x8,%eax
c0027a77:	75 1e                	jne    c0027a97 <format_integer+0x210>
c0027a79:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027a7c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027a7f:	74 0a                	je     c0027a8b <format_integer+0x204>
c0027a81:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a84:	48                   	dec    %eax
c0027a85:	8a 00                	mov    (%eax),%al
c0027a87:	3c 30                	cmp    $0x30,%al
c0027a89:	74 0c                	je     c0027a97 <format_integer+0x210>
    *cp++ = '0';
c0027a8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027a8e:	8d 50 01             	lea    0x1(%eax),%edx
c0027a91:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0027a94:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0027a97:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027a9a:	8b 40 04             	mov    0x4(%eax),%eax
c0027a9d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0027aa0:	8d 55 90             	lea    -0x70(%ebp),%edx
c0027aa3:	29 d1                	sub    %edx,%ecx
c0027aa5:	89 ca                	mov    %ecx,%edx
c0027aa7:	29 d0                	sub    %edx,%eax
c0027aa9:	89 c2                	mov    %eax,%edx
c0027aab:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027aaf:	74 07                	je     c0027ab8 <format_integer+0x231>
c0027ab1:	b8 02 00 00 00       	mov    $0x2,%eax
c0027ab6:	eb 05                	jmp    c0027abd <format_integer+0x236>
c0027ab8:	b8 00 00 00 00       	mov    $0x0,%eax
c0027abd:	29 c2                	sub    %eax,%edx
c0027abf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027ac3:	0f 95 c0             	setne  %al
c0027ac6:	0f b6 c0             	movzbl %al,%eax
c0027ac9:	29 c2                	sub    %eax,%edx
c0027acb:	89 d0                	mov    %edx,%eax
c0027acd:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c0027ad0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0027ad4:	79 07                	jns    c0027add <format_integer+0x256>
    pad_cnt = 0;
c0027ad6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027add:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027ae0:	8b 00                	mov    (%eax),%eax
c0027ae2:	83 e0 11             	and    $0x11,%eax
c0027ae5:	85 c0                	test   %eax,%eax
c0027ae7:	75 14                	jne    c0027afd <format_integer+0x276>
    output_dup (' ', pad_cnt, output, aux);
c0027ae9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027aec:	ff 75 24             	pushl  0x24(%ebp)
c0027aef:	ff 75 20             	pushl  0x20(%ebp)
c0027af2:	50                   	push   %eax
c0027af3:	6a 20                	push   $0x20
c0027af5:	e8 b6 00 00 00       	call   c0027bb0 <output_dup>
c0027afa:	83 c4 10             	add    $0x10,%esp
  if (sign)
c0027afd:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0027b01:	74 15                	je     c0027b18 <format_integer+0x291>
    output (sign, aux);
c0027b03:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027b06:	0f be c0             	movsbl %al,%eax
c0027b09:	83 ec 08             	sub    $0x8,%esp
c0027b0c:	ff 75 24             	pushl  0x24(%ebp)
c0027b0f:	50                   	push   %eax
c0027b10:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b13:	ff d0                	call   *%eax
c0027b15:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0027b18:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0027b1c:	74 25                	je     c0027b43 <format_integer+0x2bc>
    {
      output ('0', aux);
c0027b1e:	83 ec 08             	sub    $0x8,%esp
c0027b21:	ff 75 24             	pushl  0x24(%ebp)
c0027b24:	6a 30                	push   $0x30
c0027b26:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b29:	ff d0                	call   *%eax
c0027b2b:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c0027b2e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0027b31:	0f be c0             	movsbl %al,%eax
c0027b34:	83 ec 08             	sub    $0x8,%esp
c0027b37:	ff 75 24             	pushl  0x24(%ebp)
c0027b3a:	50                   	push   %eax
c0027b3b:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b3e:	ff d0                	call   *%eax
c0027b40:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c0027b43:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b46:	8b 00                	mov    (%eax),%eax
c0027b48:	83 e0 10             	and    $0x10,%eax
c0027b4b:	85 c0                	test   %eax,%eax
c0027b4d:	74 30                	je     c0027b7f <format_integer+0x2f8>
    output_dup ('0', pad_cnt, output, aux);
c0027b4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027b52:	ff 75 24             	pushl  0x24(%ebp)
c0027b55:	ff 75 20             	pushl  0x20(%ebp)
c0027b58:	50                   	push   %eax
c0027b59:	6a 30                	push   $0x30
c0027b5b:	e8 50 00 00 00       	call   c0027bb0 <output_dup>
c0027b60:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027b63:	eb 1a                	jmp    c0027b7f <format_integer+0x2f8>
    output (*--cp, aux);
c0027b65:	ff 4d e4             	decl   -0x1c(%ebp)
c0027b68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027b6b:	8a 00                	mov    (%eax),%al
c0027b6d:	0f be c0             	movsbl %al,%eax
c0027b70:	83 ec 08             	sub    $0x8,%esp
c0027b73:	ff 75 24             	pushl  0x24(%ebp)
c0027b76:	50                   	push   %eax
c0027b77:	8b 45 20             	mov    0x20(%ebp),%eax
c0027b7a:	ff d0                	call   *%eax
c0027b7c:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c0027b7f:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027b82:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0027b85:	77 de                	ja     c0027b65 <format_integer+0x2de>
  if (c->flags & MINUS)
c0027b87:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027b8a:	8b 00                	mov    (%eax),%eax
c0027b8c:	83 e0 01             	and    $0x1,%eax
c0027b8f:	85 c0                	test   %eax,%eax
c0027b91:	74 14                	je     c0027ba7 <format_integer+0x320>
    output_dup (' ', pad_cnt, output, aux);
c0027b93:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0027b96:	ff 75 24             	pushl  0x24(%ebp)
c0027b99:	ff 75 20             	pushl  0x20(%ebp)
c0027b9c:	50                   	push   %eax
c0027b9d:	6a 20                	push   $0x20
c0027b9f:	e8 0c 00 00 00       	call   c0027bb0 <output_dup>
c0027ba4:	83 c4 10             	add    $0x10,%esp
}
c0027ba7:	90                   	nop
c0027ba8:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0027bab:	5b                   	pop    %ebx
c0027bac:	5e                   	pop    %esi
c0027bad:	5f                   	pop    %edi
c0027bae:	5d                   	pop    %ebp
c0027baf:	c3                   	ret    

c0027bb0 <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0027bb0:	55                   	push   %ebp
c0027bb1:	89 e5                	mov    %esp,%ebp
c0027bb3:	83 ec 18             	sub    $0x18,%esp
c0027bb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0027bb9:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c0027bbc:	eb 13                	jmp    c0027bd1 <output_dup+0x21>
    output (ch, aux);
c0027bbe:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0027bc2:	83 ec 08             	sub    $0x8,%esp
c0027bc5:	ff 75 14             	pushl  0x14(%ebp)
c0027bc8:	50                   	push   %eax
c0027bc9:	8b 45 10             	mov    0x10(%ebp),%eax
c0027bcc:	ff d0                	call   *%eax
c0027bce:	83 c4 10             	add    $0x10,%esp
  while (cnt-- > 0)
c0027bd1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027bd4:	8d 50 ff             	lea    -0x1(%eax),%edx
c0027bd7:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027bda:	85 c0                	test   %eax,%eax
c0027bdc:	75 e0                	jne    c0027bbe <output_dup+0xe>
}
c0027bde:	90                   	nop
c0027bdf:	c9                   	leave  
c0027be0:	c3                   	ret    

c0027be1 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0027be1:	55                   	push   %ebp
c0027be2:	89 e5                	mov    %esp,%ebp
c0027be4:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027be7:	8b 45 10             	mov    0x10(%ebp),%eax
c0027bea:	8b 40 04             	mov    0x4(%eax),%eax
c0027bed:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027bf0:	7e 26                	jle    c0027c18 <format_string+0x37>
c0027bf2:	8b 45 10             	mov    0x10(%ebp),%eax
c0027bf5:	8b 00                	mov    (%eax),%eax
c0027bf7:	83 e0 01             	and    $0x1,%eax
c0027bfa:	85 c0                	test   %eax,%eax
c0027bfc:	75 1a                	jne    c0027c18 <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c0027bfe:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c01:	8b 40 04             	mov    0x4(%eax),%eax
c0027c04:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027c07:	ff 75 18             	pushl  0x18(%ebp)
c0027c0a:	ff 75 14             	pushl  0x14(%ebp)
c0027c0d:	50                   	push   %eax
c0027c0e:	6a 20                	push   $0x20
c0027c10:	e8 9b ff ff ff       	call   c0027bb0 <output_dup>
c0027c15:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027c18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0027c1f:	eb 1f                	jmp    c0027c40 <format_string+0x5f>
    output (string[i], aux);
c0027c21:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0027c24:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c27:	01 d0                	add    %edx,%eax
c0027c29:	8a 00                	mov    (%eax),%al
c0027c2b:	0f be c0             	movsbl %al,%eax
c0027c2e:	83 ec 08             	sub    $0x8,%esp
c0027c31:	ff 75 18             	pushl  0x18(%ebp)
c0027c34:	50                   	push   %eax
c0027c35:	8b 45 14             	mov    0x14(%ebp),%eax
c0027c38:	ff d0                	call   *%eax
c0027c3a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0027c3d:	ff 45 f4             	incl   -0xc(%ebp)
c0027c40:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027c43:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027c46:	7c d9                	jl     c0027c21 <format_string+0x40>
  if (c->width > length && (c->flags & MINUS) != 0)
c0027c48:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c4b:	8b 40 04             	mov    0x4(%eax),%eax
c0027c4e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0027c51:	7e 26                	jle    c0027c79 <format_string+0x98>
c0027c53:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c56:	8b 00                	mov    (%eax),%eax
c0027c58:	83 e0 01             	and    $0x1,%eax
c0027c5b:	85 c0                	test   %eax,%eax
c0027c5d:	74 1a                	je     c0027c79 <format_string+0x98>
    output_dup (' ', c->width - length, output, aux);
c0027c5f:	8b 45 10             	mov    0x10(%ebp),%eax
c0027c62:	8b 40 04             	mov    0x4(%eax),%eax
c0027c65:	2b 45 0c             	sub    0xc(%ebp),%eax
c0027c68:	ff 75 18             	pushl  0x18(%ebp)
c0027c6b:	ff 75 14             	pushl  0x14(%ebp)
c0027c6e:	50                   	push   %eax
c0027c6f:	6a 20                	push   $0x20
c0027c71:	e8 3a ff ff ff       	call   c0027bb0 <output_dup>
c0027c76:	83 c4 10             	add    $0x10,%esp
}
c0027c79:	90                   	nop
c0027c7a:	c9                   	leave  
c0027c7b:	c3                   	ret    

c0027c7c <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c0027c7c:	55                   	push   %ebp
c0027c7d:	89 e5                	mov    %esp,%ebp
c0027c7f:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c0027c82:	8d 45 14             	lea    0x14(%ebp),%eax
c0027c85:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c0027c88:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027c8b:	ff 75 10             	pushl  0x10(%ebp)
c0027c8e:	ff 75 0c             	pushl  0xc(%ebp)
c0027c91:	50                   	push   %eax
c0027c92:	ff 75 08             	pushl  0x8(%ebp)
c0027c95:	e8 f5 f4 ff ff       	call   c002718f <__vprintf>
c0027c9a:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0027c9d:	90                   	nop
c0027c9e:	c9                   	leave  
c0027c9f:	c3                   	ret    

c0027ca0 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0027ca0:	55                   	push   %ebp
c0027ca1:	89 e5                	mov    %esp,%ebp
c0027ca3:	83 ec 38             	sub    $0x38,%esp
c0027ca6:	8b 45 14             	mov    0x14(%ebp),%eax
c0027ca9:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c0027cac:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027caf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0027cb2:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c0027cb9:	e9 b4 01 00 00       	jmp    c0027e72 <hex_dump+0x1d2>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0027cbe:	8b 45 08             	mov    0x8(%ebp),%eax
c0027cc1:	ba 00 00 00 00       	mov    $0x0,%edx
c0027cc6:	f7 75 e8             	divl   -0x18(%ebp)
c0027cc9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c0027ccc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027ccf:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0027cd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027cd5:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027cd8:	3b 45 10             	cmp    0x10(%ebp),%eax
c0027cdb:	76 0b                	jbe    c0027ce8 <hex_dump+0x48>
        end = start + size;
c0027cdd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027ce0:	8b 45 10             	mov    0x10(%ebp),%eax
c0027ce3:	01 d0                	add    %edx,%eax
c0027ce5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c0027ce8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0027ceb:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027cee:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0027cf1:	8b 45 08             	mov    0x8(%ebp),%eax
c0027cf4:	ba 00 00 00 00       	mov    $0x0,%edx
c0027cf9:	f7 75 e8             	divl   -0x18(%ebp)
c0027cfc:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0027d00:	ba 00 00 00 00       	mov    $0x0,%edx
c0027d05:	83 ec 04             	sub    $0x4,%esp
c0027d08:	52                   	push   %edx
c0027d09:	50                   	push   %eax
c0027d0a:	68 2c 08 03 c0       	push   $0xc003082c
c0027d0f:	e8 55 f4 ff ff       	call   c0027169 <printf>
c0027d14:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027d17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027d1e:	eb 13                	jmp    c0027d33 <hex_dump+0x93>
        printf ("   ");
c0027d20:	83 ec 0c             	sub    $0xc,%esp
c0027d23:	68 34 08 03 c0       	push   $0xc0030834
c0027d28:	e8 3c f4 ff ff       	call   c0027169 <printf>
c0027d2d:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c0027d30:	ff 45 ec             	incl   -0x14(%ebp)
c0027d33:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027d36:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027d39:	72 e5                	jb     c0027d20 <hex_dump+0x80>
      for (; i < end; i++) 
c0027d3b:	eb 3e                	jmp    c0027d7b <hex_dump+0xdb>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027d3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027d40:	d1 e8                	shr    %eax
c0027d42:	48                   	dec    %eax
        printf ("%02hhx%c",
c0027d43:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0027d46:	75 07                	jne    c0027d4f <hex_dump+0xaf>
c0027d48:	ba 2d 00 00 00       	mov    $0x2d,%edx
c0027d4d:	eb 05                	jmp    c0027d54 <hex_dump+0xb4>
c0027d4f:	ba 20 00 00 00       	mov    $0x20,%edx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c0027d54:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027d57:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027d5a:	89 c1                	mov    %eax,%ecx
c0027d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027d5f:	01 c8                	add    %ecx,%eax
c0027d61:	8a 00                	mov    (%eax),%al
        printf ("%02hhx%c",
c0027d63:	0f b6 c0             	movzbl %al,%eax
c0027d66:	83 ec 04             	sub    $0x4,%esp
c0027d69:	52                   	push   %edx
c0027d6a:	50                   	push   %eax
c0027d6b:	68 38 08 03 c0       	push   $0xc0030838
c0027d70:	e8 f4 f3 ff ff       	call   c0027169 <printf>
c0027d75:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
c0027d78:	ff 45 ec             	incl   -0x14(%ebp)
c0027d7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027d7e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027d81:	72 ba                	jb     c0027d3d <hex_dump+0x9d>
      if (ascii) 
c0027d83:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c0027d87:	0f 84 c6 00 00 00    	je     c0027e53 <hex_dump+0x1b3>
        {
          for (; i < per_line; i++)
c0027d8d:	eb 13                	jmp    c0027da2 <hex_dump+0x102>
            printf ("   ");
c0027d8f:	83 ec 0c             	sub    $0xc,%esp
c0027d92:	68 34 08 03 c0       	push   $0xc0030834
c0027d97:	e8 cd f3 ff ff       	call   c0027169 <printf>
c0027d9c:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0027d9f:	ff 45 ec             	incl   -0x14(%ebp)
c0027da2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027da5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027da8:	72 e5                	jb     c0027d8f <hex_dump+0xef>
          printf ("|");
c0027daa:	83 ec 0c             	sub    $0xc,%esp
c0027dad:	6a 7c                	push   $0x7c
c0027daf:	e8 ba 39 00 00       	call   c002b76e <putchar>
c0027db4:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0027db7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0027dbe:	eb 10                	jmp    c0027dd0 <hex_dump+0x130>
            printf (" ");
c0027dc0:	83 ec 0c             	sub    $0xc,%esp
c0027dc3:	6a 20                	push   $0x20
c0027dc5:	e8 a4 39 00 00       	call   c002b76e <putchar>
c0027dca:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0027dcd:	ff 45 ec             	incl   -0x14(%ebp)
c0027dd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027dd3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0027dd6:	72 e8                	jb     c0027dc0 <hex_dump+0x120>
          for (; i < end; i++)
c0027dd8:	eb 4a                	jmp    c0027e24 <hex_dump+0x184>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027dda:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027ddd:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027de0:	89 c2                	mov    %eax,%edx
c0027de2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027de5:	01 d0                	add    %edx,%eax
c0027de7:	8a 00                	mov    (%eax),%al
c0027de9:	0f b6 c0             	movzbl %al,%eax
c0027dec:	83 ec 0c             	sub    $0xc,%esp
c0027def:	50                   	push   %eax
c0027df0:	e8 9f f2 ff ff       	call   c0027094 <isprint>
c0027df5:	83 c4 10             	add    $0x10,%esp
            printf ("%c",
c0027df8:	85 c0                	test   %eax,%eax
c0027dfa:	74 14                	je     c0027e10 <hex_dump+0x170>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0027dfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027dff:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0027e02:	89 c2                	mov    %eax,%edx
c0027e04:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027e07:	01 d0                	add    %edx,%eax
c0027e09:	8a 00                	mov    (%eax),%al
            printf ("%c",
c0027e0b:	0f b6 c0             	movzbl %al,%eax
c0027e0e:	eb 05                	jmp    c0027e15 <hex_dump+0x175>
c0027e10:	b8 2e 00 00 00       	mov    $0x2e,%eax
c0027e15:	83 ec 0c             	sub    $0xc,%esp
c0027e18:	50                   	push   %eax
c0027e19:	e8 50 39 00 00       	call   c002b76e <putchar>
c0027e1e:	83 c4 10             	add    $0x10,%esp
          for (; i < end; i++)
c0027e21:	ff 45 ec             	incl   -0x14(%ebp)
c0027e24:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e27:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0027e2a:	72 ae                	jb     c0027dda <hex_dump+0x13a>
          for (; i < per_line; i++)
c0027e2c:	eb 10                	jmp    c0027e3e <hex_dump+0x19e>
            printf (" ");
c0027e2e:	83 ec 0c             	sub    $0xc,%esp
c0027e31:	6a 20                	push   $0x20
c0027e33:	e8 36 39 00 00       	call   c002b76e <putchar>
c0027e38:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
c0027e3b:	ff 45 ec             	incl   -0x14(%ebp)
c0027e3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027e41:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0027e44:	72 e8                	jb     c0027e2e <hex_dump+0x18e>
          printf ("|");
c0027e46:	83 ec 0c             	sub    $0xc,%esp
c0027e49:	6a 7c                	push   $0x7c
c0027e4b:	e8 1e 39 00 00       	call   c002b76e <putchar>
c0027e50:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c0027e53:	83 ec 0c             	sub    $0xc,%esp
c0027e56:	6a 0a                	push   $0xa
c0027e58:	e8 11 39 00 00       	call   c002b76e <putchar>
c0027e5d:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c0027e60:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027e63:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c0027e66:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027e69:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c0027e6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027e6f:	29 45 10             	sub    %eax,0x10(%ebp)
  while (size > 0)
c0027e72:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0027e76:	0f 85 42 fe ff ff    	jne    c0027cbe <hex_dump+0x1e>
    }
}
c0027e7c:	90                   	nop
c0027e7d:	c9                   	leave  
c0027e7e:	c3                   	ret    

c0027e7f <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c0027e7f:	55                   	push   %ebp
c0027e80:	89 e5                	mov    %esp,%ebp
c0027e82:	83 ec 28             	sub    $0x28,%esp
c0027e85:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0027e88:	89 4d e0             	mov    %ecx,-0x20(%ebp)
c0027e8b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0027e8e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  if (size == 1)
c0027e91:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0027e94:	83 f1 01             	xor    $0x1,%ecx
c0027e97:	89 c8                	mov    %ecx,%eax
c0027e99:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c0027e9c:	80 f5 00             	xor    $0x0,%ch
c0027e9f:	89 ca                	mov    %ecx,%edx
c0027ea1:	09 d0                	or     %edx,%eax
c0027ea3:	85 c0                	test   %eax,%eax
c0027ea5:	75 12                	jne    c0027eb9 <print_human_readable_size+0x3a>
    printf ("1 byte");
c0027ea7:	83 ec 0c             	sub    $0xc,%esp
c0027eaa:	68 41 08 03 c0       	push   $0xc0030841
c0027eaf:	e8 b5 f2 ff ff       	call   c0027169 <printf>
c0027eb4:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c0027eb7:	eb 5a                	jmp    c0027f13 <print_human_readable_size+0x94>
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027eb9:	c7 45 f4 a8 70 03 c0 	movl   $0xc00370a8,-0xc(%ebp)
c0027ec0:	eb 17                	jmp    c0027ed9 <print_human_readable_size+0x5a>
        size /= 1024;
c0027ec2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0027ec5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0027ec8:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0027ecc:	c1 ea 0a             	shr    $0xa,%edx
c0027ecf:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027ed2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0027ed5:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c0027ed9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0027edd:	72 1b                	jb     c0027efa <print_human_readable_size+0x7b>
c0027edf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0027ee3:	77 09                	ja     c0027eee <print_human_readable_size+0x6f>
c0027ee5:	81 7d e0 ff 03 00 00 	cmpl   $0x3ff,-0x20(%ebp)
c0027eec:	76 0c                	jbe    c0027efa <print_human_readable_size+0x7b>
c0027eee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027ef1:	83 c0 04             	add    $0x4,%eax
c0027ef4:	8b 00                	mov    (%eax),%eax
c0027ef6:	85 c0                	test   %eax,%eax
c0027ef8:	75 c8                	jne    c0027ec2 <print_human_readable_size+0x43>
      printf ("%"PRIu64" %s", size, *fp);
c0027efa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027efd:	8b 00                	mov    (%eax),%eax
c0027eff:	50                   	push   %eax
c0027f00:	ff 75 e4             	pushl  -0x1c(%ebp)
c0027f03:	ff 75 e0             	pushl  -0x20(%ebp)
c0027f06:	68 48 08 03 c0       	push   $0xc0030848
c0027f0b:	e8 59 f2 ff ff       	call   c0027169 <printf>
c0027f10:	83 c4 10             	add    $0x10,%esp
}
c0027f13:	90                   	nop
c0027f14:	c9                   	leave  
c0027f15:	c3                   	ret    

c0027f16 <isdigit>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c0027f16:	55                   	push   %ebp
c0027f17:	89 e5                	mov    %esp,%ebp
c0027f19:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c0027f1d:	7e 0d                	jle    c0027f2c <isdigit+0x16>
c0027f1f:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027f23:	7f 07                	jg     c0027f2c <isdigit+0x16>
c0027f25:	b8 01 00 00 00       	mov    $0x1,%eax
c0027f2a:	eb 05                	jmp    c0027f31 <isdigit+0x1b>
c0027f2c:	b8 00 00 00 00       	mov    $0x0,%eax
c0027f31:	5d                   	pop    %ebp
c0027f32:	c3                   	ret    

c0027f33 <isspace>:
static inline int isspace (int c) {
c0027f33:	55                   	push   %ebp
c0027f34:	89 e5                	mov    %esp,%ebp
          || c == '\r' || c == '\t' || c == '\v');
c0027f36:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0027f3a:	74 1e                	je     c0027f5a <isspace+0x27>
  return (c == ' ' || c == '\f' || c == '\n'
c0027f3c:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0027f40:	74 18                	je     c0027f5a <isspace+0x27>
c0027f42:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0027f46:	74 12                	je     c0027f5a <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0027f48:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0027f4c:	74 0c                	je     c0027f5a <isspace+0x27>
c0027f4e:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0027f52:	74 06                	je     c0027f5a <isspace+0x27>
c0027f54:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0027f58:	75 07                	jne    c0027f61 <isspace+0x2e>
c0027f5a:	b8 01 00 00 00       	mov    $0x1,%eax
c0027f5f:	eb 05                	jmp    c0027f66 <isspace+0x33>
c0027f61:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0027f66:	5d                   	pop    %ebp
c0027f67:	c3                   	ret    

c0027f68 <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c0027f68:	55                   	push   %ebp
c0027f69:	89 e5                	mov    %esp,%ebp
c0027f6b:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c0027f6e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0027f72:	75 21                	jne    c0027f95 <atoi+0x2d>
c0027f74:	83 ec 0c             	sub    $0xc,%esp
c0027f77:	68 6c 08 03 c0       	push   $0xc003086c
c0027f7c:	68 76 08 03 c0       	push   $0xc0030876
c0027f81:	68 d4 08 03 c0       	push   $0xc00308d4
c0027f86:	6a 0f                	push   $0xf
c0027f88:	68 8d 08 03 c0       	push   $0xc003088d
c0027f8d:	e8 96 15 00 00       	call   c0029528 <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c0027f92:	ff 45 08             	incl   0x8(%ebp)
  while (isspace ((unsigned char) *s))
c0027f95:	8b 45 08             	mov    0x8(%ebp),%eax
c0027f98:	8a 00                	mov    (%eax),%al
c0027f9a:	0f b6 c0             	movzbl %al,%eax
c0027f9d:	83 ec 0c             	sub    $0xc,%esp
c0027fa0:	50                   	push   %eax
c0027fa1:	e8 8d ff ff ff       	call   c0027f33 <isspace>
c0027fa6:	83 c4 10             	add    $0x10,%esp
c0027fa9:	85 c0                	test   %eax,%eax
c0027fab:	75 e5                	jne    c0027f92 <atoi+0x2a>

  /* Parse sign. */
  negative = false;
c0027fad:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c0027fb1:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fb4:	8a 00                	mov    (%eax),%al
c0027fb6:	3c 2b                	cmp    $0x2b,%al
c0027fb8:	75 05                	jne    c0027fbf <atoi+0x57>
    s++;
c0027fba:	ff 45 08             	incl   0x8(%ebp)
c0027fbd:	eb 10                	jmp    c0027fcf <atoi+0x67>
  else if (*s == '-')
c0027fbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fc2:	8a 00                	mov    (%eax),%al
c0027fc4:	3c 2d                	cmp    $0x2d,%al
c0027fc6:	75 07                	jne    c0027fcf <atoi+0x67>
    {
      negative = true;
c0027fc8:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c0027fcc:	ff 45 08             	incl   0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0027fcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0027fd6:	eb 23                	jmp    c0027ffb <atoi+0x93>
    value = value * 10 - (*s - '0');
c0027fd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0027fdb:	89 d0                	mov    %edx,%eax
c0027fdd:	c1 e0 02             	shl    $0x2,%eax
c0027fe0:	01 d0                	add    %edx,%eax
c0027fe2:	01 c0                	add    %eax,%eax
c0027fe4:	89 c2                	mov    %eax,%edx
c0027fe6:	8b 45 08             	mov    0x8(%ebp),%eax
c0027fe9:	8a 00                	mov    (%eax),%al
c0027feb:	0f be c0             	movsbl %al,%eax
c0027fee:	83 e8 30             	sub    $0x30,%eax
c0027ff1:	29 c2                	sub    %eax,%edx
c0027ff3:	89 d0                	mov    %edx,%eax
c0027ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (value = 0; isdigit (*s); s++)
c0027ff8:	ff 45 08             	incl   0x8(%ebp)
c0027ffb:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ffe:	8a 00                	mov    (%eax),%al
c0028000:	0f be c0             	movsbl %al,%eax
c0028003:	83 ec 0c             	sub    $0xc,%esp
c0028006:	50                   	push   %eax
c0028007:	e8 0a ff ff ff       	call   c0027f16 <isdigit>
c002800c:	83 c4 10             	add    $0x10,%esp
c002800f:	85 c0                	test   %eax,%eax
c0028011:	75 c5                	jne    c0027fd8 <atoi+0x70>
  if (!negative)
c0028013:	8a 45 f7             	mov    -0x9(%ebp),%al
c0028016:	83 f0 01             	xor    $0x1,%eax
c0028019:	84 c0                	test   %al,%al
c002801b:	74 03                	je     c0028020 <atoi+0xb8>
    value = -value;
c002801d:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c0028020:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028023:	c9                   	leave  
c0028024:	c3                   	ret    

c0028025 <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c0028025:	55                   	push   %ebp
c0028026:	89 e5                	mov    %esp,%ebp
c0028028:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c002802b:	8b 45 10             	mov    0x10(%ebp),%eax
c002802e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c0028031:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028034:	8b 00                	mov    (%eax),%eax
c0028036:	83 ec 08             	sub    $0x8,%esp
c0028039:	ff 75 0c             	pushl  0xc(%ebp)
c002803c:	ff 75 08             	pushl  0x8(%ebp)
c002803f:	ff d0                	call   *%eax
c0028041:	83 c4 10             	add    $0x10,%esp
}
c0028044:	c9                   	leave  
c0028045:	c3                   	ret    

c0028046 <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c0028046:	55                   	push   %ebp
c0028047:	89 e5                	mov    %esp,%ebp
c0028049:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c002804c:	83 ec 0c             	sub    $0xc,%esp
c002804f:	8d 45 14             	lea    0x14(%ebp),%eax
c0028052:	50                   	push   %eax
c0028053:	68 25 80 02 c0       	push   $0xc0028025
c0028058:	ff 75 10             	pushl  0x10(%ebp)
c002805b:	ff 75 0c             	pushl  0xc(%ebp)
c002805e:	ff 75 08             	pushl  0x8(%ebp)
c0028061:	e8 51 01 00 00       	call   c00281b7 <sort>
c0028066:	83 c4 20             	add    $0x20,%esp
}
c0028069:	90                   	nop
c002806a:	c9                   	leave  
c002806b:	c3                   	ret    

c002806c <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c002806c:	55                   	push   %ebp
c002806d:	89 e5                	mov    %esp,%ebp
c002806f:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c0028072:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028075:	48                   	dec    %eax
c0028076:	0f af 45 14          	imul   0x14(%ebp),%eax
c002807a:	89 c2                	mov    %eax,%edx
c002807c:	8b 45 08             	mov    0x8(%ebp),%eax
c002807f:	01 d0                	add    %edx,%eax
c0028081:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c0028084:	8b 45 10             	mov    0x10(%ebp),%eax
c0028087:	48                   	dec    %eax
c0028088:	0f af 45 14          	imul   0x14(%ebp),%eax
c002808c:	89 c2                	mov    %eax,%edx
c002808e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028091:	01 d0                	add    %edx,%eax
c0028093:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c0028096:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002809d:	eb 31                	jmp    c00280d0 <do_swap+0x64>
    {
      unsigned char t = a[i];
c002809f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00280a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280a5:	01 d0                	add    %edx,%eax
c00280a7:	8a 00                	mov    (%eax),%al
c00280a9:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c00280ac:	8b 55 f8             	mov    -0x8(%ebp),%edx
c00280af:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280b2:	01 c2                	add    %eax,%edx
c00280b4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00280b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280ba:	01 c8                	add    %ecx,%eax
c00280bc:	8a 00                	mov    (%eax),%al
c00280be:	88 02                	mov    %al,(%edx)
      b[i] = t;
c00280c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00280c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280c6:	01 c2                	add    %eax,%edx
c00280c8:	8a 45 f3             	mov    -0xd(%ebp),%al
c00280cb:	88 02                	mov    %al,(%edx)
  for (i = 0; i < size; i++)
c00280cd:	ff 45 fc             	incl   -0x4(%ebp)
c00280d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00280d3:	3b 45 14             	cmp    0x14(%ebp),%eax
c00280d6:	72 c7                	jb     c002809f <do_swap+0x33>
    }
}
c00280d8:	90                   	nop
c00280d9:	c9                   	leave  
c00280da:	c3                   	ret    

c00280db <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c00280db:	55                   	push   %ebp
c00280dc:	89 e5                	mov    %esp,%ebp
c00280de:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00280e1:	8b 45 10             	mov    0x10(%ebp),%eax
c00280e4:	48                   	dec    %eax
c00280e5:	0f af 45 14          	imul   0x14(%ebp),%eax
c00280e9:	89 c2                	mov    %eax,%edx
c00280eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00280ee:	01 c2                	add    %eax,%edx
c00280f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00280f3:	48                   	dec    %eax
c00280f4:	0f af 45 14          	imul   0x14(%ebp),%eax
c00280f8:	89 c1                	mov    %eax,%ecx
c00280fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00280fd:	01 c8                	add    %ecx,%eax
c00280ff:	83 ec 04             	sub    $0x4,%esp
c0028102:	ff 75 1c             	pushl  0x1c(%ebp)
c0028105:	52                   	push   %edx
c0028106:	50                   	push   %eax
c0028107:	8b 45 18             	mov    0x18(%ebp),%eax
c002810a:	ff d0                	call   *%eax
c002810c:	83 c4 10             	add    $0x10,%esp
}
c002810f:	c9                   	leave  
c0028110:	c3                   	ret    

c0028111 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c0028111:	55                   	push   %ebp
c0028112:	89 e5                	mov    %esp,%ebp
c0028114:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c0028117:	8b 45 0c             	mov    0xc(%ebp),%eax
c002811a:	01 c0                	add    %eax,%eax
c002811c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c002811f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028122:	01 c0                	add    %eax,%eax
c0028124:	40                   	inc    %eax
c0028125:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c0028128:	8b 45 0c             	mov    0xc(%ebp),%eax
c002812b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c002812e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028131:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028134:	77 27                	ja     c002815d <heapify+0x4c>
c0028136:	83 ec 08             	sub    $0x8,%esp
c0028139:	ff 75 1c             	pushl  0x1c(%ebp)
c002813c:	ff 75 18             	pushl  0x18(%ebp)
c002813f:	ff 75 14             	pushl  0x14(%ebp)
c0028142:	ff 75 f4             	pushl  -0xc(%ebp)
c0028145:	ff 75 f0             	pushl  -0x10(%ebp)
c0028148:	ff 75 08             	pushl  0x8(%ebp)
c002814b:	e8 8b ff ff ff       	call   c00280db <do_compare>
c0028150:	83 c4 20             	add    $0x20,%esp
c0028153:	85 c0                	test   %eax,%eax
c0028155:	7e 06                	jle    c002815d <heapify+0x4c>
        max = left;
c0028157:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002815a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c002815d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028160:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028163:	77 27                	ja     c002818c <heapify+0x7b>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028165:	83 ec 08             	sub    $0x8,%esp
c0028168:	ff 75 1c             	pushl  0x1c(%ebp)
c002816b:	ff 75 18             	pushl  0x18(%ebp)
c002816e:	ff 75 14             	pushl  0x14(%ebp)
c0028171:	ff 75 f4             	pushl  -0xc(%ebp)
c0028174:	ff 75 ec             	pushl  -0x14(%ebp)
c0028177:	ff 75 08             	pushl  0x8(%ebp)
c002817a:	e8 5c ff ff ff       	call   c00280db <do_compare>
c002817f:	83 c4 20             	add    $0x20,%esp
c0028182:	85 c0                	test   %eax,%eax
c0028184:	7e 06                	jle    c002818c <heapify+0x7b>
        max = right;
c0028186:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028189:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c002818c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002818f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028192:	74 1f                	je     c00281b3 <heapify+0xa2>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0028194:	ff 75 14             	pushl  0x14(%ebp)
c0028197:	ff 75 f4             	pushl  -0xc(%ebp)
c002819a:	ff 75 0c             	pushl  0xc(%ebp)
c002819d:	ff 75 08             	pushl  0x8(%ebp)
c00281a0:	e8 c7 fe ff ff       	call   c002806c <do_swap>
c00281a5:	83 c4 10             	add    $0x10,%esp
      i = max;
c00281a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00281ab:	89 45 0c             	mov    %eax,0xc(%ebp)
    {
c00281ae:	e9 64 ff ff ff       	jmp    c0028117 <heapify+0x6>
        break;
c00281b3:	90                   	nop
    }
}
c00281b4:	90                   	nop
c00281b5:	c9                   	leave  
c00281b6:	c3                   	ret    

c00281b7 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c00281b7:	55                   	push   %ebp
c00281b8:	89 e5                	mov    %esp,%ebp
c00281ba:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c00281bd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00281c1:	75 27                	jne    c00281ea <sort+0x33>
c00281c3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00281c7:	74 21                	je     c00281ea <sort+0x33>
c00281c9:	83 ec 0c             	sub    $0xc,%esp
c00281cc:	68 a0 08 03 c0       	push   $0xc00308a0
c00281d1:	68 76 08 03 c0       	push   $0xc0030876
c00281d6:	68 dc 08 03 c0       	push   $0xc00308dc
c00281db:	68 8a 00 00 00       	push   $0x8a
c00281e0:	68 8d 08 03 c0       	push   $0xc003088d
c00281e5:	e8 3e 13 00 00       	call   c0029528 <debug_panic>
  ASSERT (compare != NULL);
c00281ea:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c00281ee:	75 21                	jne    c0028211 <sort+0x5a>
c00281f0:	83 ec 0c             	sub    $0xc,%esp
c00281f3:	68 ba 08 03 c0       	push   $0xc00308ba
c00281f8:	68 76 08 03 c0       	push   $0xc0030876
c00281fd:	68 dc 08 03 c0       	push   $0xc00308dc
c0028202:	68 8b 00 00 00       	push   $0x8b
c0028207:	68 8d 08 03 c0       	push   $0xc003088d
c002820c:	e8 17 13 00 00       	call   c0029528 <debug_panic>
  ASSERT (size > 0);
c0028211:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028215:	75 21                	jne    c0028238 <sort+0x81>
c0028217:	83 ec 0c             	sub    $0xc,%esp
c002821a:	68 ca 08 03 c0       	push   $0xc00308ca
c002821f:	68 76 08 03 c0       	push   $0xc0030876
c0028224:	68 dc 08 03 c0       	push   $0xc00308dc
c0028229:	68 8c 00 00 00       	push   $0x8c
c002822e:	68 8d 08 03 c0       	push   $0xc003088d
c0028233:	e8 f0 12 00 00       	call   c0029528 <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c0028238:	8b 45 0c             	mov    0xc(%ebp),%eax
c002823b:	d1 e8                	shr    %eax
c002823d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028240:	eb 20                	jmp    c0028262 <sort+0xab>
    heapify (array, i, cnt, size, compare, aux);
c0028242:	83 ec 08             	sub    $0x8,%esp
c0028245:	ff 75 18             	pushl  0x18(%ebp)
c0028248:	ff 75 14             	pushl  0x14(%ebp)
c002824b:	ff 75 10             	pushl  0x10(%ebp)
c002824e:	ff 75 0c             	pushl  0xc(%ebp)
c0028251:	ff 75 f4             	pushl  -0xc(%ebp)
c0028254:	ff 75 08             	pushl  0x8(%ebp)
c0028257:	e8 b5 fe ff ff       	call   c0028111 <heapify>
c002825c:	83 c4 20             	add    $0x20,%esp
  for (i = cnt / 2; i > 0; i--)
c002825f:	ff 4d f4             	decl   -0xc(%ebp)
c0028262:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028266:	75 da                	jne    c0028242 <sort+0x8b>

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0028268:	8b 45 0c             	mov    0xc(%ebp),%eax
c002826b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002826e:	eb 34                	jmp    c00282a4 <sort+0xed>
    {
      do_swap (array, 1, i, size);
c0028270:	ff 75 10             	pushl  0x10(%ebp)
c0028273:	ff 75 f4             	pushl  -0xc(%ebp)
c0028276:	6a 01                	push   $0x1
c0028278:	ff 75 08             	pushl  0x8(%ebp)
c002827b:	e8 ec fd ff ff       	call   c002806c <do_swap>
c0028280:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c0028283:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028286:	48                   	dec    %eax
c0028287:	83 ec 08             	sub    $0x8,%esp
c002828a:	ff 75 18             	pushl  0x18(%ebp)
c002828d:	ff 75 14             	pushl  0x14(%ebp)
c0028290:	ff 75 10             	pushl  0x10(%ebp)
c0028293:	50                   	push   %eax
c0028294:	6a 01                	push   $0x1
c0028296:	ff 75 08             	pushl  0x8(%ebp)
c0028299:	e8 73 fe ff ff       	call   c0028111 <heapify>
c002829e:	83 c4 20             	add    $0x20,%esp
  for (i = cnt; i > 1; i--) 
c00282a1:	ff 4d f4             	decl   -0xc(%ebp)
c00282a4:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c00282a8:	77 c6                	ja     c0028270 <sort+0xb9>
    }
}
c00282aa:	90                   	nop
c00282ab:	c9                   	leave  
c00282ac:	c3                   	ret    

c00282ad <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c00282ad:	55                   	push   %ebp
c00282ae:	89 e5                	mov    %esp,%ebp
c00282b0:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c00282b3:	83 ec 08             	sub    $0x8,%esp
c00282b6:	8d 45 18             	lea    0x18(%ebp),%eax
c00282b9:	50                   	push   %eax
c00282ba:	68 25 80 02 c0       	push   $0xc0028025
c00282bf:	ff 75 14             	pushl  0x14(%ebp)
c00282c2:	ff 75 10             	pushl  0x10(%ebp)
c00282c5:	ff 75 0c             	pushl  0xc(%ebp)
c00282c8:	ff 75 08             	pushl  0x8(%ebp)
c00282cb:	e8 05 00 00 00       	call   c00282d5 <binary_search>
c00282d0:	83 c4 20             	add    $0x20,%esp
}
c00282d3:	c9                   	leave  
c00282d4:	c3                   	ret    

c00282d5 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c00282d5:	55                   	push   %ebp
c00282d6:	89 e5                	mov    %esp,%ebp
c00282d8:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c00282db:	8b 45 0c             	mov    0xc(%ebp),%eax
c00282de:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c00282e1:	8b 45 14             	mov    0x14(%ebp),%eax
c00282e4:	0f af 45 10          	imul   0x10(%ebp),%eax
c00282e8:	89 c2                	mov    %eax,%edx
c00282ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c00282ed:	01 d0                	add    %edx,%eax
c00282ef:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c00282f2:	eb 65                	jmp    c0028359 <binary_search+0x84>
    {
      size_t range = (last - first) / size;
c00282f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00282f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00282fa:	29 c2                	sub    %eax,%edx
c00282fc:	89 d0                	mov    %edx,%eax
c00282fe:	ba 00 00 00 00       	mov    $0x0,%edx
c0028303:	f7 75 14             	divl   0x14(%ebp)
c0028306:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c0028309:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002830c:	d1 e8                	shr    %eax
c002830e:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028312:	89 c2                	mov    %eax,%edx
c0028314:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028317:	01 d0                	add    %edx,%eax
c0028319:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c002831c:	83 ec 04             	sub    $0x4,%esp
c002831f:	ff 75 1c             	pushl  0x1c(%ebp)
c0028322:	ff 75 e8             	pushl  -0x18(%ebp)
c0028325:	ff 75 08             	pushl  0x8(%ebp)
c0028328:	8b 45 18             	mov    0x18(%ebp),%eax
c002832b:	ff d0                	call   *%eax
c002832d:	83 c4 10             	add    $0x10,%esp
c0028330:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c0028333:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028337:	79 08                	jns    c0028341 <binary_search+0x6c>
        last = middle;
c0028339:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002833c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002833f:	eb 18                	jmp    c0028359 <binary_search+0x84>
      else if (cmp > 0) 
c0028341:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028345:	7e 0d                	jle    c0028354 <binary_search+0x7f>
        first = middle + size;
c0028347:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002834a:	8b 45 14             	mov    0x14(%ebp),%eax
c002834d:	01 d0                	add    %edx,%eax
c002834f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028352:	eb 05                	jmp    c0028359 <binary_search+0x84>
      else
        return (void *) middle;
c0028354:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028357:	eb 0d                	jmp    c0028366 <binary_search+0x91>
  while (first < last) 
c0028359:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002835c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002835f:	72 93                	jb     c00282f4 <binary_search+0x1f>
    }
  
  return NULL;
c0028361:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028366:	c9                   	leave  
c0028367:	c3                   	ret    

c0028368 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0028368:	55                   	push   %ebp
c0028369:	89 e5                	mov    %esp,%ebp
c002836b:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c002836e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028371:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028374:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028377:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c002837a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002837e:	75 24                	jne    c00283a4 <memcpy+0x3c>
c0028380:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028384:	74 1e                	je     c00283a4 <memcpy+0x3c>
c0028386:	83 ec 0c             	sub    $0xc,%esp
c0028389:	68 e4 08 03 c0       	push   $0xc00308e4
c002838e:	68 fd 08 03 c0       	push   $0xc00308fd
c0028393:	68 f4 09 03 c0       	push   $0xc00309f4
c0028398:	6a 0c                	push   $0xc
c002839a:	68 14 09 03 c0       	push   $0xc0030914
c002839f:	e8 84 11 00 00       	call   c0029528 <debug_panic>
  ASSERT (src != NULL || size == 0);
c00283a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00283a8:	75 3a                	jne    c00283e4 <memcpy+0x7c>
c00283aa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00283ae:	74 34                	je     c00283e4 <memcpy+0x7c>
c00283b0:	83 ec 0c             	sub    $0xc,%esp
c00283b3:	68 27 09 03 c0       	push   $0xc0030927
c00283b8:	68 fd 08 03 c0       	push   $0xc00308fd
c00283bd:	68 f4 09 03 c0       	push   $0xc00309f4
c00283c2:	6a 0d                	push   $0xd
c00283c4:	68 14 09 03 c0       	push   $0xc0030914
c00283c9:	e8 5a 11 00 00       	call   c0029528 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c00283ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283d1:	8d 50 01             	lea    0x1(%eax),%edx
c00283d4:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00283d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00283da:	8d 4a 01             	lea    0x1(%edx),%ecx
c00283dd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c00283e0:	8a 12                	mov    (%edx),%dl
c00283e2:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c00283e4:	8b 45 10             	mov    0x10(%ebp),%eax
c00283e7:	8d 50 ff             	lea    -0x1(%eax),%edx
c00283ea:	89 55 10             	mov    %edx,0x10(%ebp)
c00283ed:	85 c0                	test   %eax,%eax
c00283ef:	75 dd                	jne    c00283ce <memcpy+0x66>

  return dst_;
c00283f1:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00283f4:	c9                   	leave  
c00283f5:	c3                   	ret    

c00283f6 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c00283f6:	55                   	push   %ebp
c00283f7:	89 e5                	mov    %esp,%ebp
c00283f9:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c00283fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00283ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028402:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028405:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028408:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002840c:	75 24                	jne    c0028432 <memmove+0x3c>
c002840e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028412:	74 1e                	je     c0028432 <memmove+0x3c>
c0028414:	83 ec 0c             	sub    $0xc,%esp
c0028417:	68 e4 08 03 c0       	push   $0xc00308e4
c002841c:	68 fd 08 03 c0       	push   $0xc00308fd
c0028421:	68 fc 09 03 c0       	push   $0xc00309fc
c0028426:	6a 1d                	push   $0x1d
c0028428:	68 14 09 03 c0       	push   $0xc0030914
c002842d:	e8 f6 10 00 00       	call   c0029528 <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028432:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028436:	75 24                	jne    c002845c <memmove+0x66>
c0028438:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002843c:	74 1e                	je     c002845c <memmove+0x66>
c002843e:	83 ec 0c             	sub    $0xc,%esp
c0028441:	68 27 09 03 c0       	push   $0xc0030927
c0028446:	68 fd 08 03 c0       	push   $0xc00308fd
c002844b:	68 fc 09 03 c0       	push   $0xc00309fc
c0028450:	6a 1e                	push   $0x1e
c0028452:	68 14 09 03 c0       	push   $0xc0030914
c0028457:	e8 cc 10 00 00       	call   c0029528 <debug_panic>

  if (dst < src) 
c002845c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002845f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028462:	73 27                	jae    c002848b <memmove+0x95>
    {
      while (size-- > 0)
c0028464:	eb 16                	jmp    c002847c <memmove+0x86>
        *dst++ = *src++;
c0028466:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028469:	8d 50 01             	lea    0x1(%eax),%edx
c002846c:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002846f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028472:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028475:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028478:	8a 12                	mov    (%edx),%dl
c002847a:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c002847c:	8b 45 10             	mov    0x10(%ebp),%eax
c002847f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028482:	89 55 10             	mov    %edx,0x10(%ebp)
c0028485:	85 c0                	test   %eax,%eax
c0028487:	75 dd                	jne    c0028466 <memmove+0x70>
c0028489:	eb 2b                	jmp    c00284b6 <memmove+0xc0>
    }
  else 
    {
      dst += size;
c002848b:	8b 45 10             	mov    0x10(%ebp),%eax
c002848e:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c0028491:	8b 45 10             	mov    0x10(%ebp),%eax
c0028494:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c0028497:	eb 10                	jmp    c00284a9 <memmove+0xb3>
        *--dst = *--src;
c0028499:	ff 4d f4             	decl   -0xc(%ebp)
c002849c:	ff 4d f0             	decl   -0x10(%ebp)
c002849f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00284a2:	8a 10                	mov    (%eax),%dl
c00284a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00284a7:	88 10                	mov    %dl,(%eax)
      while (size-- > 0)
c00284a9:	8b 45 10             	mov    0x10(%ebp),%eax
c00284ac:	8d 50 ff             	lea    -0x1(%eax),%edx
c00284af:	89 55 10             	mov    %edx,0x10(%ebp)
c00284b2:	85 c0                	test   %eax,%eax
c00284b4:	75 e3                	jne    c0028499 <memmove+0xa3>
    }

  return dst;
c00284b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00284b9:	c9                   	leave  
c00284ba:	c3                   	ret    

c00284bb <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c00284bb:	55                   	push   %ebp
c00284bc:	89 e5                	mov    %esp,%ebp
c00284be:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c00284c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00284c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c00284c7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00284ca:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c00284cd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00284d1:	75 24                	jne    c00284f7 <memcmp+0x3c>
c00284d3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00284d7:	74 1e                	je     c00284f7 <memcmp+0x3c>
c00284d9:	83 ec 0c             	sub    $0xc,%esp
c00284dc:	68 40 09 03 c0       	push   $0xc0030940
c00284e1:	68 fd 08 03 c0       	push   $0xc00308fd
c00284e6:	68 04 0a 03 c0       	push   $0xc0030a04
c00284eb:	6a 3a                	push   $0x3a
c00284ed:	68 14 09 03 c0       	push   $0xc0030914
c00284f2:	e8 31 10 00 00       	call   c0029528 <debug_panic>
  ASSERT (b != NULL || size == 0);
c00284f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00284fb:	75 54                	jne    c0028551 <memcmp+0x96>
c00284fd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028501:	74 4e                	je     c0028551 <memcmp+0x96>
c0028503:	83 ec 0c             	sub    $0xc,%esp
c0028506:	68 57 09 03 c0       	push   $0xc0030957
c002850b:	68 fd 08 03 c0       	push   $0xc00308fd
c0028510:	68 04 0a 03 c0       	push   $0xc0030a04
c0028515:	6a 3b                	push   $0x3b
c0028517:	68 14 09 03 c0       	push   $0xc0030914
c002851c:	e8 07 10 00 00       	call   c0029528 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0028521:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028524:	8a 10                	mov    (%eax),%dl
c0028526:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028529:	8a 00                	mov    (%eax),%al
c002852b:	38 c2                	cmp    %al,%dl
c002852d:	74 1c                	je     c002854b <memcmp+0x90>
      return *a > *b ? +1 : -1;
c002852f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028532:	8a 10                	mov    (%eax),%dl
c0028534:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028537:	8a 00                	mov    (%eax),%al
c0028539:	38 c2                	cmp    %al,%dl
c002853b:	76 07                	jbe    c0028544 <memcmp+0x89>
c002853d:	b8 01 00 00 00       	mov    $0x1,%eax
c0028542:	eb 1f                	jmp    c0028563 <memcmp+0xa8>
c0028544:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028549:	eb 18                	jmp    c0028563 <memcmp+0xa8>
  for (; size-- > 0; a++, b++)
c002854b:	ff 45 f4             	incl   -0xc(%ebp)
c002854e:	ff 45 f0             	incl   -0x10(%ebp)
c0028551:	8b 45 10             	mov    0x10(%ebp),%eax
c0028554:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028557:	89 55 10             	mov    %edx,0x10(%ebp)
c002855a:	85 c0                	test   %eax,%eax
c002855c:	75 c3                	jne    c0028521 <memcmp+0x66>
  return 0;
c002855e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028563:	c9                   	leave  
c0028564:	c3                   	ret    

c0028565 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0028565:	55                   	push   %ebp
c0028566:	89 e5                	mov    %esp,%ebp
c0028568:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c002856b:	8b 45 08             	mov    0x8(%ebp),%eax
c002856e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c0028571:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028574:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c0028577:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002857b:	75 1e                	jne    c002859b <strcmp+0x36>
c002857d:	83 ec 0c             	sub    $0xc,%esp
c0028580:	68 6e 09 03 c0       	push   $0xc003096e
c0028585:	68 fd 08 03 c0       	push   $0xc00308fd
c002858a:	68 0c 0a 03 c0       	push   $0xc0030a0c
c002858f:	6a 4e                	push   $0x4e
c0028591:	68 14 09 03 c0       	push   $0xc0030914
c0028596:	e8 8d 0f 00 00       	call   c0029528 <debug_panic>
  ASSERT (b != NULL);
c002859b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002859f:	75 24                	jne    c00285c5 <strcmp+0x60>
c00285a1:	83 ec 0c             	sub    $0xc,%esp
c00285a4:	68 78 09 03 c0       	push   $0xc0030978
c00285a9:	68 fd 08 03 c0       	push   $0xc00308fd
c00285ae:	68 0c 0a 03 c0       	push   $0xc0030a0c
c00285b3:	6a 4f                	push   $0x4f
c00285b5:	68 14 09 03 c0       	push   $0xc0030914
c00285ba:	e8 69 0f 00 00       	call   c0029528 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c00285bf:	ff 45 f4             	incl   -0xc(%ebp)
      b++;
c00285c2:	ff 45 f0             	incl   -0x10(%ebp)
  while (*a != '\0' && *a == *b) 
c00285c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285c8:	8a 00                	mov    (%eax),%al
c00285ca:	84 c0                	test   %al,%al
c00285cc:	74 0e                	je     c00285dc <strcmp+0x77>
c00285ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285d1:	8a 10                	mov    (%eax),%dl
c00285d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285d6:	8a 00                	mov    (%eax),%al
c00285d8:	38 c2                	cmp    %al,%dl
c00285da:	74 e3                	je     c00285bf <strcmp+0x5a>
    }

  return *a < *b ? -1 : *a > *b;
c00285dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285df:	8a 10                	mov    (%eax),%dl
c00285e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285e4:	8a 00                	mov    (%eax),%al
c00285e6:	38 c2                	cmp    %al,%dl
c00285e8:	72 14                	jb     c00285fe <strcmp+0x99>
c00285ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00285ed:	8a 10                	mov    (%eax),%dl
c00285ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00285f2:	8a 00                	mov    (%eax),%al
c00285f4:	38 c2                	cmp    %al,%dl
c00285f6:	0f 97 c0             	seta   %al
c00285f9:	0f b6 c0             	movzbl %al,%eax
c00285fc:	eb 05                	jmp    c0028603 <strcmp+0x9e>
c00285fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028603:	c9                   	leave  
c0028604:	c3                   	ret    

c0028605 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0028605:	55                   	push   %ebp
c0028606:	89 e5                	mov    %esp,%ebp
c0028608:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c002860b:	8b 45 08             	mov    0x8(%ebp),%eax
c002860e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c0028611:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028614:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c0028617:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002861b:	75 36                	jne    c0028653 <memchr+0x4e>
c002861d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028621:	74 30                	je     c0028653 <memchr+0x4e>
c0028623:	83 ec 0c             	sub    $0xc,%esp
c0028626:	68 82 09 03 c0       	push   $0xc0030982
c002862b:	68 fd 08 03 c0       	push   $0xc00308fd
c0028630:	68 14 0a 03 c0       	push   $0xc0030a14
c0028635:	6a 63                	push   $0x63
c0028637:	68 14 09 03 c0       	push   $0xc0030914
c002863c:	e8 e7 0e 00 00       	call   c0029528 <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c0028641:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028644:	8a 00                	mov    (%eax),%al
c0028646:	3a 45 f3             	cmp    -0xd(%ebp),%al
c0028649:	75 05                	jne    c0028650 <memchr+0x4b>
      return (void *) block;
c002864b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002864e:	eb 15                	jmp    c0028665 <memchr+0x60>
  for (; size-- > 0; block++)
c0028650:	ff 45 f4             	incl   -0xc(%ebp)
c0028653:	8b 45 10             	mov    0x10(%ebp),%eax
c0028656:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028659:	89 55 10             	mov    %edx,0x10(%ebp)
c002865c:	85 c0                	test   %eax,%eax
c002865e:	75 e1                	jne    c0028641 <memchr+0x3c>

  return NULL;
c0028660:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028665:	c9                   	leave  
c0028666:	c3                   	ret    

c0028667 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0028667:	55                   	push   %ebp
c0028668:	89 e5                	mov    %esp,%ebp
c002866a:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c002866d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028670:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c0028673:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028677:	75 1e                	jne    c0028697 <strchr+0x30>
c0028679:	83 ec 0c             	sub    $0xc,%esp
c002867c:	68 9d 09 03 c0       	push   $0xc003099d
c0028681:	68 fd 08 03 c0       	push   $0xc00308fd
c0028686:	68 1c 0a 03 c0       	push   $0xc0030a1c
c002868b:	6a 75                	push   $0x75
c002868d:	68 14 09 03 c0       	push   $0xc0030914
c0028692:	e8 91 0e 00 00       	call   c0029528 <debug_panic>

  for (;;) 
    if (*string == c)
c0028697:	8b 45 08             	mov    0x8(%ebp),%eax
c002869a:	8a 00                	mov    (%eax),%al
c002869c:	3a 45 f7             	cmp    -0x9(%ebp),%al
c002869f:	75 05                	jne    c00286a6 <strchr+0x3f>
      return (char *) string;
c00286a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00286a4:	eb 15                	jmp    c00286bb <strchr+0x54>
    else if (*string == '\0')
c00286a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00286a9:	8a 00                	mov    (%eax),%al
c00286ab:	84 c0                	test   %al,%al
c00286ad:	75 07                	jne    c00286b6 <strchr+0x4f>
      return NULL;
c00286af:	b8 00 00 00 00       	mov    $0x0,%eax
c00286b4:	eb 05                	jmp    c00286bb <strchr+0x54>
    else
      string++;
c00286b6:	ff 45 08             	incl   0x8(%ebp)
    if (*string == c)
c00286b9:	eb dc                	jmp    c0028697 <strchr+0x30>
}
c00286bb:	c9                   	leave  
c00286bc:	c3                   	ret    

c00286bd <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c00286bd:	55                   	push   %ebp
c00286be:	89 e5                	mov    %esp,%ebp
c00286c0:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c00286c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00286ca:	eb 23                	jmp    c00286ef <strcspn+0x32>
    if (strchr (stop, string[length]) != NULL)
c00286cc:	8b 55 08             	mov    0x8(%ebp),%edx
c00286cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286d2:	01 d0                	add    %edx,%eax
c00286d4:	8a 00                	mov    (%eax),%al
c00286d6:	0f be c0             	movsbl %al,%eax
c00286d9:	83 ec 08             	sub    $0x8,%esp
c00286dc:	50                   	push   %eax
c00286dd:	ff 75 0c             	pushl  0xc(%ebp)
c00286e0:	e8 82 ff ff ff       	call   c0028667 <strchr>
c00286e5:	83 c4 10             	add    $0x10,%esp
c00286e8:	85 c0                	test   %eax,%eax
c00286ea:	75 13                	jne    c00286ff <strcspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c00286ec:	ff 45 f4             	incl   -0xc(%ebp)
c00286ef:	8b 55 08             	mov    0x8(%ebp),%edx
c00286f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286f5:	01 d0                	add    %edx,%eax
c00286f7:	8a 00                	mov    (%eax),%al
c00286f9:	84 c0                	test   %al,%al
c00286fb:	75 cf                	jne    c00286cc <strcspn+0xf>
c00286fd:	eb 01                	jmp    c0028700 <strcspn+0x43>
      break;
c00286ff:	90                   	nop
  return length;
c0028700:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028703:	c9                   	leave  
c0028704:	c3                   	ret    

c0028705 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c0028705:	55                   	push   %ebp
c0028706:	89 e5                	mov    %esp,%ebp
c0028708:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c002870b:	eb 23                	jmp    c0028730 <strpbrk+0x2b>
    if (strchr (stop, *string) != NULL)
c002870d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028710:	8a 00                	mov    (%eax),%al
c0028712:	0f be c0             	movsbl %al,%eax
c0028715:	83 ec 08             	sub    $0x8,%esp
c0028718:	50                   	push   %eax
c0028719:	ff 75 0c             	pushl  0xc(%ebp)
c002871c:	e8 46 ff ff ff       	call   c0028667 <strchr>
c0028721:	83 c4 10             	add    $0x10,%esp
c0028724:	85 c0                	test   %eax,%eax
c0028726:	74 05                	je     c002872d <strpbrk+0x28>
      return (char *) string;
c0028728:	8b 45 08             	mov    0x8(%ebp),%eax
c002872b:	eb 11                	jmp    c002873e <strpbrk+0x39>
  for (; *string != '\0'; string++)
c002872d:	ff 45 08             	incl   0x8(%ebp)
c0028730:	8b 45 08             	mov    0x8(%ebp),%eax
c0028733:	8a 00                	mov    (%eax),%al
c0028735:	84 c0                	test   %al,%al
c0028737:	75 d4                	jne    c002870d <strpbrk+0x8>
  return NULL;
c0028739:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002873e:	c9                   	leave  
c002873f:	c3                   	ret    

c0028740 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0028740:	55                   	push   %ebp
c0028741:	89 e5                	mov    %esp,%ebp
c0028743:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c0028746:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028749:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c002874c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c0028753:	eb 13                	jmp    c0028768 <strrchr+0x28>
    if (*string == c)
c0028755:	8b 45 08             	mov    0x8(%ebp),%eax
c0028758:	8a 00                	mov    (%eax),%al
c002875a:	3a 45 fb             	cmp    -0x5(%ebp),%al
c002875d:	75 06                	jne    c0028765 <strrchr+0x25>
      p = string;
c002875f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028762:	89 45 fc             	mov    %eax,-0x4(%ebp)
  for (; *string != '\0'; string++)
c0028765:	ff 45 08             	incl   0x8(%ebp)
c0028768:	8b 45 08             	mov    0x8(%ebp),%eax
c002876b:	8a 00                	mov    (%eax),%al
c002876d:	84 c0                	test   %al,%al
c002876f:	75 e4                	jne    c0028755 <strrchr+0x15>
  return (char *) p;
c0028771:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028774:	c9                   	leave  
c0028775:	c3                   	ret    

c0028776 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0028776:	55                   	push   %ebp
c0028777:	89 e5                	mov    %esp,%ebp
c0028779:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c002877c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028783:	eb 23                	jmp    c00287a8 <strspn+0x32>
    if (strchr (skip, string[length]) == NULL)
c0028785:	8b 55 08             	mov    0x8(%ebp),%edx
c0028788:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002878b:	01 d0                	add    %edx,%eax
c002878d:	8a 00                	mov    (%eax),%al
c002878f:	0f be c0             	movsbl %al,%eax
c0028792:	83 ec 08             	sub    $0x8,%esp
c0028795:	50                   	push   %eax
c0028796:	ff 75 0c             	pushl  0xc(%ebp)
c0028799:	e8 c9 fe ff ff       	call   c0028667 <strchr>
c002879e:	83 c4 10             	add    $0x10,%esp
c00287a1:	85 c0                	test   %eax,%eax
c00287a3:	74 13                	je     c00287b8 <strspn+0x42>
  for (length = 0; string[length] != '\0'; length++)
c00287a5:	ff 45 f4             	incl   -0xc(%ebp)
c00287a8:	8b 55 08             	mov    0x8(%ebp),%edx
c00287ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287ae:	01 d0                	add    %edx,%eax
c00287b0:	8a 00                	mov    (%eax),%al
c00287b2:	84 c0                	test   %al,%al
c00287b4:	75 cf                	jne    c0028785 <strspn+0xf>
c00287b6:	eb 01                	jmp    c00287b9 <strspn+0x43>
      break;
c00287b8:	90                   	nop
  return length;
c00287b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00287bc:	c9                   	leave  
c00287bd:	c3                   	ret    

c00287be <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c00287be:	55                   	push   %ebp
c00287bf:	89 e5                	mov    %esp,%ebp
c00287c1:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c00287c4:	83 ec 0c             	sub    $0xc,%esp
c00287c7:	ff 75 08             	pushl  0x8(%ebp)
c00287ca:	e8 cc 01 00 00       	call   c002899b <strlen>
c00287cf:	83 c4 10             	add    $0x10,%esp
c00287d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c00287d5:	83 ec 0c             	sub    $0xc,%esp
c00287d8:	ff 75 0c             	pushl  0xc(%ebp)
c00287db:	e8 bb 01 00 00       	call   c002899b <strlen>
c00287e0:	83 c4 10             	add    $0x10,%esp
c00287e3:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c00287e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287e9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00287ec:	72 3f                	jb     c002882d <strstr+0x6f>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c00287ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00287f5:	eb 2b                	jmp    c0028822 <strstr+0x64>
        if (!memcmp (haystack + i, needle, needle_len))
c00287f7:	8b 55 08             	mov    0x8(%ebp),%edx
c00287fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00287fd:	01 d0                	add    %edx,%eax
c00287ff:	83 ec 04             	sub    $0x4,%esp
c0028802:	ff 75 ec             	pushl  -0x14(%ebp)
c0028805:	ff 75 0c             	pushl  0xc(%ebp)
c0028808:	50                   	push   %eax
c0028809:	e8 ad fc ff ff       	call   c00284bb <memcmp>
c002880e:	83 c4 10             	add    $0x10,%esp
c0028811:	85 c0                	test   %eax,%eax
c0028813:	75 0a                	jne    c002881f <strstr+0x61>
          return (char *) haystack + i;
c0028815:	8b 55 08             	mov    0x8(%ebp),%edx
c0028818:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002881b:	01 d0                	add    %edx,%eax
c002881d:	eb 13                	jmp    c0028832 <strstr+0x74>
      for (i = 0; i <= haystack_len - needle_len; i++)
c002881f:	ff 45 f4             	incl   -0xc(%ebp)
c0028822:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028825:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028828:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002882b:	73 ca                	jae    c00287f7 <strstr+0x39>
    }

  return NULL;
c002882d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028832:	c9                   	leave  
c0028833:	c3                   	ret    

c0028834 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028834:	55                   	push   %ebp
c0028835:	89 e5                	mov    %esp,%ebp
c0028837:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c002883a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002883e:	75 21                	jne    c0028861 <strtok_r+0x2d>
c0028840:	83 ec 0c             	sub    $0xc,%esp
c0028843:	68 ac 09 03 c0       	push   $0xc00309ac
c0028848:	68 fd 08 03 c0       	push   $0xc00308fd
c002884d:	68 24 0a 03 c0       	push   $0xc0030a24
c0028852:	68 ef 00 00 00       	push   $0xef
c0028857:	68 14 09 03 c0       	push   $0xc0030914
c002885c:	e8 c7 0c 00 00       	call   c0029528 <debug_panic>
  ASSERT (save_ptr != NULL);
c0028861:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028865:	75 21                	jne    c0028888 <strtok_r+0x54>
c0028867:	83 ec 0c             	sub    $0xc,%esp
c002886a:	68 bf 09 03 c0       	push   $0xc00309bf
c002886f:	68 fd 08 03 c0       	push   $0xc00308fd
c0028874:	68 24 0a 03 c0       	push   $0xc0030a24
c0028879:	68 f0 00 00 00       	push   $0xf0
c002887e:	68 14 09 03 c0       	push   $0xc0030914
c0028883:	e8 a0 0c 00 00       	call   c0029528 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028888:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002888c:	75 08                	jne    c0028896 <strtok_r+0x62>
    s = *save_ptr;
c002888e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028891:	8b 00                	mov    (%eax),%eax
c0028893:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c0028896:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002889a:	75 3c                	jne    c00288d8 <strtok_r+0xa4>
c002889c:	83 ec 0c             	sub    $0xc,%esp
c002889f:	68 d0 09 03 c0       	push   $0xc00309d0
c00288a4:	68 fd 08 03 c0       	push   $0xc00308fd
c00288a9:	68 24 0a 03 c0       	push   $0xc0030a24
c00288ae:	68 f6 00 00 00       	push   $0xf6
c00288b3:	68 14 09 03 c0       	push   $0xc0030914
c00288b8:	e8 6b 0c 00 00       	call   c0029528 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c00288bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00288c0:	8a 00                	mov    (%eax),%al
c00288c2:	84 c0                	test   %al,%al
c00288c4:	75 0f                	jne    c00288d5 <strtok_r+0xa1>
        {
          *save_ptr = s;
c00288c6:	8b 45 10             	mov    0x10(%ebp),%eax
c00288c9:	8b 55 08             	mov    0x8(%ebp),%edx
c00288cc:	89 10                	mov    %edx,(%eax)
          return NULL;
c00288ce:	b8 00 00 00 00       	mov    $0x0,%eax
c00288d3:	eb 6b                	jmp    c0028940 <strtok_r+0x10c>
        }

      s++;
c00288d5:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) != NULL) 
c00288d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00288db:	8a 00                	mov    (%eax),%al
c00288dd:	0f be c0             	movsbl %al,%eax
c00288e0:	83 ec 08             	sub    $0x8,%esp
c00288e3:	50                   	push   %eax
c00288e4:	ff 75 0c             	pushl  0xc(%ebp)
c00288e7:	e8 7b fd ff ff       	call   c0028667 <strchr>
c00288ec:	83 c4 10             	add    $0x10,%esp
c00288ef:	85 c0                	test   %eax,%eax
c00288f1:	75 ca                	jne    c00288bd <strtok_r+0x89>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c00288f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00288f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c00288f9:	eb 03                	jmp    c00288fe <strtok_r+0xca>
    s++;
c00288fb:	ff 45 08             	incl   0x8(%ebp)
  while (strchr (delimiters, *s) == NULL)
c00288fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0028901:	8a 00                	mov    (%eax),%al
c0028903:	0f be c0             	movsbl %al,%eax
c0028906:	83 ec 08             	sub    $0x8,%esp
c0028909:	50                   	push   %eax
c002890a:	ff 75 0c             	pushl  0xc(%ebp)
c002890d:	e8 55 fd ff ff       	call   c0028667 <strchr>
c0028912:	83 c4 10             	add    $0x10,%esp
c0028915:	85 c0                	test   %eax,%eax
c0028917:	74 e2                	je     c00288fb <strtok_r+0xc7>
  if (*s != '\0') 
c0028919:	8b 45 08             	mov    0x8(%ebp),%eax
c002891c:	8a 00                	mov    (%eax),%al
c002891e:	84 c0                	test   %al,%al
c0028920:	74 13                	je     c0028935 <strtok_r+0x101>
    {
      *s = '\0';
c0028922:	8b 45 08             	mov    0x8(%ebp),%eax
c0028925:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0028928:	8b 45 08             	mov    0x8(%ebp),%eax
c002892b:	8d 50 01             	lea    0x1(%eax),%edx
c002892e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028931:	89 10                	mov    %edx,(%eax)
c0028933:	eb 08                	jmp    c002893d <strtok_r+0x109>
    }
  else 
    *save_ptr = s;
c0028935:	8b 45 10             	mov    0x10(%ebp),%eax
c0028938:	8b 55 08             	mov    0x8(%ebp),%edx
c002893b:	89 10                	mov    %edx,(%eax)
  return token;
c002893d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028940:	c9                   	leave  
c0028941:	c3                   	ret    

c0028942 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c0028942:	55                   	push   %ebp
c0028943:	89 e5                	mov    %esp,%ebp
c0028945:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028948:	8b 45 08             	mov    0x8(%ebp),%eax
c002894b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c002894e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028952:	75 35                	jne    c0028989 <memset+0x47>
c0028954:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028958:	74 2f                	je     c0028989 <memset+0x47>
c002895a:	83 ec 0c             	sub    $0xc,%esp
c002895d:	68 e4 08 03 c0       	push   $0xc00308e4
c0028962:	68 fd 08 03 c0       	push   $0xc00308fd
c0028967:	68 30 0a 03 c0       	push   $0xc0030a30
c002896c:	68 1b 01 00 00       	push   $0x11b
c0028971:	68 14 09 03 c0       	push   $0xc0030914
c0028976:	e8 ad 0b 00 00       	call   c0029528 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c002897b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002897e:	8d 50 01             	lea    0x1(%eax),%edx
c0028981:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028984:	8b 55 0c             	mov    0xc(%ebp),%edx
c0028987:	88 10                	mov    %dl,(%eax)
  while (size-- > 0)
c0028989:	8b 45 10             	mov    0x10(%ebp),%eax
c002898c:	8d 50 ff             	lea    -0x1(%eax),%edx
c002898f:	89 55 10             	mov    %edx,0x10(%ebp)
c0028992:	85 c0                	test   %eax,%eax
c0028994:	75 e5                	jne    c002897b <memset+0x39>

  return dst_;
c0028996:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0028999:	c9                   	leave  
c002899a:	c3                   	ret    

c002899b <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c002899b:	55                   	push   %ebp
c002899c:	89 e5                	mov    %esp,%ebp
c002899e:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c00289a1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00289a5:	75 21                	jne    c00289c8 <strlen+0x2d>
c00289a7:	83 ec 0c             	sub    $0xc,%esp
c00289aa:	68 9d 09 03 c0       	push   $0xc003099d
c00289af:	68 fd 08 03 c0       	push   $0xc00308fd
c00289b4:	68 38 0a 03 c0       	push   $0xc0030a38
c00289b9:	68 29 01 00 00       	push   $0x129
c00289be:	68 14 09 03 c0       	push   $0xc0030914
c00289c3:	e8 60 0b 00 00       	call   c0029528 <debug_panic>

  for (p = string; *p != '\0'; p++)
c00289c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00289cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00289ce:	eb 03                	jmp    c00289d3 <strlen+0x38>
c00289d0:	ff 45 f4             	incl   -0xc(%ebp)
c00289d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289d6:	8a 00                	mov    (%eax),%al
c00289d8:	84 c0                	test   %al,%al
c00289da:	75 f4                	jne    c00289d0 <strlen+0x35>
    continue;
  return p - string;
c00289dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00289df:	8b 45 08             	mov    0x8(%ebp),%eax
c00289e2:	29 c2                	sub    %eax,%edx
c00289e4:	89 d0                	mov    %edx,%eax
}
c00289e6:	c9                   	leave  
c00289e7:	c3                   	ret    

c00289e8 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00289e8:	55                   	push   %ebp
c00289e9:	89 e5                	mov    %esp,%ebp
c00289eb:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00289ee:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00289f5:	eb 03                	jmp    c00289fa <strnlen+0x12>
c00289f7:	ff 45 fc             	incl   -0x4(%ebp)
c00289fa:	8b 55 08             	mov    0x8(%ebp),%edx
c00289fd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028a00:	01 d0                	add    %edx,%eax
c0028a02:	8a 00                	mov    (%eax),%al
c0028a04:	84 c0                	test   %al,%al
c0028a06:	74 08                	je     c0028a10 <strnlen+0x28>
c0028a08:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028a0b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028a0e:	72 e7                	jb     c00289f7 <strnlen+0xf>
    continue;
  return length;
c0028a10:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028a13:	c9                   	leave  
c0028a14:	c3                   	ret    

c0028a15 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c0028a15:	55                   	push   %ebp
c0028a16:	89 e5                	mov    %esp,%ebp
c0028a18:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c0028a1b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028a1f:	75 21                	jne    c0028a42 <strlcpy+0x2d>
c0028a21:	83 ec 0c             	sub    $0xc,%esp
c0028a24:	68 da 09 03 c0       	push   $0xc00309da
c0028a29:	68 fd 08 03 c0       	push   $0xc00308fd
c0028a2e:	68 40 0a 03 c0       	push   $0xc0030a40
c0028a33:	68 4a 01 00 00       	push   $0x14a
c0028a38:	68 14 09 03 c0       	push   $0xc0030914
c0028a3d:	e8 e6 0a 00 00       	call   c0029528 <debug_panic>
  ASSERT (src != NULL);
c0028a42:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028a46:	75 21                	jne    c0028a69 <strlcpy+0x54>
c0028a48:	83 ec 0c             	sub    $0xc,%esp
c0028a4b:	68 e6 09 03 c0       	push   $0xc00309e6
c0028a50:	68 fd 08 03 c0       	push   $0xc00308fd
c0028a55:	68 40 0a 03 c0       	push   $0xc0030a40
c0028a5a:	68 4b 01 00 00       	push   $0x14b
c0028a5f:	68 14 09 03 c0       	push   $0xc0030914
c0028a64:	e8 bf 0a 00 00       	call   c0029528 <debug_panic>

  src_len = strlen (src);
c0028a69:	83 ec 0c             	sub    $0xc,%esp
c0028a6c:	ff 75 0c             	pushl  0xc(%ebp)
c0028a6f:	e8 27 ff ff ff       	call   c002899b <strlen>
c0028a74:	83 c4 10             	add    $0x10,%esp
c0028a77:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c0028a7a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a7e:	74 34                	je     c0028ab4 <strlcpy+0x9f>
    {
      size_t dst_len = size - 1;
c0028a80:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a83:	48                   	dec    %eax
c0028a84:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c0028a87:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a8a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028a8d:	73 06                	jae    c0028a95 <strlcpy+0x80>
        dst_len = src_len;
c0028a8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028a92:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c0028a95:	83 ec 04             	sub    $0x4,%esp
c0028a98:	ff 75 f4             	pushl  -0xc(%ebp)
c0028a9b:	ff 75 0c             	pushl  0xc(%ebp)
c0028a9e:	ff 75 08             	pushl  0x8(%ebp)
c0028aa1:	e8 c2 f8 ff ff       	call   c0028368 <memcpy>
c0028aa6:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c0028aa9:	8b 55 08             	mov    0x8(%ebp),%edx
c0028aac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028aaf:	01 d0                	add    %edx,%eax
c0028ab1:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c0028ab4:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028ab7:	c9                   	leave  
c0028ab8:	c3                   	ret    

c0028ab9 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c0028ab9:	55                   	push   %ebp
c0028aba:	89 e5                	mov    %esp,%ebp
c0028abc:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0028abf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028ac3:	75 21                	jne    c0028ae6 <strlcat+0x2d>
c0028ac5:	83 ec 0c             	sub    $0xc,%esp
c0028ac8:	68 da 09 03 c0       	push   $0xc00309da
c0028acd:	68 fd 08 03 c0       	push   $0xc00308fd
c0028ad2:	68 48 0a 03 c0       	push   $0xc0030a48
c0028ad7:	68 68 01 00 00       	push   $0x168
c0028adc:	68 14 09 03 c0       	push   $0xc0030914
c0028ae1:	e8 42 0a 00 00       	call   c0029528 <debug_panic>
  ASSERT (src != NULL);
c0028ae6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028aea:	75 21                	jne    c0028b0d <strlcat+0x54>
c0028aec:	83 ec 0c             	sub    $0xc,%esp
c0028aef:	68 e6 09 03 c0       	push   $0xc00309e6
c0028af4:	68 fd 08 03 c0       	push   $0xc00308fd
c0028af9:	68 48 0a 03 c0       	push   $0xc0030a48
c0028afe:	68 69 01 00 00       	push   $0x169
c0028b03:	68 14 09 03 c0       	push   $0xc0030914
c0028b08:	e8 1b 0a 00 00       	call   c0029528 <debug_panic>

  src_len = strlen (src);
c0028b0d:	83 ec 0c             	sub    $0xc,%esp
c0028b10:	ff 75 0c             	pushl  0xc(%ebp)
c0028b13:	e8 83 fe ff ff       	call   c002899b <strlen>
c0028b18:	83 c4 10             	add    $0x10,%esp
c0028b1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c0028b1e:	83 ec 0c             	sub    $0xc,%esp
c0028b21:	ff 75 08             	pushl  0x8(%ebp)
c0028b24:	e8 72 fe ff ff       	call   c002899b <strlen>
c0028b29:	83 c4 10             	add    $0x10,%esp
c0028b2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c0028b2f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b33:	74 4a                	je     c0028b7f <strlcat+0xc6>
c0028b35:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b38:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028b3b:	73 42                	jae    c0028b7f <strlcat+0xc6>
    {
      size_t copy_cnt = size - dst_len - 1;
c0028b3d:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b40:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028b43:	48                   	dec    %eax
c0028b44:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c0028b47:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b4a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028b4d:	73 06                	jae    c0028b55 <strlcat+0x9c>
        copy_cnt = src_len;
c0028b4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b52:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c0028b55:	8b 55 08             	mov    0x8(%ebp),%edx
c0028b58:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b5b:	01 d0                	add    %edx,%eax
c0028b5d:	83 ec 04             	sub    $0x4,%esp
c0028b60:	ff 75 f4             	pushl  -0xc(%ebp)
c0028b63:	ff 75 0c             	pushl  0xc(%ebp)
c0028b66:	50                   	push   %eax
c0028b67:	e8 fc f7 ff ff       	call   c0028368 <memcpy>
c0028b6c:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c0028b6f:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b75:	01 c2                	add    %eax,%edx
c0028b77:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b7a:	01 d0                	add    %edx,%eax
c0028b7c:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c0028b7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028b82:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028b85:	01 d0                	add    %edx,%eax
}
c0028b87:	c9                   	leave  
c0028b88:	c3                   	ret    

c0028b89 <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c0028b89:	55                   	push   %ebp
c0028b8a:	89 e5                	mov    %esp,%ebp
c0028b8c:	83 ec 18             	sub    $0x18,%esp
c0028b8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b92:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028b95:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028b98:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0028b9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028b9e:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028ba1:	89 d0                	mov    %edx,%eax
c0028ba3:	31 d2                	xor    %edx,%edx
c0028ba5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c0028ba8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028bab:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0028bae:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0028bb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0028bb4:	f7 75 10             	divl   0x10(%ebp)
c0028bb7:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028bba:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c0028bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0028bc0:	c9                   	leave  
c0028bc1:	c3                   	ret    

c0028bc2 <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c0028bc2:	55                   	push   %ebp
c0028bc3:	89 e5                	mov    %esp,%ebp
c0028bc5:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c0028bc8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c0028bcf:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c0028bd6:	77 08                	ja     c0028be0 <nlz+0x1e>
    {
      n += 16;
c0028bd8:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c0028bdc:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c0028be0:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c0028be7:	77 08                	ja     c0028bf1 <nlz+0x2f>
    {
      n += 8;
c0028be9:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c0028bed:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c0028bf1:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c0028bf8:	77 08                	ja     c0028c02 <nlz+0x40>
    {
      n += 4;
c0028bfa:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c0028bfe:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c0028c02:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c0028c09:	77 08                	ja     c0028c13 <nlz+0x51>
    {
      n += 2;
c0028c0b:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c0028c0f:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c0028c13:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c16:	85 c0                	test   %eax,%eax
c0028c18:	78 03                	js     c0028c1d <nlz+0x5b>
    n++;
c0028c1a:	ff 45 fc             	incl   -0x4(%ebp)
  return n;
c0028c1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028c20:	c9                   	leave  
c0028c21:	c3                   	ret    

c0028c22 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c0028c22:	55                   	push   %ebp
c0028c23:	89 e5                	mov    %esp,%ebp
c0028c25:	57                   	push   %edi
c0028c26:	56                   	push   %esi
c0028c27:	53                   	push   %ebx
c0028c28:	83 ec 44             	sub    $0x44,%esp
c0028c2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c2e:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0028c31:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028c34:	89 45 bc             	mov    %eax,-0x44(%ebp)
c0028c37:	8b 45 10             	mov    0x10(%ebp),%eax
c0028c3a:	89 45 b0             	mov    %eax,-0x50(%ebp)
c0028c3d:	8b 45 14             	mov    0x14(%ebp),%eax
c0028c40:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c0028c43:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028c46:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028c49:	89 d0                	mov    %edx,%eax
c0028c4b:	31 d2                	xor    %edx,%edx
c0028c4d:	89 c7                	mov    %eax,%edi
c0028c4f:	83 f7 00             	xor    $0x0,%edi
c0028c52:	89 f9                	mov    %edi,%ecx
c0028c54:	89 d0                	mov    %edx,%eax
c0028c56:	80 f4 00             	xor    $0x0,%ah
c0028c59:	89 c3                	mov    %eax,%ebx
c0028c5b:	89 d8                	mov    %ebx,%eax
c0028c5d:	09 c8                	or     %ecx,%eax
c0028c5f:	85 c0                	test   %eax,%eax
c0028c61:	0f 85 a3 00 00 00    	jne    c0028d0a <udiv64+0xe8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c0028c67:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0028c6e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      uint32_t n1 = n >> 32;
c0028c75:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028c78:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028c7b:	89 d0                	mov    %edx,%eax
c0028c7d:	31 d2                	xor    %edx,%edx
c0028c7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      uint32_t n0 = n; 
c0028c82:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028c85:	89 45 e0             	mov    %eax,-0x20(%ebp)
      uint32_t d0 = d;
c0028c88:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028c8b:	89 45 dc             	mov    %eax,-0x24(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0028c8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028c91:	ba 00 00 00 00       	mov    $0x0,%edx
c0028c96:	f7 75 dc             	divl   -0x24(%ebp)
c0028c99:	89 d0                	mov    %edx,%eax
c0028c9b:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ca0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0028ca3:	89 cb                	mov    %ecx,%ebx
c0028ca5:	0f af da             	imul   %edx,%ebx
c0028ca8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0028cab:	0f af c8             	imul   %eax,%ecx
c0028cae:	01 d9                	add    %ebx,%ecx
c0028cb0:	f7 65 e8             	mull   -0x18(%ebp)
c0028cb3:	01 d1                	add    %edx,%ecx
c0028cb5:	89 ca                	mov    %ecx,%edx
c0028cb7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0028cba:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028cbf:	01 c8                	add    %ecx,%eax
c0028cc1:	11 da                	adc    %ebx,%edx
c0028cc3:	83 ec 04             	sub    $0x4,%esp
c0028cc6:	ff 75 dc             	pushl  -0x24(%ebp)
c0028cc9:	52                   	push   %edx
c0028cca:	50                   	push   %eax
c0028ccb:	e8 b9 fe ff ff       	call   c0028b89 <divl>
c0028cd0:	83 c4 10             	add    $0x10,%esp
c0028cd3:	89 c1                	mov    %eax,%ecx
c0028cd5:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028cda:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028cdd:	ba 00 00 00 00       	mov    $0x0,%edx
c0028ce2:	f7 75 dc             	divl   -0x24(%ebp)
c0028ce5:	ba 00 00 00 00       	mov    $0x0,%edx
c0028cea:	8b 75 e8             	mov    -0x18(%ebp),%esi
c0028ced:	89 f7                	mov    %esi,%edi
c0028cef:	0f af fa             	imul   %edx,%edi
c0028cf2:	8b 75 ec             	mov    -0x14(%ebp),%esi
c0028cf5:	0f af f0             	imul   %eax,%esi
c0028cf8:	01 fe                	add    %edi,%esi
c0028cfa:	f7 65 e8             	mull   -0x18(%ebp)
c0028cfd:	01 d6                	add    %edx,%esi
c0028cff:	89 f2                	mov    %esi,%edx
c0028d01:	01 c8                	add    %ecx,%eax
c0028d03:	11 da                	adc    %ebx,%edx
c0028d05:	e9 e7 00 00 00       	jmp    c0028df1 <udiv64+0x1cf>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c0028d0a:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028d0d:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028d10:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028d13:	77 19                	ja     c0028d2e <udiv64+0x10c>
c0028d15:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028d18:	72 05                	jb     c0028d1f <udiv64+0xfd>
c0028d1a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028d1d:	73 0f                	jae    c0028d2e <udiv64+0x10c>
        return 0;
c0028d1f:	b8 00 00 00 00       	mov    $0x0,%eax
c0028d24:	ba 00 00 00 00       	mov    $0x0,%edx
c0028d29:	e9 c3 00 00 00       	jmp    c0028df1 <udiv64+0x1cf>
      else 
        {
          uint32_t d1 = d >> 32;
c0028d2e:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028d31:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028d34:	89 d0                	mov    %edx,%eax
c0028d36:	31 d2                	xor    %edx,%edx
c0028d38:	89 45 d8             	mov    %eax,-0x28(%ebp)
          int s = nlz (d1);
c0028d3b:	83 ec 04             	sub    $0x4,%esp
c0028d3e:	ff 75 d8             	pushl  -0x28(%ebp)
c0028d41:	e8 7c fe ff ff       	call   c0028bc2 <nlz>
c0028d46:	83 c4 08             	add    $0x8,%esp
c0028d49:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0028d4c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0028d4f:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0028d52:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0028d55:	0f a5 c2             	shld   %cl,%eax,%edx
c0028d58:	d3 e0                	shl    %cl,%eax
c0028d5a:	f6 c1 20             	test   $0x20,%cl
c0028d5d:	74 04                	je     c0028d63 <udiv64+0x141>
c0028d5f:	89 c2                	mov    %eax,%edx
c0028d61:	31 c0                	xor    %eax,%eax
c0028d63:	89 d0                	mov    %edx,%eax
c0028d65:	31 d2                	xor    %edx,%edx
c0028d67:	89 c1                	mov    %eax,%ecx
c0028d69:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0028d6c:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0028d6f:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0028d73:	d1 ea                	shr    %edx
c0028d75:	83 ec 04             	sub    $0x4,%esp
c0028d78:	51                   	push   %ecx
c0028d79:	52                   	push   %edx
c0028d7a:	50                   	push   %eax
c0028d7b:	e8 09 fe ff ff       	call   c0028b89 <divl>
c0028d80:	83 c4 10             	add    $0x10,%esp
c0028d83:	89 c2                	mov    %eax,%edx
c0028d85:	b8 1f 00 00 00       	mov    $0x1f,%eax
c0028d8a:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0028d8d:	88 c1                	mov    %al,%cl
c0028d8f:	d3 ea                	shr    %cl,%edx
c0028d91:	89 d0                	mov    %edx,%eax
c0028d93:	89 45 c8             	mov    %eax,-0x38(%ebp)
c0028d96:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0028d9d:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028da0:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0028da3:	83 c0 ff             	add    $0xffffffff,%eax
c0028da6:	83 d2 ff             	adc    $0xffffffff,%edx
c0028da9:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0028dac:	89 cb                	mov    %ecx,%ebx
c0028dae:	0f af da             	imul   %edx,%ebx
c0028db1:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c0028db4:	0f af c8             	imul   %eax,%ecx
c0028db7:	01 d9                	add    %ebx,%ecx
c0028db9:	f7 65 b0             	mull   -0x50(%ebp)
c0028dbc:	01 d1                	add    %edx,%ecx
c0028dbe:	89 ca                	mov    %ecx,%edx
c0028dc0:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0028dc3:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c0028dc6:	29 c1                	sub    %eax,%ecx
c0028dc8:	19 d3                	sbb    %edx,%ebx
c0028dca:	89 c8                	mov    %ecx,%eax
c0028dcc:	89 da                	mov    %ebx,%edx
c0028dce:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028dd1:	77 18                	ja     c0028deb <udiv64+0x1c9>
c0028dd3:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0028dd6:	72 05                	jb     c0028ddd <udiv64+0x1bb>
c0028dd8:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c0028ddb:	73 0e                	jae    c0028deb <udiv64+0x1c9>
c0028ddd:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028de0:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0028de3:	83 c0 ff             	add    $0xffffffff,%eax
c0028de6:	83 d2 ff             	adc    $0xffffffff,%edx
c0028de9:	eb 06                	jmp    c0028df1 <udiv64+0x1cf>
c0028deb:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0028dee:	8b 55 cc             	mov    -0x34(%ebp),%edx
        }
    }
}
c0028df1:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0028df4:	5b                   	pop    %ebx
c0028df5:	5e                   	pop    %esi
c0028df6:	5f                   	pop    %edi
c0028df7:	5d                   	pop    %ebp
c0028df8:	c3                   	ret    

c0028df9 <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c0028df9:	55                   	push   %ebp
c0028dfa:	89 e5                	mov    %esp,%ebp
c0028dfc:	53                   	push   %ebx
c0028dfd:	83 ec 14             	sub    $0x14,%esp
c0028e00:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e03:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028e06:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028e0c:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e0f:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028e12:	8b 45 14             	mov    0x14(%ebp),%eax
c0028e15:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c0028e18:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0028e1b:	ff 75 ec             	pushl  -0x14(%ebp)
c0028e1e:	ff 75 e8             	pushl  -0x18(%ebp)
c0028e21:	ff 75 f4             	pushl  -0xc(%ebp)
c0028e24:	ff 75 f0             	pushl  -0x10(%ebp)
c0028e27:	e8 f6 fd ff ff       	call   c0028c22 <udiv64>
c0028e2c:	83 c4 10             	add    $0x10,%esp
c0028e2f:	89 c2                	mov    %eax,%edx
c0028e31:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028e34:	0f af c2             	imul   %edx,%eax
c0028e37:	29 c3                	sub    %eax,%ebx
c0028e39:	89 d8                	mov    %ebx,%eax
}
c0028e3b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028e3e:	c9                   	leave  
c0028e3f:	c3                   	ret    

c0028e40 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0028e40:	55                   	push   %ebp
c0028e41:	89 e5                	mov    %esp,%ebp
c0028e43:	83 ec 30             	sub    $0x30,%esp
c0028e46:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e49:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0028e4c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028e4f:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0028e52:	8b 45 10             	mov    0x10(%ebp),%eax
c0028e55:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0028e58:	8b 45 14             	mov    0x14(%ebp),%eax
c0028e5b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0028e5e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0028e62:	79 0f                	jns    c0028e73 <sdiv64+0x33>
c0028e64:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028e67:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0028e6a:	f7 d8                	neg    %eax
c0028e6c:	83 d2 00             	adc    $0x0,%edx
c0028e6f:	f7 da                	neg    %edx
c0028e71:	eb 06                	jmp    c0028e79 <sdiv64+0x39>
c0028e73:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028e76:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0028e79:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028e7c:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0028e7f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0028e83:	79 0f                	jns    c0028e94 <sdiv64+0x54>
c0028e85:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0028e88:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0028e8b:	f7 d8                	neg    %eax
c0028e8d:	83 d2 00             	adc    $0x0,%edx
c0028e90:	f7 da                	neg    %edx
c0028e92:	eb 06                	jmp    c0028e9a <sdiv64+0x5a>
c0028e94:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0028e97:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0028e9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028e9d:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0028ea0:	ff 75 f4             	pushl  -0xc(%ebp)
c0028ea3:	ff 75 f0             	pushl  -0x10(%ebp)
c0028ea6:	ff 75 fc             	pushl  -0x4(%ebp)
c0028ea9:	ff 75 f8             	pushl  -0x8(%ebp)
c0028eac:	e8 71 fd ff ff       	call   c0028c22 <udiv64>
c0028eb1:	83 c4 10             	add    $0x10,%esp
c0028eb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028eb7:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0028eba:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0028ebd:	f7 d0                	not    %eax
c0028ebf:	c1 e8 1f             	shr    $0x1f,%eax
c0028ec2:	88 c2                	mov    %al,%dl
c0028ec4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0028ec7:	c1 e8 1f             	shr    $0x1f,%eax
c0028eca:	31 d0                	xor    %edx,%eax
c0028ecc:	84 c0                	test   %al,%al
c0028ece:	74 08                	je     c0028ed8 <sdiv64+0x98>
c0028ed0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028ed3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028ed6:	eb 0d                	jmp    c0028ee5 <sdiv64+0xa5>
c0028ed8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028edb:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0028ede:	f7 d8                	neg    %eax
c0028ee0:	83 d2 00             	adc    $0x0,%edx
c0028ee3:	f7 da                	neg    %edx
}
c0028ee5:	c9                   	leave  
c0028ee6:	c3                   	ret    

c0028ee7 <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c0028ee7:	55                   	push   %ebp
c0028ee8:	89 e5                	mov    %esp,%ebp
c0028eea:	53                   	push   %ebx
c0028eeb:	83 ec 14             	sub    $0x14,%esp
c0028eee:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ef1:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028ef4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028ef7:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0028efa:	8b 45 10             	mov    0x10(%ebp),%eax
c0028efd:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0028f00:	8b 45 14             	mov    0x14(%ebp),%eax
c0028f03:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c0028f06:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c0028f09:	ff 75 ec             	pushl  -0x14(%ebp)
c0028f0c:	ff 75 e8             	pushl  -0x18(%ebp)
c0028f0f:	ff 75 f4             	pushl  -0xc(%ebp)
c0028f12:	ff 75 f0             	pushl  -0x10(%ebp)
c0028f15:	e8 26 ff ff ff       	call   c0028e40 <sdiv64>
c0028f1a:	83 c4 10             	add    $0x10,%esp
c0028f1d:	89 c2                	mov    %eax,%edx
c0028f1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028f22:	0f af c2             	imul   %edx,%eax
c0028f25:	29 c3                	sub    %eax,%ebx
c0028f27:	89 d8                	mov    %ebx,%eax
}
c0028f29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0028f2c:	c9                   	leave  
c0028f2d:	c3                   	ret    

c0028f2e <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c0028f2e:	55                   	push   %ebp
c0028f2f:	89 e5                	mov    %esp,%ebp
c0028f31:	83 ec 10             	sub    $0x10,%esp
c0028f34:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f37:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028f3a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028f3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028f40:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f43:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028f46:	8b 45 14             	mov    0x14(%ebp),%eax
c0028f49:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c0028f4c:	ff 75 f4             	pushl  -0xc(%ebp)
c0028f4f:	ff 75 f0             	pushl  -0x10(%ebp)
c0028f52:	ff 75 fc             	pushl  -0x4(%ebp)
c0028f55:	ff 75 f8             	pushl  -0x8(%ebp)
c0028f58:	e8 e3 fe ff ff       	call   c0028e40 <sdiv64>
c0028f5d:	83 c4 10             	add    $0x10,%esp
}
c0028f60:	c9                   	leave  
c0028f61:	c3                   	ret    

c0028f62 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0028f62:	55                   	push   %ebp
c0028f63:	89 e5                	mov    %esp,%ebp
c0028f65:	83 ec 10             	sub    $0x10,%esp
c0028f68:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f6b:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028f6e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028f71:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028f74:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f77:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028f7a:	8b 45 14             	mov    0x14(%ebp),%eax
c0028f7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c0028f80:	ff 75 f4             	pushl  -0xc(%ebp)
c0028f83:	ff 75 f0             	pushl  -0x10(%ebp)
c0028f86:	ff 75 fc             	pushl  -0x4(%ebp)
c0028f89:	ff 75 f8             	pushl  -0x8(%ebp)
c0028f8c:	e8 56 ff ff ff       	call   c0028ee7 <smod64>
c0028f91:	83 c4 10             	add    $0x10,%esp
c0028f94:	99                   	cltd   
}
c0028f95:	c9                   	leave  
c0028f96:	c3                   	ret    

c0028f97 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c0028f97:	55                   	push   %ebp
c0028f98:	89 e5                	mov    %esp,%ebp
c0028f9a:	83 ec 10             	sub    $0x10,%esp
c0028f9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fa0:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028fa3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028fa6:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028fa9:	8b 45 10             	mov    0x10(%ebp),%eax
c0028fac:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028faf:	8b 45 14             	mov    0x14(%ebp),%eax
c0028fb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c0028fb5:	ff 75 f4             	pushl  -0xc(%ebp)
c0028fb8:	ff 75 f0             	pushl  -0x10(%ebp)
c0028fbb:	ff 75 fc             	pushl  -0x4(%ebp)
c0028fbe:	ff 75 f8             	pushl  -0x8(%ebp)
c0028fc1:	e8 5c fc ff ff       	call   c0028c22 <udiv64>
c0028fc6:	83 c4 10             	add    $0x10,%esp
}
c0028fc9:	c9                   	leave  
c0028fca:	c3                   	ret    

c0028fcb <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0028fcb:	55                   	push   %ebp
c0028fcc:	89 e5                	mov    %esp,%ebp
c0028fce:	83 ec 10             	sub    $0x10,%esp
c0028fd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fd4:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0028fd7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028fda:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0028fdd:	8b 45 10             	mov    0x10(%ebp),%eax
c0028fe0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0028fe3:	8b 45 14             	mov    0x14(%ebp),%eax
c0028fe6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c0028fe9:	ff 75 f4             	pushl  -0xc(%ebp)
c0028fec:	ff 75 f0             	pushl  -0x10(%ebp)
c0028fef:	ff 75 fc             	pushl  -0x4(%ebp)
c0028ff2:	ff 75 f8             	pushl  -0x8(%ebp)
c0028ff5:	e8 ff fd ff ff       	call   c0028df9 <umod64>
c0028ffa:	83 c4 10             	add    $0x10,%esp
c0028ffd:	ba 00 00 00 00       	mov    $0x0,%edx
}
c0029002:	c9                   	leave  
c0029003:	c3                   	ret    

c0029004 <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c0029004:	55                   	push   %ebp
c0029005:	89 e5                	mov    %esp,%ebp
c0029007:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c002900a:	8b 45 08             	mov    0x8(%ebp),%eax
c002900d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c0029010:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029017:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c002901e:	eb 57                	jmp    c0029077 <calculate_chksum+0x73>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c0029020:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c0029027:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002902a:	83 c0 08             	add    $0x8,%eax
c002902d:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c0029030:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029033:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0029036:	72 0f                	jb     c0029047 <calculate_chksum+0x43>
c0029038:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002903b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002903e:	73 07                	jae    c0029047 <calculate_chksum+0x43>
c0029040:	b8 01 00 00 00       	mov    $0x1,%eax
c0029045:	eb 05                	jmp    c002904c <calculate_chksum+0x48>
c0029047:	b8 00 00 00 00       	mov    $0x0,%eax
c002904c:	88 45 eb             	mov    %al,-0x15(%ebp)
c002904f:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c0029053:	8a 45 eb             	mov    -0x15(%ebp),%al
c0029056:	83 f0 01             	xor    $0x1,%eax
c0029059:	84 c0                	test   %al,%al
c002905b:	74 0f                	je     c002906c <calculate_chksum+0x68>
c002905d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029060:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029063:	01 d0                	add    %edx,%eax
c0029065:	8a 00                	mov    (%eax),%al
c0029067:	0f b6 c0             	movzbl %al,%eax
c002906a:	eb 05                	jmp    c0029071 <calculate_chksum+0x6d>
c002906c:	b8 20 00 00 00       	mov    $0x20,%eax
c0029071:	01 45 fc             	add    %eax,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029074:	ff 45 f8             	incl   -0x8(%ebp)
c0029077:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c002907e:	76 a0                	jbe    c0029020 <calculate_chksum+0x1c>
    }
  return chksum;
c0029080:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0029083:	c9                   	leave  
c0029084:	c3                   	ret    

c0029085 <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c0029085:	55                   	push   %ebp
c0029086:	89 e5                	mov    %esp,%ebp
c0029088:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c002908b:	eb 14                	jmp    c00290a1 <strip_antisocial_prefixes+0x1c>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c002908d:	83 ec 08             	sub    $0x8,%esp
c0029090:	6a 2f                	push   $0x2f
c0029092:	ff 75 08             	pushl  0x8(%ebp)
c0029095:	e8 cd f5 ff ff       	call   c0028667 <strchr>
c002909a:	83 c4 10             	add    $0x10,%esp
c002909d:	40                   	inc    %eax
c002909e:	89 45 08             	mov    %eax,0x8(%ebp)
  while (*file_name == '/'
c00290a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00290a4:	8a 00                	mov    (%eax),%al
c00290a6:	3c 2f                	cmp    $0x2f,%al
c00290a8:	74 e3                	je     c002908d <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c00290aa:	83 ec 04             	sub    $0x4,%esp
c00290ad:	6a 02                	push   $0x2
c00290af:	68 50 0a 03 c0       	push   $0xc0030a50
c00290b4:	ff 75 08             	pushl  0x8(%ebp)
c00290b7:	e8 ff f3 ff ff       	call   c00284bb <memcmp>
c00290bc:	83 c4 10             	add    $0x10,%esp
c00290bf:	85 c0                	test   %eax,%eax
c00290c1:	74 ca                	je     c002908d <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c00290c3:	83 ec 04             	sub    $0x4,%esp
c00290c6:	6a 03                	push   $0x3
c00290c8:	68 53 0a 03 c0       	push   $0xc0030a53
c00290cd:	ff 75 08             	pushl  0x8(%ebp)
c00290d0:	e8 e6 f3 ff ff       	call   c00284bb <memcmp>
c00290d5:	83 c4 10             	add    $0x10,%esp
c00290d8:	85 c0                	test   %eax,%eax
c00290da:	74 b1                	je     c002908d <strip_antisocial_prefixes+0x8>
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c00290dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00290df:	8a 00                	mov    (%eax),%al
c00290e1:	84 c0                	test   %al,%al
c00290e3:	74 1c                	je     c0029101 <strip_antisocial_prefixes+0x7c>
c00290e5:	83 ec 08             	sub    $0x8,%esp
c00290e8:	68 57 0a 03 c0       	push   $0xc0030a57
c00290ed:	ff 75 08             	pushl  0x8(%ebp)
c00290f0:	e8 70 f4 ff ff       	call   c0028565 <strcmp>
c00290f5:	83 c4 10             	add    $0x10,%esp
c00290f8:	85 c0                	test   %eax,%eax
c00290fa:	74 05                	je     c0029101 <strip_antisocial_prefixes+0x7c>
c00290fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00290ff:	eb 05                	jmp    c0029106 <strip_antisocial_prefixes+0x81>
c0029101:	b8 5a 0a 03 c0       	mov    $0xc0030a5a,%eax
}
c0029106:	c9                   	leave  
c0029107:	c3                   	ret    

c0029108 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c0029108:	55                   	push   %ebp
c0029109:	89 e5                	mov    %esp,%ebp
c002910b:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c002910e:	8b 45 14             	mov    0x14(%ebp),%eax
c0029111:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0029114:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c0029118:	74 24                	je     c002913e <ustar_make_header+0x36>
c002911a:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c002911e:	74 1e                	je     c002913e <ustar_make_header+0x36>
c0029120:	83 ec 0c             	sub    $0xc,%esp
c0029123:	68 5c 0a 03 c0       	push   $0xc0030a5c
c0029128:	68 8d 0a 03 c0       	push   $0xc0030a8d
c002912d:	68 90 0b 03 c0       	push   $0xc0030b90
c0029132:	6a 59                	push   $0x59
c0029134:	68 a4 0a 03 c0       	push   $0xc0030aa4
c0029139:	e8 ea 03 00 00       	call   c0029528 <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c002913e:	83 ec 0c             	sub    $0xc,%esp
c0029141:	ff 75 08             	pushl  0x8(%ebp)
c0029144:	e8 3c ff ff ff       	call   c0029085 <strip_antisocial_prefixes>
c0029149:	83 c4 10             	add    $0x10,%esp
c002914c:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c002914f:	83 ec 0c             	sub    $0xc,%esp
c0029152:	ff 75 08             	pushl  0x8(%ebp)
c0029155:	e8 41 f8 ff ff       	call   c002899b <strlen>
c002915a:	83 c4 10             	add    $0x10,%esp
c002915d:	83 f8 63             	cmp    $0x63,%eax
c0029160:	76 1a                	jbe    c002917c <ustar_make_header+0x74>
    {
      printf ("%s: file name too long\n", file_name);
c0029162:	83 ec 08             	sub    $0x8,%esp
c0029165:	ff 75 08             	pushl  0x8(%ebp)
c0029168:	68 b6 0a 03 c0       	push   $0xc0030ab6
c002916d:	e8 f7 df ff ff       	call   c0027169 <printf>
c0029172:	83 c4 10             	add    $0x10,%esp
      return false;
c0029175:	b0 00                	mov    $0x0,%al
c0029177:	e9 5f 01 00 00       	jmp    c00292db <ustar_make_header+0x1d3>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c002917c:	83 ec 04             	sub    $0x4,%esp
c002917f:	68 00 02 00 00       	push   $0x200
c0029184:	6a 00                	push   $0x0
c0029186:	ff 75 f4             	pushl  -0xc(%ebp)
c0029189:	e8 b4 f7 ff ff       	call   c0028942 <memset>
c002918e:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c0029191:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029194:	83 ec 04             	sub    $0x4,%esp
c0029197:	6a 64                	push   $0x64
c0029199:	ff 75 08             	pushl  0x8(%ebp)
c002919c:	50                   	push   %eax
c002919d:	e8 73 f8 ff ff       	call   c0028a15 <strlcpy>
c00291a2:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c00291a5:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c00291a9:	75 07                	jne    c00291b2 <ustar_make_header+0xaa>
c00291ab:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c00291b0:	eb 05                	jmp    c00291b7 <ustar_make_header+0xaf>
c00291b2:	b8 ed 01 00 00       	mov    $0x1ed,%eax
c00291b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00291ba:	83 c2 64             	add    $0x64,%edx
c00291bd:	50                   	push   %eax
c00291be:	68 ce 0a 03 c0       	push   $0xc0030ace
c00291c3:	6a 08                	push   $0x8
c00291c5:	52                   	push   %edx
c00291c6:	e8 75 df ff ff       	call   c0027140 <snprintf>
c00291cb:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c00291ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00291d1:	83 c0 6c             	add    $0x6c,%eax
c00291d4:	83 ec 04             	sub    $0x4,%esp
c00291d7:	6a 08                	push   $0x8
c00291d9:	68 d3 0a 03 c0       	push   $0xc0030ad3
c00291de:	50                   	push   %eax
c00291df:	e8 31 f8 ff ff       	call   c0028a15 <strlcpy>
c00291e4:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c00291e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00291ea:	83 c0 74             	add    $0x74,%eax
c00291ed:	83 ec 04             	sub    $0x4,%esp
c00291f0:	6a 08                	push   $0x8
c00291f2:	68 d3 0a 03 c0       	push   $0xc0030ad3
c00291f7:	50                   	push   %eax
c00291f8:	e8 18 f8 ff ff       	call   c0028a15 <strlcpy>
c00291fd:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c0029200:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029203:	83 c0 7c             	add    $0x7c,%eax
c0029206:	ff 75 10             	pushl  0x10(%ebp)
c0029209:	68 db 0a 03 c0       	push   $0xc0030adb
c002920e:	6a 0c                	push   $0xc
c0029210:	50                   	push   %eax
c0029211:	e8 2a df ff ff       	call   c0027140 <snprintf>
c0029216:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c0029219:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002921c:	05 88 00 00 00       	add    $0x88,%eax
c0029221:	68 00 8c b7 43       	push   $0x43b78c00
c0029226:	68 db 0a 03 c0       	push   $0xc0030adb
c002922b:	6a 0c                	push   $0xc
c002922d:	50                   	push   %eax
c002922e:	e8 0d df ff ff       	call   c0027140 <snprintf>
c0029233:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c0029236:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029239:	88 c2                	mov    %al,%dl
c002923b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002923e:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0029244:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029247:	05 01 01 00 00       	add    $0x101,%eax
c002924c:	83 ec 04             	sub    $0x4,%esp
c002924f:	6a 06                	push   $0x6
c0029251:	68 e1 0a 03 c0       	push   $0xc0030ae1
c0029256:	50                   	push   %eax
c0029257:	e8 b9 f7 ff ff       	call   c0028a15 <strlcpy>
c002925c:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c002925f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029262:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c0029269:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002926c:	8a 90 08 01 00 00    	mov    0x108(%eax),%dl
c0029272:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029275:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c002927b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002927e:	05 29 01 00 00       	add    $0x129,%eax
c0029283:	83 ec 04             	sub    $0x4,%esp
c0029286:	6a 20                	push   $0x20
c0029288:	68 e7 0a 03 c0       	push   $0xc0030ae7
c002928d:	50                   	push   %eax
c002928e:	e8 82 f7 ff ff       	call   c0028a15 <strlcpy>
c0029293:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c0029296:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029299:	05 09 01 00 00       	add    $0x109,%eax
c002929e:	83 ec 04             	sub    $0x4,%esp
c00292a1:	6a 20                	push   $0x20
c00292a3:	68 e7 0a 03 c0       	push   $0xc0030ae7
c00292a8:	50                   	push   %eax
c00292a9:	e8 67 f7 ff ff       	call   c0028a15 <strlcpy>
c00292ae:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c00292b1:	83 ec 0c             	sub    $0xc,%esp
c00292b4:	ff 75 f4             	pushl  -0xc(%ebp)
c00292b7:	e8 48 fd ff ff       	call   c0029004 <calculate_chksum>
c00292bc:	83 c4 10             	add    $0x10,%esp
c00292bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00292c2:	81 c2 94 00 00 00    	add    $0x94,%edx
c00292c8:	50                   	push   %eax
c00292c9:	68 ce 0a 03 c0       	push   $0xc0030ace
c00292ce:	6a 08                	push   $0x8
c00292d0:	52                   	push   %edx
c00292d1:	e8 6a de ff ff       	call   c0027140 <snprintf>
c00292d6:	83 c4 10             	add    $0x10,%esp

  return true;
c00292d9:	b0 01                	mov    $0x1,%al
}
c00292db:	c9                   	leave  
c00292dc:	c3                   	ret    

c00292dd <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c00292dd:	55                   	push   %ebp
c00292de:	89 e5                	mov    %esp,%ebp
c00292e0:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c00292e3:	8b 45 10             	mov    0x10(%ebp),%eax
c00292e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c00292ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00292f3:	eb 5d                	jmp    c0029352 <parse_octal_field+0x75>
    {
      char c = s[ofs];
c00292f5:	8b 55 08             	mov    0x8(%ebp),%edx
c00292f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00292fb:	01 d0                	add    %edx,%eax
c00292fd:	8a 00                	mov    (%eax),%al
c00292ff:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c0029302:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c0029306:	7e 31                	jle    c0029339 <parse_octal_field+0x5c>
c0029308:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c002930c:	7f 2b                	jg     c0029339 <parse_octal_field+0x5c>
        {
          if (*value > ULONG_MAX / 8)
c002930e:	8b 45 10             	mov    0x10(%ebp),%eax
c0029311:	8b 00                	mov    (%eax),%eax
c0029313:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c0029318:	76 04                	jbe    c002931e <parse_octal_field+0x41>
            {
              /* Overflow. */
              return false;
c002931a:	b0 00                	mov    $0x0,%al
c002931c:	eb 3e                	jmp    c002935c <parse_octal_field+0x7f>
            }
          *value = c - '0' + *value * 8;
c002931e:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c0029322:	8b 45 10             	mov    0x10(%ebp),%eax
c0029325:	8b 00                	mov    (%eax),%eax
c0029327:	c1 e0 03             	shl    $0x3,%eax
c002932a:	01 d0                	add    %edx,%eax
c002932c:	8d 50 d0             	lea    -0x30(%eax),%edx
c002932f:	8b 45 10             	mov    0x10(%ebp),%eax
c0029332:	89 10                	mov    %edx,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c0029334:	ff 45 fc             	incl   -0x4(%ebp)
c0029337:	eb 19                	jmp    c0029352 <parse_octal_field+0x75>
        }
      else if (c == ' ' || c == '\0')
c0029339:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c002933d:	74 06                	je     c0029345 <parse_octal_field+0x68>
c002933f:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c0029343:	75 09                	jne    c002934e <parse_octal_field+0x71>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c0029345:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0029349:	0f 95 c0             	setne  %al
c002934c:	eb 0e                	jmp    c002935c <parse_octal_field+0x7f>
        }
      else
        {
          /* Bad character. */
          return false;
c002934e:	b0 00                	mov    $0x0,%al
c0029350:	eb 0a                	jmp    c002935c <parse_octal_field+0x7f>
  for (ofs = 0; ofs < size; ofs++)
c0029352:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029355:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029358:	72 9b                	jb     c00292f5 <parse_octal_field+0x18>
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c002935a:	b0 00                	mov    $0x0,%al
}
c002935c:	c9                   	leave  
c002935d:	c3                   	ret    

c002935e <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c002935e:	55                   	push   %ebp
c002935f:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c0029361:	eb 13                	jmp    c0029376 <is_all_zeros+0x18>
    if (*block++ != 0)
c0029363:	8b 45 08             	mov    0x8(%ebp),%eax
c0029366:	8d 50 01             	lea    0x1(%eax),%edx
c0029369:	89 55 08             	mov    %edx,0x8(%ebp)
c002936c:	8a 00                	mov    (%eax),%al
c002936e:	84 c0                	test   %al,%al
c0029370:	74 04                	je     c0029376 <is_all_zeros+0x18>
      return false;
c0029372:	b0 00                	mov    $0x0,%al
c0029374:	eb 0f                	jmp    c0029385 <is_all_zeros+0x27>
  while (cnt-- > 0)
c0029376:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029379:	8d 50 ff             	lea    -0x1(%eax),%edx
c002937c:	89 55 0c             	mov    %edx,0xc(%ebp)
c002937f:	85 c0                	test   %eax,%eax
c0029381:	75 e0                	jne    c0029363 <is_all_zeros+0x5>
  return true;
c0029383:	b0 01                	mov    $0x1,%al
}
c0029385:	5d                   	pop    %ebp
c0029386:	c3                   	ret    

c0029387 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0029387:	55                   	push   %ebp
c0029388:	89 e5                	mov    %esp,%ebp
c002938a:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c002938d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029390:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c0029393:	68 00 02 00 00       	push   $0x200
c0029398:	ff 75 08             	pushl  0x8(%ebp)
c002939b:	e8 be ff ff ff       	call   c002935e <is_all_zeros>
c00293a0:	83 c4 08             	add    $0x8,%esp
c00293a3:	84 c0                	test   %al,%al
c00293a5:	74 25                	je     c00293cc <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c00293a7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00293aa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c00293b0:	8b 45 10             	mov    0x10(%ebp),%eax
c00293b3:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c00293b9:	8b 45 14             	mov    0x14(%ebp),%eax
c00293bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c00293c2:	b8 00 00 00 00       	mov    $0x0,%eax
c00293c7:	e9 5a 01 00 00       	jmp    c0029526 <ustar_parse_header+0x19f>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c00293cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293cf:	05 01 01 00 00       	add    $0x101,%eax
c00293d4:	83 ec 04             	sub    $0x4,%esp
c00293d7:	6a 06                	push   $0x6
c00293d9:	68 e1 0a 03 c0       	push   $0xc0030ae1
c00293de:	50                   	push   %eax
c00293df:	e8 d7 f0 ff ff       	call   c00284bb <memcmp>
c00293e4:	83 c4 10             	add    $0x10,%esp
c00293e7:	85 c0                	test   %eax,%eax
c00293e9:	74 0a                	je     c00293f5 <ustar_parse_header+0x6e>
    return "not a ustar archive";
c00293eb:	b8 ec 0a 03 c0       	mov    $0xc0030aec,%eax
c00293f0:	e9 31 01 00 00       	jmp    c0029526 <ustar_parse_header+0x19f>
  else if (h->version[0] != '0' || h->version[1] != '0')
c00293f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00293f8:	8a 80 07 01 00 00    	mov    0x107(%eax),%al
c00293fe:	3c 30                	cmp    $0x30,%al
c0029400:	75 0d                	jne    c002940f <ustar_parse_header+0x88>
c0029402:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029405:	8a 80 08 01 00 00    	mov    0x108(%eax),%al
c002940b:	3c 30                	cmp    $0x30,%al
c002940d:	74 0a                	je     c0029419 <ustar_parse_header+0x92>
    return "invalid ustar version";
c002940f:	b8 00 0b 03 c0       	mov    $0xc0030b00,%eax
c0029414:	e9 0d 01 00 00       	jmp    c0029526 <ustar_parse_header+0x19f>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0029419:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002941c:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c0029422:	83 ec 04             	sub    $0x4,%esp
c0029425:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0029428:	50                   	push   %eax
c0029429:	6a 08                	push   $0x8
c002942b:	52                   	push   %edx
c002942c:	e8 ac fe ff ff       	call   c00292dd <parse_octal_field>
c0029431:	83 c4 10             	add    $0x10,%esp
c0029434:	83 f0 01             	xor    $0x1,%eax
c0029437:	84 c0                	test   %al,%al
c0029439:	74 0a                	je     c0029445 <ustar_parse_header+0xbe>
    return "corrupt chksum field";
c002943b:	b8 16 0b 03 c0       	mov    $0xc0030b16,%eax
c0029440:	e9 e1 00 00 00       	jmp    c0029526 <ustar_parse_header+0x19f>
  else if (chksum != calculate_chksum (h))
c0029445:	83 ec 0c             	sub    $0xc,%esp
c0029448:	ff 75 f4             	pushl  -0xc(%ebp)
c002944b:	e8 b4 fb ff ff       	call   c0029004 <calculate_chksum>
c0029450:	83 c4 10             	add    $0x10,%esp
c0029453:	89 c2                	mov    %eax,%edx
c0029455:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029458:	39 c2                	cmp    %eax,%edx
c002945a:	74 0a                	je     c0029466 <ustar_parse_header+0xdf>
    return "checksum mismatch";
c002945c:	b8 2b 0b 03 c0       	mov    $0xc0030b2b,%eax
c0029461:	e9 c0 00 00 00       	jmp    c0029526 <ustar_parse_header+0x19f>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0029466:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029469:	8a 40 63             	mov    0x63(%eax),%al
c002946c:	84 c0                	test   %al,%al
c002946e:	75 0d                	jne    c002947d <ustar_parse_header+0xf6>
c0029470:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029473:	8a 80 59 01 00 00    	mov    0x159(%eax),%al
c0029479:	84 c0                	test   %al,%al
c002947b:	74 0a                	je     c0029487 <ustar_parse_header+0x100>
    return "file name too long";
c002947d:	b8 3d 0b 03 c0       	mov    $0xc0030b3d,%eax
c0029482:	e9 9f 00 00 00       	jmp    c0029526 <ustar_parse_header+0x19f>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0029487:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002948a:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c0029490:	3c 30                	cmp    $0x30,%al
c0029492:	74 14                	je     c00294a8 <ustar_parse_header+0x121>
c0029494:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029497:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c002949d:	3c 35                	cmp    $0x35,%al
c002949f:	74 07                	je     c00294a8 <ustar_parse_header+0x121>
    return "unimplemented file type";
c00294a1:	b8 50 0b 03 c0       	mov    $0xc0030b50,%eax
c00294a6:	eb 7e                	jmp    c0029526 <ustar_parse_header+0x19f>
  if (h->typeflag == USTAR_REGULAR)
c00294a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294ab:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c00294b1:	3c 30                	cmp    $0x30,%al
c00294b3:	75 34                	jne    c00294e9 <ustar_parse_header+0x162>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c00294b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294b8:	8d 50 7c             	lea    0x7c(%eax),%edx
c00294bb:	83 ec 04             	sub    $0x4,%esp
c00294be:	8d 45 ec             	lea    -0x14(%ebp),%eax
c00294c1:	50                   	push   %eax
c00294c2:	6a 0c                	push   $0xc
c00294c4:	52                   	push   %edx
c00294c5:	e8 13 fe ff ff       	call   c00292dd <parse_octal_field>
c00294ca:	83 c4 10             	add    $0x10,%esp
c00294cd:	83 f0 01             	xor    $0x1,%eax
c00294d0:	84 c0                	test   %al,%al
c00294d2:	74 07                	je     c00294db <ustar_parse_header+0x154>
        return "corrupt file size field";
c00294d4:	b8 68 0b 03 c0       	mov    $0xc0030b68,%eax
c00294d9:	eb 4b                	jmp    c0029526 <ustar_parse_header+0x19f>
      else if (size_ul > INT_MAX)
c00294db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00294de:	85 c0                	test   %eax,%eax
c00294e0:	79 0e                	jns    c00294f0 <ustar_parse_header+0x169>
        return "file too large";
c00294e2:	b8 80 0b 03 c0       	mov    $0xc0030b80,%eax
c00294e7:	eb 3d                	jmp    c0029526 <ustar_parse_header+0x19f>
    }
  else
    size_ul = 0;
c00294e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c00294f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00294f3:	83 ec 0c             	sub    $0xc,%esp
c00294f6:	50                   	push   %eax
c00294f7:	e8 89 fb ff ff       	call   c0029085 <strip_antisocial_prefixes>
c00294fc:	83 c4 10             	add    $0x10,%esp
c00294ff:	89 c2                	mov    %eax,%edx
c0029501:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029504:	89 10                	mov    %edx,(%eax)
  *type = h->typeflag;
c0029506:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029509:	8a 80 9c 00 00 00    	mov    0x9c(%eax),%al
c002950f:	0f be d0             	movsbl %al,%edx
c0029512:	8b 45 10             	mov    0x10(%ebp),%eax
c0029515:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c0029517:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002951a:	89 c2                	mov    %eax,%edx
c002951c:	8b 45 14             	mov    0x14(%ebp),%eax
c002951f:	89 10                	mov    %edx,(%eax)
  return NULL;
c0029521:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029526:	c9                   	leave  
c0029527:	c3                   	ret    

c0029528 <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c0029528:	55                   	push   %ebp
c0029529:	89 e5                	mov    %esp,%ebp
c002952b:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c002952e:	e8 59 7e ff ff       	call   c002138c <intr_disable>
  console_panic ();
c0029533:	e8 78 20 00 00       	call   c002b5b0 <console_panic>

  level++;
c0029538:	a1 e4 8b 03 c0       	mov    0xc0038be4,%eax
c002953d:	40                   	inc    %eax
c002953e:	a3 e4 8b 03 c0       	mov    %eax,0xc0038be4
  if (level == 1) 
c0029543:	a1 e4 8b 03 c0       	mov    0xc0038be4,%eax
c0029548:	83 f8 01             	cmp    $0x1,%eax
c002954b:	75 42                	jne    c002958f <debug_panic+0x67>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c002954d:	ff 75 10             	pushl  0x10(%ebp)
c0029550:	ff 75 0c             	pushl  0xc(%ebp)
c0029553:	ff 75 08             	pushl  0x8(%ebp)
c0029556:	68 a4 0b 03 c0       	push   $0xc0030ba4
c002955b:	e8 09 dc ff ff       	call   c0027169 <printf>
c0029560:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c0029563:	8d 45 18             	lea    0x18(%ebp),%eax
c0029566:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c0029569:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002956c:	83 ec 08             	sub    $0x8,%esp
c002956f:	50                   	push   %eax
c0029570:	ff 75 14             	pushl  0x14(%ebp)
c0029573:	e8 3e 21 00 00       	call   c002b6b6 <vprintf>
c0029578:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c002957b:	83 ec 0c             	sub    $0xc,%esp
c002957e:	6a 0a                	push   $0xa
c0029580:	e8 e9 21 00 00       	call   c002b76e <putchar>
c0029585:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c0029588:	e8 cf d8 ff ff       	call   c0026e5c <debug_backtrace>
c002958d:	eb 20                	jmp    c00295af <debug_panic+0x87>
    }
  else if (level == 2)
c002958f:	a1 e4 8b 03 c0       	mov    0xc0038be4,%eax
c0029594:	83 f8 02             	cmp    $0x2,%eax
c0029597:	75 16                	jne    c00295af <debug_panic+0x87>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c0029599:	ff 75 10             	pushl  0x10(%ebp)
c002959c:	ff 75 0c             	pushl  0xc(%ebp)
c002959f:	ff 75 08             	pushl  0x8(%ebp)
c00295a2:	68 c4 0b 03 c0       	push   $0xc0030bc4
c00295a7:	e8 bd db ff ff       	call   c0027169 <printf>
c00295ac:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c00295af:	e8 80 b4 ff ff       	call   c0024a34 <serial_flush>
  shutdown ();
c00295b4:	e8 12 d6 ff ff       	call   c0026bcb <shutdown>
  for (;;);
c00295b9:	eb fe                	jmp    c00295b9 <debug_panic+0x91>

c00295bb <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c00295bb:	55                   	push   %ebp
c00295bc:	89 e5                	mov    %esp,%ebp
c00295be:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c00295c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00295c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c00295cf:	c7 45 ec ee 0b 03 c0 	movl   $0xc0030bee,-0x14(%ebp)

  switch (t->status) {
c00295d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00295d9:	8b 40 04             	mov    0x4(%eax),%eax
c00295dc:	83 f8 01             	cmp    $0x1,%eax
c00295df:	74 15                	je     c00295f6 <print_stacktrace+0x3b>
c00295e1:	83 f8 01             	cmp    $0x1,%eax
c00295e4:	72 07                	jb     c00295ed <print_stacktrace+0x32>
c00295e6:	83 f8 02             	cmp    $0x2,%eax
c00295e9:	74 14                	je     c00295ff <print_stacktrace+0x44>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c00295eb:	eb 1a                	jmp    c0029607 <print_stacktrace+0x4c>
      status = "RUNNING";
c00295ed:	c7 45 ec f6 0b 03 c0 	movl   $0xc0030bf6,-0x14(%ebp)
      break;
c00295f4:	eb 11                	jmp    c0029607 <print_stacktrace+0x4c>
      status = "READY";
c00295f6:	c7 45 ec fe 0b 03 c0 	movl   $0xc0030bfe,-0x14(%ebp)
      break;
c00295fd:	eb 08                	jmp    c0029607 <print_stacktrace+0x4c>
      status = "BLOCKED";
c00295ff:	c7 45 ec 04 0c 03 c0 	movl   $0xc0030c04,-0x14(%ebp)
      break;
c0029606:	90                   	nop
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029607:	8b 45 08             	mov    0x8(%ebp),%eax
c002960a:	83 c0 08             	add    $0x8,%eax
c002960d:	83 ec 04             	sub    $0x4,%esp
c0029610:	ff 75 ec             	pushl  -0x14(%ebp)
c0029613:	50                   	push   %eax
c0029614:	68 0c 0c 03 c0       	push   $0xc0030c0c
c0029619:	e8 4b db ff ff       	call   c0027169 <printf>
c002961e:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c0029621:	e8 3d 76 ff ff       	call   c0020c63 <thread_current>
c0029626:	3b 45 08             	cmp    0x8(%ebp),%eax
c0029629:	75 0e                	jne    c0029639 <print_stacktrace+0x7e>
    {
      frame = __builtin_frame_address (1);
c002962b:	8b 45 00             	mov    0x0(%ebp),%eax
c002962e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c0029631:	8b 45 04             	mov    0x4(%ebp),%eax
c0029634:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029637:	eb 4d                	jmp    c0029686 <print_stacktrace+0xcb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0029639:	8b 45 08             	mov    0x8(%ebp),%eax
c002963c:	8b 40 18             	mov    0x18(%eax),%eax
c002963f:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0029642:	8b 45 08             	mov    0x8(%ebp),%eax
c0029645:	8b 40 18             	mov    0x18(%eax),%eax
c0029648:	8b 55 08             	mov    0x8(%ebp),%edx
c002964b:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0029651:	39 d0                	cmp    %edx,%eax
c0029653:	74 0d                	je     c0029662 <print_stacktrace+0xa7>
c0029655:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029658:	8b 40 10             	mov    0x10(%eax),%eax
c002965b:	3d ed 12 02 c0       	cmp    $0xc00212ed,%eax
c0029660:	75 12                	jne    c0029674 <print_stacktrace+0xb9>
        {
          printf (" thread was never scheduled.\n");
c0029662:	83 ec 0c             	sub    $0xc,%esp
c0029665:	68 33 0c 03 c0       	push   $0xc0030c33
c002966a:	e8 7a 20 00 00       	call   c002b6e9 <puts>
c002966f:	83 c4 10             	add    $0x10,%esp
          return;
c0029672:	eb 6b                	jmp    c00296df <print_stacktrace+0x124>
        }

      frame = (void **) saved_frame->ebp;
c0029674:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029677:	8b 40 08             	mov    0x8(%eax),%eax
c002967a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c002967d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029680:	8b 40 10             	mov    0x10(%eax),%eax
c0029683:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c0029686:	83 ec 08             	sub    $0x8,%esp
c0029689:	ff 75 f4             	pushl  -0xc(%ebp)
c002968c:	68 50 0c 03 c0       	push   $0xc0030c50
c0029691:	e8 d3 da ff ff       	call   c0027169 <printf>
c0029696:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029699:	eb 21                	jmp    c00296bc <print_stacktrace+0x101>
    printf (" %p", frame[1]);
c002969b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002969e:	83 c0 04             	add    $0x4,%eax
c00296a1:	8b 00                	mov    (%eax),%eax
c00296a3:	83 ec 08             	sub    $0x8,%esp
c00296a6:	50                   	push   %eax
c00296a7:	68 50 0c 03 c0       	push   $0xc0030c50
c00296ac:	e8 b8 da ff ff       	call   c0027169 <printf>
c00296b1:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c00296b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00296b7:	8b 00                	mov    (%eax),%eax
c00296b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00296bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00296bf:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c00296c4:	76 09                	jbe    c00296cf <print_stacktrace+0x114>
c00296c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00296c9:	8b 00                	mov    (%eax),%eax
c00296cb:	85 c0                	test   %eax,%eax
c00296cd:	75 cc                	jne    c002969b <print_stacktrace+0xe0>
  printf (".\n");
c00296cf:	83 ec 0c             	sub    $0xc,%esp
c00296d2:	68 54 0c 03 c0       	push   $0xc0030c54
c00296d7:	e8 0d 20 00 00       	call   c002b6e9 <puts>
c00296dc:	83 c4 10             	add    $0x10,%esp
}
c00296df:	c9                   	leave  
c00296e0:	c3                   	ret    

c00296e1 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c00296e1:	55                   	push   %ebp
c00296e2:	89 e5                	mov    %esp,%ebp
c00296e4:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c00296e7:	e8 a0 7c ff ff       	call   c002138c <intr_disable>
c00296ec:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c00296ef:	83 ec 08             	sub    $0x8,%esp
c00296f2:	6a 00                	push   $0x0
c00296f4:	68 bb 95 02 c0       	push   $0xc00295bb
c00296f9:	e8 df 76 ff ff       	call   c0020ddd <thread_foreach>
c00296fe:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c0029701:	83 ec 0c             	sub    $0xc,%esp
c0029704:	ff 75 f4             	pushl  -0xc(%ebp)
c0029707:	e8 28 7c ff ff       	call   c0021334 <intr_set_level>
c002970c:	83 c4 10             	add    $0x10,%esp
}
c002970f:	90                   	nop
c0029710:	c9                   	leave  
c0029711:	c3                   	ret    

c0029712 <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c0029712:	55                   	push   %ebp
c0029713:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029715:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029719:	74 1a                	je     c0029735 <is_head+0x23>
c002971b:	8b 45 08             	mov    0x8(%ebp),%eax
c002971e:	8b 00                	mov    (%eax),%eax
c0029720:	85 c0                	test   %eax,%eax
c0029722:	75 11                	jne    c0029735 <is_head+0x23>
c0029724:	8b 45 08             	mov    0x8(%ebp),%eax
c0029727:	8b 40 04             	mov    0x4(%eax),%eax
c002972a:	85 c0                	test   %eax,%eax
c002972c:	74 07                	je     c0029735 <is_head+0x23>
c002972e:	b8 01 00 00 00       	mov    $0x1,%eax
c0029733:	eb 05                	jmp    c002973a <is_head+0x28>
c0029735:	b8 00 00 00 00       	mov    $0x0,%eax
c002973a:	83 e0 01             	and    $0x1,%eax
}
c002973d:	5d                   	pop    %ebp
c002973e:	c3                   	ret    

c002973f <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c002973f:	55                   	push   %ebp
c0029740:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029742:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029746:	74 1a                	je     c0029762 <is_interior+0x23>
c0029748:	8b 45 08             	mov    0x8(%ebp),%eax
c002974b:	8b 00                	mov    (%eax),%eax
c002974d:	85 c0                	test   %eax,%eax
c002974f:	74 11                	je     c0029762 <is_interior+0x23>
c0029751:	8b 45 08             	mov    0x8(%ebp),%eax
c0029754:	8b 40 04             	mov    0x4(%eax),%eax
c0029757:	85 c0                	test   %eax,%eax
c0029759:	74 07                	je     c0029762 <is_interior+0x23>
c002975b:	b8 01 00 00 00       	mov    $0x1,%eax
c0029760:	eb 05                	jmp    c0029767 <is_interior+0x28>
c0029762:	b8 00 00 00 00       	mov    $0x0,%eax
c0029767:	83 e0 01             	and    $0x1,%eax
}
c002976a:	5d                   	pop    %ebp
c002976b:	c3                   	ret    

c002976c <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c002976c:	55                   	push   %ebp
c002976d:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c002976f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029773:	74 1a                	je     c002978f <is_tail+0x23>
c0029775:	8b 45 08             	mov    0x8(%ebp),%eax
c0029778:	8b 00                	mov    (%eax),%eax
c002977a:	85 c0                	test   %eax,%eax
c002977c:	74 11                	je     c002978f <is_tail+0x23>
c002977e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029781:	8b 40 04             	mov    0x4(%eax),%eax
c0029784:	85 c0                	test   %eax,%eax
c0029786:	75 07                	jne    c002978f <is_tail+0x23>
c0029788:	b8 01 00 00 00       	mov    $0x1,%eax
c002978d:	eb 05                	jmp    c0029794 <is_tail+0x28>
c002978f:	b8 00 00 00 00       	mov    $0x0,%eax
c0029794:	83 e0 01             	and    $0x1,%eax
}
c0029797:	5d                   	pop    %ebp
c0029798:	c3                   	ret    

c0029799 <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c0029799:	55                   	push   %ebp
c002979a:	89 e5                	mov    %esp,%ebp
c002979c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002979f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00297a3:	75 1e                	jne    c00297c3 <list_init+0x2a>
c00297a5:	83 ec 0c             	sub    $0xc,%esp
c00297a8:	68 58 0c 03 c0       	push   $0xc0030c58
c00297ad:	68 65 0c 03 c0       	push   $0xc0030c65
c00297b2:	68 30 0e 03 c0       	push   $0xc0030e30
c00297b7:	6a 3f                	push   $0x3f
c00297b9:	68 7c 0c 03 c0       	push   $0xc0030c7c
c00297be:	e8 65 fd ff ff       	call   c0029528 <debug_panic>
  list->head.prev = NULL;
c00297c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00297c6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c00297cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00297cf:	8d 50 08             	lea    0x8(%eax),%edx
c00297d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00297d5:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c00297d8:	8b 55 08             	mov    0x8(%ebp),%edx
c00297db:	8b 45 08             	mov    0x8(%ebp),%eax
c00297de:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c00297e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00297e4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c00297eb:	90                   	nop
c00297ec:	c9                   	leave  
c00297ed:	c3                   	ret    

c00297ee <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c00297ee:	55                   	push   %ebp
c00297ef:	89 e5                	mov    %esp,%ebp
c00297f1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00297f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00297f8:	75 1e                	jne    c0029818 <list_begin+0x2a>
c00297fa:	83 ec 0c             	sub    $0xc,%esp
c00297fd:	68 58 0c 03 c0       	push   $0xc0030c58
c0029802:	68 65 0c 03 c0       	push   $0xc0030c65
c0029807:	68 3c 0e 03 c0       	push   $0xc0030e3c
c002980c:	6a 4a                	push   $0x4a
c002980e:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029813:	e8 10 fd ff ff       	call   c0029528 <debug_panic>
  return list->head.next;
c0029818:	8b 45 08             	mov    0x8(%ebp),%eax
c002981b:	8b 40 04             	mov    0x4(%eax),%eax
}
c002981e:	c9                   	leave  
c002981f:	c3                   	ret    

c0029820 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0029820:	55                   	push   %ebp
c0029821:	89 e5                	mov    %esp,%ebp
c0029823:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c0029826:	ff 75 08             	pushl  0x8(%ebp)
c0029829:	e8 e4 fe ff ff       	call   c0029712 <is_head>
c002982e:	83 c4 04             	add    $0x4,%esp
c0029831:	84 c0                	test   %al,%al
c0029833:	75 2d                	jne    c0029862 <list_next+0x42>
c0029835:	ff 75 08             	pushl  0x8(%ebp)
c0029838:	e8 02 ff ff ff       	call   c002973f <is_interior>
c002983d:	83 c4 04             	add    $0x4,%esp
c0029840:	84 c0                	test   %al,%al
c0029842:	75 1e                	jne    c0029862 <list_next+0x42>
c0029844:	83 ec 0c             	sub    $0xc,%esp
c0029847:	68 94 0c 03 c0       	push   $0xc0030c94
c002984c:	68 65 0c 03 c0       	push   $0xc0030c65
c0029851:	68 48 0e 03 c0       	push   $0xc0030e48
c0029856:	6a 54                	push   $0x54
c0029858:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002985d:	e8 c6 fc ff ff       	call   c0029528 <debug_panic>
  return elem->next;
c0029862:	8b 45 08             	mov    0x8(%ebp),%eax
c0029865:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029868:	c9                   	leave  
c0029869:	c3                   	ret    

c002986a <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c002986a:	55                   	push   %ebp
c002986b:	89 e5                	mov    %esp,%ebp
c002986d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029870:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029874:	75 1e                	jne    c0029894 <list_end+0x2a>
c0029876:	83 ec 0c             	sub    $0xc,%esp
c0029879:	68 58 0c 03 c0       	push   $0xc0030c58
c002987e:	68 65 0c 03 c0       	push   $0xc0030c65
c0029883:	68 54 0e 03 c0       	push   $0xc0030e54
c0029888:	6a 60                	push   $0x60
c002988a:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002988f:	e8 94 fc ff ff       	call   c0029528 <debug_panic>
  return &list->tail;
c0029894:	8b 45 08             	mov    0x8(%ebp),%eax
c0029897:	83 c0 08             	add    $0x8,%eax
}
c002989a:	c9                   	leave  
c002989b:	c3                   	ret    

c002989c <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c002989c:	55                   	push   %ebp
c002989d:	89 e5                	mov    %esp,%ebp
c002989f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c00298a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00298a6:	75 1e                	jne    c00298c6 <list_rbegin+0x2a>
c00298a8:	83 ec 0c             	sub    $0xc,%esp
c00298ab:	68 58 0c 03 c0       	push   $0xc0030c58
c00298b0:	68 65 0c 03 c0       	push   $0xc0030c65
c00298b5:	68 60 0e 03 c0       	push   $0xc0030e60
c00298ba:	6a 69                	push   $0x69
c00298bc:	68 7c 0c 03 c0       	push   $0xc0030c7c
c00298c1:	e8 62 fc ff ff       	call   c0029528 <debug_panic>
  return list->tail.prev;
c00298c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00298c9:	8b 40 08             	mov    0x8(%eax),%eax
}
c00298cc:	c9                   	leave  
c00298cd:	c3                   	ret    

c00298ce <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c00298ce:	55                   	push   %ebp
c00298cf:	89 e5                	mov    %esp,%ebp
c00298d1:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c00298d4:	ff 75 08             	pushl  0x8(%ebp)
c00298d7:	e8 63 fe ff ff       	call   c002973f <is_interior>
c00298dc:	83 c4 04             	add    $0x4,%esp
c00298df:	84 c0                	test   %al,%al
c00298e1:	75 2d                	jne    c0029910 <list_prev+0x42>
c00298e3:	ff 75 08             	pushl  0x8(%ebp)
c00298e6:	e8 81 fe ff ff       	call   c002976c <is_tail>
c00298eb:	83 c4 04             	add    $0x4,%esp
c00298ee:	84 c0                	test   %al,%al
c00298f0:	75 1e                	jne    c0029910 <list_prev+0x42>
c00298f2:	83 ec 0c             	sub    $0xc,%esp
c00298f5:	68 bc 0c 03 c0       	push   $0xc0030cbc
c00298fa:	68 65 0c 03 c0       	push   $0xc0030c65
c00298ff:	68 6c 0e 03 c0       	push   $0xc0030e6c
c0029904:	6a 73                	push   $0x73
c0029906:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002990b:	e8 18 fc ff ff       	call   c0029528 <debug_panic>
  return elem->prev;
c0029910:	8b 45 08             	mov    0x8(%ebp),%eax
c0029913:	8b 00                	mov    (%eax),%eax
}
c0029915:	c9                   	leave  
c0029916:	c3                   	ret    

c0029917 <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c0029917:	55                   	push   %ebp
c0029918:	89 e5                	mov    %esp,%ebp
c002991a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002991d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029921:	75 21                	jne    c0029944 <list_rend+0x2d>
c0029923:	83 ec 0c             	sub    $0xc,%esp
c0029926:	68 58 0c 03 c0       	push   $0xc0030c58
c002992b:	68 65 0c 03 c0       	push   $0xc0030c65
c0029930:	68 78 0e 03 c0       	push   $0xc0030e78
c0029935:	68 87 00 00 00       	push   $0x87
c002993a:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002993f:	e8 e4 fb ff ff       	call   c0029528 <debug_panic>
  return &list->head;
c0029944:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029947:	c9                   	leave  
c0029948:	c3                   	ret    

c0029949 <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c0029949:	55                   	push   %ebp
c002994a:	89 e5                	mov    %esp,%ebp
c002994c:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002994f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029953:	75 21                	jne    c0029976 <list_head+0x2d>
c0029955:	83 ec 0c             	sub    $0xc,%esp
c0029958:	68 58 0c 03 c0       	push   $0xc0030c58
c002995d:	68 65 0c 03 c0       	push   $0xc0030c65
c0029962:	68 84 0e 03 c0       	push   $0xc0030e84
c0029967:	68 99 00 00 00       	push   $0x99
c002996c:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029971:	e8 b2 fb ff ff       	call   c0029528 <debug_panic>
  return &list->head;
c0029976:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029979:	c9                   	leave  
c002997a:	c3                   	ret    

c002997b <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c002997b:	55                   	push   %ebp
c002997c:	89 e5                	mov    %esp,%ebp
c002997e:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029981:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029985:	75 21                	jne    c00299a8 <list_tail+0x2d>
c0029987:	83 ec 0c             	sub    $0xc,%esp
c002998a:	68 58 0c 03 c0       	push   $0xc0030c58
c002998f:	68 65 0c 03 c0       	push   $0xc0030c65
c0029994:	68 90 0e 03 c0       	push   $0xc0030e90
c0029999:	68 a1 00 00 00       	push   $0xa1
c002999e:	68 7c 0c 03 c0       	push   $0xc0030c7c
c00299a3:	e8 80 fb ff ff       	call   c0029528 <debug_panic>
  return &list->tail;
c00299a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00299ab:	83 c0 08             	add    $0x8,%eax
}
c00299ae:	c9                   	leave  
c00299af:	c3                   	ret    

c00299b0 <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c00299b0:	55                   	push   %ebp
c00299b1:	89 e5                	mov    %esp,%ebp
c00299b3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c00299b6:	ff 75 08             	pushl  0x8(%ebp)
c00299b9:	e8 81 fd ff ff       	call   c002973f <is_interior>
c00299be:	83 c4 04             	add    $0x4,%esp
c00299c1:	84 c0                	test   %al,%al
c00299c3:	75 30                	jne    c00299f5 <list_insert+0x45>
c00299c5:	ff 75 08             	pushl  0x8(%ebp)
c00299c8:	e8 9f fd ff ff       	call   c002976c <is_tail>
c00299cd:	83 c4 04             	add    $0x4,%esp
c00299d0:	84 c0                	test   %al,%al
c00299d2:	75 21                	jne    c00299f5 <list_insert+0x45>
c00299d4:	83 ec 0c             	sub    $0xc,%esp
c00299d7:	68 e4 0c 03 c0       	push   $0xc0030ce4
c00299dc:	68 65 0c 03 c0       	push   $0xc0030c65
c00299e1:	68 9c 0e 03 c0       	push   $0xc0030e9c
c00299e6:	68 ab 00 00 00       	push   $0xab
c00299eb:	68 7c 0c 03 c0       	push   $0xc0030c7c
c00299f0:	e8 33 fb ff ff       	call   c0029528 <debug_panic>
  ASSERT (elem != NULL);
c00299f5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00299f9:	75 21                	jne    c0029a1c <list_insert+0x6c>
c00299fb:	83 ec 0c             	sub    $0xc,%esp
c00299fe:	68 0d 0d 03 c0       	push   $0xc0030d0d
c0029a03:	68 65 0c 03 c0       	push   $0xc0030c65
c0029a08:	68 9c 0e 03 c0       	push   $0xc0030e9c
c0029a0d:	68 ac 00 00 00       	push   $0xac
c0029a12:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029a17:	e8 0c fb ff ff       	call   c0029528 <debug_panic>

  elem->prev = before->prev;
c0029a1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a1f:	8b 10                	mov    (%eax),%edx
c0029a21:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a24:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c0029a26:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a29:	8b 55 08             	mov    0x8(%ebp),%edx
c0029a2c:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c0029a2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a32:	8b 00                	mov    (%eax),%eax
c0029a34:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029a37:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c0029a3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a3d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029a40:	89 10                	mov    %edx,(%eax)
}
c0029a42:	90                   	nop
c0029a43:	c9                   	leave  
c0029a44:	c3                   	ret    

c0029a45 <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c0029a45:	55                   	push   %ebp
c0029a46:	89 e5                	mov    %esp,%ebp
c0029a48:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c0029a4b:	ff 75 08             	pushl  0x8(%ebp)
c0029a4e:	e8 ec fc ff ff       	call   c002973f <is_interior>
c0029a53:	83 c4 04             	add    $0x4,%esp
c0029a56:	84 c0                	test   %al,%al
c0029a58:	75 30                	jne    c0029a8a <list_splice+0x45>
c0029a5a:	ff 75 08             	pushl  0x8(%ebp)
c0029a5d:	e8 0a fd ff ff       	call   c002976c <is_tail>
c0029a62:	83 c4 04             	add    $0x4,%esp
c0029a65:	84 c0                	test   %al,%al
c0029a67:	75 21                	jne    c0029a8a <list_splice+0x45>
c0029a69:	83 ec 0c             	sub    $0xc,%esp
c0029a6c:	68 e4 0c 03 c0       	push   $0xc0030ce4
c0029a71:	68 65 0c 03 c0       	push   $0xc0030c65
c0029a76:	68 a8 0e 03 c0       	push   $0xc0030ea8
c0029a7b:	68 bb 00 00 00       	push   $0xbb
c0029a80:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029a85:	e8 9e fa ff ff       	call   c0029528 <debug_panic>
  if (first == last)
c0029a8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a8d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0029a90:	0f 84 ba 00 00 00    	je     c0029b50 <list_splice+0x10b>
    return;
  last = list_prev (last);
c0029a96:	83 ec 0c             	sub    $0xc,%esp
c0029a99:	ff 75 10             	pushl  0x10(%ebp)
c0029a9c:	e8 2d fe ff ff       	call   c00298ce <list_prev>
c0029aa1:	83 c4 10             	add    $0x10,%esp
c0029aa4:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c0029aa7:	83 ec 0c             	sub    $0xc,%esp
c0029aaa:	ff 75 0c             	pushl  0xc(%ebp)
c0029aad:	e8 8d fc ff ff       	call   c002973f <is_interior>
c0029ab2:	83 c4 10             	add    $0x10,%esp
c0029ab5:	84 c0                	test   %al,%al
c0029ab7:	75 21                	jne    c0029ada <list_splice+0x95>
c0029ab9:	83 ec 0c             	sub    $0xc,%esp
c0029abc:	68 1a 0d 03 c0       	push   $0xc0030d1a
c0029ac1:	68 65 0c 03 c0       	push   $0xc0030c65
c0029ac6:	68 a8 0e 03 c0       	push   $0xc0030ea8
c0029acb:	68 c0 00 00 00       	push   $0xc0
c0029ad0:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029ad5:	e8 4e fa ff ff       	call   c0029528 <debug_panic>
  ASSERT (is_interior (last));
c0029ada:	83 ec 0c             	sub    $0xc,%esp
c0029add:	ff 75 10             	pushl  0x10(%ebp)
c0029ae0:	e8 5a fc ff ff       	call   c002973f <is_interior>
c0029ae5:	83 c4 10             	add    $0x10,%esp
c0029ae8:	84 c0                	test   %al,%al
c0029aea:	75 21                	jne    c0029b0d <list_splice+0xc8>
c0029aec:	83 ec 0c             	sub    $0xc,%esp
c0029aef:	68 2e 0d 03 c0       	push   $0xc0030d2e
c0029af4:	68 65 0c 03 c0       	push   $0xc0030c65
c0029af9:	68 a8 0e 03 c0       	push   $0xc0030ea8
c0029afe:	68 c1 00 00 00       	push   $0xc1
c0029b03:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029b08:	e8 1b fa ff ff       	call   c0029528 <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c0029b0d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b10:	8b 00                	mov    (%eax),%eax
c0029b12:	8b 55 10             	mov    0x10(%ebp),%edx
c0029b15:	8b 52 04             	mov    0x4(%edx),%edx
c0029b18:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c0029b1b:	8b 45 10             	mov    0x10(%ebp),%eax
c0029b1e:	8b 40 04             	mov    0x4(%eax),%eax
c0029b21:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029b24:	8b 12                	mov    (%edx),%edx
c0029b26:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c0029b28:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b2b:	8b 10                	mov    (%eax),%edx
c0029b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029b30:	89 10                	mov    %edx,(%eax)
  last->next = before;
c0029b32:	8b 45 10             	mov    0x10(%ebp),%eax
c0029b35:	8b 55 08             	mov    0x8(%ebp),%edx
c0029b38:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c0029b3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b3e:	8b 00                	mov    (%eax),%eax
c0029b40:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029b43:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c0029b46:	8b 45 08             	mov    0x8(%ebp),%eax
c0029b49:	8b 55 10             	mov    0x10(%ebp),%edx
c0029b4c:	89 10                	mov    %edx,(%eax)
c0029b4e:	eb 01                	jmp    c0029b51 <list_splice+0x10c>
    return;
c0029b50:	90                   	nop
}
c0029b51:	c9                   	leave  
c0029b52:	c3                   	ret    

c0029b53 <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c0029b53:	55                   	push   %ebp
c0029b54:	89 e5                	mov    %esp,%ebp
c0029b56:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c0029b59:	83 ec 0c             	sub    $0xc,%esp
c0029b5c:	ff 75 08             	pushl  0x8(%ebp)
c0029b5f:	e8 8a fc ff ff       	call   c00297ee <list_begin>
c0029b64:	83 c4 10             	add    $0x10,%esp
c0029b67:	83 ec 08             	sub    $0x8,%esp
c0029b6a:	ff 75 0c             	pushl  0xc(%ebp)
c0029b6d:	50                   	push   %eax
c0029b6e:	e8 3d fe ff ff       	call   c00299b0 <list_insert>
c0029b73:	83 c4 10             	add    $0x10,%esp
}
c0029b76:	90                   	nop
c0029b77:	c9                   	leave  
c0029b78:	c3                   	ret    

c0029b79 <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c0029b79:	55                   	push   %ebp
c0029b7a:	89 e5                	mov    %esp,%ebp
c0029b7c:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c0029b7f:	83 ec 0c             	sub    $0xc,%esp
c0029b82:	ff 75 08             	pushl  0x8(%ebp)
c0029b85:	e8 e0 fc ff ff       	call   c002986a <list_end>
c0029b8a:	83 c4 10             	add    $0x10,%esp
c0029b8d:	83 ec 08             	sub    $0x8,%esp
c0029b90:	ff 75 0c             	pushl  0xc(%ebp)
c0029b93:	50                   	push   %eax
c0029b94:	e8 17 fe ff ff       	call   c00299b0 <list_insert>
c0029b99:	83 c4 10             	add    $0x10,%esp
}
c0029b9c:	90                   	nop
c0029b9d:	c9                   	leave  
c0029b9e:	c3                   	ret    

c0029b9f <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c0029b9f:	55                   	push   %ebp
c0029ba0:	89 e5                	mov    %esp,%ebp
c0029ba2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c0029ba5:	ff 75 08             	pushl  0x8(%ebp)
c0029ba8:	e8 92 fb ff ff       	call   c002973f <is_interior>
c0029bad:	83 c4 04             	add    $0x4,%esp
c0029bb0:	84 c0                	test   %al,%al
c0029bb2:	75 21                	jne    c0029bd5 <list_remove+0x36>
c0029bb4:	83 ec 0c             	sub    $0xc,%esp
c0029bb7:	68 41 0d 03 c0       	push   $0xc0030d41
c0029bbc:	68 65 0c 03 c0       	push   $0xc0030c65
c0029bc1:	68 b4 0e 03 c0       	push   $0xc0030eb4
c0029bc6:	68 fb 00 00 00       	push   $0xfb
c0029bcb:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029bd0:	e8 53 f9 ff ff       	call   c0029528 <debug_panic>
  elem->prev->next = elem->next;
c0029bd5:	8b 45 08             	mov    0x8(%ebp),%eax
c0029bd8:	8b 00                	mov    (%eax),%eax
c0029bda:	8b 55 08             	mov    0x8(%ebp),%edx
c0029bdd:	8b 52 04             	mov    0x4(%edx),%edx
c0029be0:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c0029be3:	8b 45 08             	mov    0x8(%ebp),%eax
c0029be6:	8b 40 04             	mov    0x4(%eax),%eax
c0029be9:	8b 55 08             	mov    0x8(%ebp),%edx
c0029bec:	8b 12                	mov    (%edx),%edx
c0029bee:	89 10                	mov    %edx,(%eax)
  return elem->next;
c0029bf0:	8b 45 08             	mov    0x8(%ebp),%eax
c0029bf3:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029bf6:	c9                   	leave  
c0029bf7:	c3                   	ret    

c0029bf8 <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c0029bf8:	55                   	push   %ebp
c0029bf9:	89 e5                	mov    %esp,%ebp
c0029bfb:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c0029bfe:	83 ec 0c             	sub    $0xc,%esp
c0029c01:	ff 75 08             	pushl  0x8(%ebp)
c0029c04:	e8 43 00 00 00       	call   c0029c4c <list_front>
c0029c09:	83 c4 10             	add    $0x10,%esp
c0029c0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c0029c0f:	83 ec 0c             	sub    $0xc,%esp
c0029c12:	ff 75 f4             	pushl  -0xc(%ebp)
c0029c15:	e8 85 ff ff ff       	call   c0029b9f <list_remove>
c0029c1a:	83 c4 10             	add    $0x10,%esp
  return front;
c0029c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029c20:	c9                   	leave  
c0029c21:	c3                   	ret    

c0029c22 <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c0029c22:	55                   	push   %ebp
c0029c23:	89 e5                	mov    %esp,%ebp
c0029c25:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c0029c28:	83 ec 0c             	sub    $0xc,%esp
c0029c2b:	ff 75 08             	pushl  0x8(%ebp)
c0029c2e:	e8 5d 00 00 00       	call   c0029c90 <list_back>
c0029c33:	83 c4 10             	add    $0x10,%esp
c0029c36:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c0029c39:	83 ec 0c             	sub    $0xc,%esp
c0029c3c:	ff 75 f4             	pushl  -0xc(%ebp)
c0029c3f:	e8 5b ff ff ff       	call   c0029b9f <list_remove>
c0029c44:	83 c4 10             	add    $0x10,%esp
  return back;
c0029c47:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0029c4a:	c9                   	leave  
c0029c4b:	c3                   	ret    

c0029c4c <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c0029c4c:	55                   	push   %ebp
c0029c4d:	89 e5                	mov    %esp,%ebp
c0029c4f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029c52:	83 ec 0c             	sub    $0xc,%esp
c0029c55:	ff 75 08             	pushl  0x8(%ebp)
c0029c58:	e8 c3 00 00 00       	call   c0029d20 <list_empty>
c0029c5d:	83 c4 10             	add    $0x10,%esp
c0029c60:	83 f0 01             	xor    $0x1,%eax
c0029c63:	84 c0                	test   %al,%al
c0029c65:	75 21                	jne    c0029c88 <list_front+0x3c>
c0029c67:	83 ec 0c             	sub    $0xc,%esp
c0029c6a:	68 54 0d 03 c0       	push   $0xc0030d54
c0029c6f:	68 65 0c 03 c0       	push   $0xc0030c65
c0029c74:	68 c0 0e 03 c0       	push   $0xc0030ec0
c0029c79:	68 1a 01 00 00       	push   $0x11a
c0029c7e:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029c83:	e8 a0 f8 ff ff       	call   c0029528 <debug_panic>
  return list->head.next;
c0029c88:	8b 45 08             	mov    0x8(%ebp),%eax
c0029c8b:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029c8e:	c9                   	leave  
c0029c8f:	c3                   	ret    

c0029c90 <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c0029c90:	55                   	push   %ebp
c0029c91:	89 e5                	mov    %esp,%ebp
c0029c93:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c0029c96:	83 ec 0c             	sub    $0xc,%esp
c0029c99:	ff 75 08             	pushl  0x8(%ebp)
c0029c9c:	e8 7f 00 00 00       	call   c0029d20 <list_empty>
c0029ca1:	83 c4 10             	add    $0x10,%esp
c0029ca4:	83 f0 01             	xor    $0x1,%eax
c0029ca7:	84 c0                	test   %al,%al
c0029ca9:	75 21                	jne    c0029ccc <list_back+0x3c>
c0029cab:	83 ec 0c             	sub    $0xc,%esp
c0029cae:	68 54 0d 03 c0       	push   $0xc0030d54
c0029cb3:	68 65 0c 03 c0       	push   $0xc0030c65
c0029cb8:	68 cc 0e 03 c0       	push   $0xc0030ecc
c0029cbd:	68 23 01 00 00       	push   $0x123
c0029cc2:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029cc7:	e8 5c f8 ff ff       	call   c0029528 <debug_panic>
  return list->tail.prev;
c0029ccc:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ccf:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029cd2:	c9                   	leave  
c0029cd3:	c3                   	ret    

c0029cd4 <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c0029cd4:	55                   	push   %ebp
c0029cd5:	89 e5                	mov    %esp,%ebp
c0029cd7:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c0029cda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029ce1:	83 ec 0c             	sub    $0xc,%esp
c0029ce4:	ff 75 08             	pushl  0x8(%ebp)
c0029ce7:	e8 02 fb ff ff       	call   c00297ee <list_begin>
c0029cec:	83 c4 10             	add    $0x10,%esp
c0029cef:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029cf2:	eb 14                	jmp    c0029d08 <list_size+0x34>
    cnt++;
c0029cf4:	ff 45 f0             	incl   -0x10(%ebp)
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c0029cf7:	83 ec 0c             	sub    $0xc,%esp
c0029cfa:	ff 75 f4             	pushl  -0xc(%ebp)
c0029cfd:	e8 1e fb ff ff       	call   c0029820 <list_next>
c0029d02:	83 c4 10             	add    $0x10,%esp
c0029d05:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029d08:	83 ec 0c             	sub    $0xc,%esp
c0029d0b:	ff 75 08             	pushl  0x8(%ebp)
c0029d0e:	e8 57 fb ff ff       	call   c002986a <list_end>
c0029d13:	83 c4 10             	add    $0x10,%esp
c0029d16:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029d19:	75 d9                	jne    c0029cf4 <list_size+0x20>
  return cnt;
c0029d1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029d1e:	c9                   	leave  
c0029d1f:	c3                   	ret    

c0029d20 <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c0029d20:	55                   	push   %ebp
c0029d21:	89 e5                	mov    %esp,%ebp
c0029d23:	53                   	push   %ebx
c0029d24:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c0029d27:	83 ec 0c             	sub    $0xc,%esp
c0029d2a:	ff 75 08             	pushl  0x8(%ebp)
c0029d2d:	e8 bc fa ff ff       	call   c00297ee <list_begin>
c0029d32:	83 c4 10             	add    $0x10,%esp
c0029d35:	89 c3                	mov    %eax,%ebx
c0029d37:	83 ec 0c             	sub    $0xc,%esp
c0029d3a:	ff 75 08             	pushl  0x8(%ebp)
c0029d3d:	e8 28 fb ff ff       	call   c002986a <list_end>
c0029d42:	83 c4 10             	add    $0x10,%esp
c0029d45:	39 c3                	cmp    %eax,%ebx
c0029d47:	0f 94 c0             	sete   %al
}
c0029d4a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029d4d:	c9                   	leave  
c0029d4e:	c3                   	ret    

c0029d4f <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c0029d4f:	55                   	push   %ebp
c0029d50:	89 e5                	mov    %esp,%ebp
c0029d52:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c0029d55:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d58:	8b 00                	mov    (%eax),%eax
c0029d5a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c0029d5d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d60:	8b 10                	mov    (%eax),%edx
c0029d62:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d65:	89 10                	mov    %edx,(%eax)
  *b = t;
c0029d67:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029d6a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029d6d:	89 10                	mov    %edx,(%eax)
}
c0029d6f:	90                   	nop
c0029d70:	c9                   	leave  
c0029d71:	c3                   	ret    

c0029d72 <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c0029d72:	55                   	push   %ebp
c0029d73:	89 e5                	mov    %esp,%ebp
c0029d75:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c0029d78:	83 ec 0c             	sub    $0xc,%esp
c0029d7b:	ff 75 08             	pushl  0x8(%ebp)
c0029d7e:	e8 9d ff ff ff       	call   c0029d20 <list_empty>
c0029d83:	83 c4 10             	add    $0x10,%esp
c0029d86:	83 f0 01             	xor    $0x1,%eax
c0029d89:	84 c0                	test   %al,%al
c0029d8b:	74 79                	je     c0029e06 <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029d8d:	83 ec 0c             	sub    $0xc,%esp
c0029d90:	ff 75 08             	pushl  0x8(%ebp)
c0029d93:	e8 56 fa ff ff       	call   c00297ee <list_begin>
c0029d98:	83 c4 10             	add    $0x10,%esp
c0029d9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029d9e:	eb 1e                	jmp    c0029dbe <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c0029da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029da3:	8d 50 04             	lea    0x4(%eax),%edx
c0029da6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029da9:	83 ec 08             	sub    $0x8,%esp
c0029dac:	52                   	push   %edx
c0029dad:	50                   	push   %eax
c0029dae:	e8 9c ff ff ff       	call   c0029d4f <swap>
c0029db3:	83 c4 10             	add    $0x10,%esp
      for (e = list_begin (list); e != list_end (list); e = e->prev)
c0029db6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029db9:	8b 00                	mov    (%eax),%eax
c0029dbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029dbe:	83 ec 0c             	sub    $0xc,%esp
c0029dc1:	ff 75 08             	pushl  0x8(%ebp)
c0029dc4:	e8 a1 fa ff ff       	call   c002986a <list_end>
c0029dc9:	83 c4 10             	add    $0x10,%esp
c0029dcc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029dcf:	75 cf                	jne    c0029da0 <list_reverse+0x2e>
      swap (&list->head.next, &list->tail.prev);
c0029dd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0029dd4:	8d 50 08             	lea    0x8(%eax),%edx
c0029dd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0029dda:	83 c0 04             	add    $0x4,%eax
c0029ddd:	83 ec 08             	sub    $0x8,%esp
c0029de0:	52                   	push   %edx
c0029de1:	50                   	push   %eax
c0029de2:	e8 68 ff ff ff       	call   c0029d4f <swap>
c0029de7:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c0029dea:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ded:	8b 40 08             	mov    0x8(%eax),%eax
c0029df0:	8d 50 04             	lea    0x4(%eax),%edx
c0029df3:	8b 45 08             	mov    0x8(%ebp),%eax
c0029df6:	8b 40 04             	mov    0x4(%eax),%eax
c0029df9:	83 ec 08             	sub    $0x8,%esp
c0029dfc:	52                   	push   %edx
c0029dfd:	50                   	push   %eax
c0029dfe:	e8 4c ff ff ff       	call   c0029d4f <swap>
c0029e03:	83 c4 10             	add    $0x10,%esp
    }
}
c0029e06:	90                   	nop
c0029e07:	c9                   	leave  
c0029e08:	c3                   	ret    

c0029e09 <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c0029e09:	55                   	push   %ebp
c0029e0a:	89 e5                	mov    %esp,%ebp
c0029e0c:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c0029e0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e12:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029e15:	74 43                	je     c0029e5a <is_sorted+0x51>
    while ((a = list_next (a)) != b) 
c0029e17:	eb 28                	jmp    c0029e41 <is_sorted+0x38>
      if (less (a, list_prev (a), aux))
c0029e19:	83 ec 0c             	sub    $0xc,%esp
c0029e1c:	ff 75 08             	pushl  0x8(%ebp)
c0029e1f:	e8 aa fa ff ff       	call   c00298ce <list_prev>
c0029e24:	83 c4 10             	add    $0x10,%esp
c0029e27:	83 ec 04             	sub    $0x4,%esp
c0029e2a:	ff 75 14             	pushl  0x14(%ebp)
c0029e2d:	50                   	push   %eax
c0029e2e:	ff 75 08             	pushl  0x8(%ebp)
c0029e31:	8b 45 10             	mov    0x10(%ebp),%eax
c0029e34:	ff d0                	call   *%eax
c0029e36:	83 c4 10             	add    $0x10,%esp
c0029e39:	84 c0                	test   %al,%al
c0029e3b:	74 04                	je     c0029e41 <is_sorted+0x38>
        return false;
c0029e3d:	b0 00                	mov    $0x0,%al
c0029e3f:	eb 1b                	jmp    c0029e5c <is_sorted+0x53>
    while ((a = list_next (a)) != b) 
c0029e41:	83 ec 0c             	sub    $0xc,%esp
c0029e44:	ff 75 08             	pushl  0x8(%ebp)
c0029e47:	e8 d4 f9 ff ff       	call   c0029820 <list_next>
c0029e4c:	83 c4 10             	add    $0x10,%esp
c0029e4f:	89 45 08             	mov    %eax,0x8(%ebp)
c0029e52:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e55:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029e58:	75 bf                	jne    c0029e19 <is_sorted+0x10>
  return true;
c0029e5a:	b0 01                	mov    $0x1,%al
}
c0029e5c:	c9                   	leave  
c0029e5d:	c3                   	ret    

c0029e5e <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c0029e5e:	55                   	push   %ebp
c0029e5f:	89 e5                	mov    %esp,%ebp
c0029e61:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0029e64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e68:	75 21                	jne    c0029e8b <find_end_of_run+0x2d>
c0029e6a:	83 ec 0c             	sub    $0xc,%esp
c0029e6d:	68 67 0d 03 c0       	push   $0xc0030d67
c0029e72:	68 65 0c 03 c0       	push   $0xc0030c65
c0029e77:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029e7c:	68 69 01 00 00       	push   $0x169
c0029e81:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029e86:	e8 9d f6 ff ff       	call   c0029528 <debug_panic>
  ASSERT (b != NULL);
c0029e8b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029e8f:	75 21                	jne    c0029eb2 <find_end_of_run+0x54>
c0029e91:	83 ec 0c             	sub    $0xc,%esp
c0029e94:	68 71 0d 03 c0       	push   $0xc0030d71
c0029e99:	68 65 0c 03 c0       	push   $0xc0030c65
c0029e9e:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029ea3:	68 6a 01 00 00       	push   $0x16a
c0029ea8:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029ead:	e8 76 f6 ff ff       	call   c0029528 <debug_panic>
  ASSERT (less != NULL);
c0029eb2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029eb6:	75 21                	jne    c0029ed9 <find_end_of_run+0x7b>
c0029eb8:	83 ec 0c             	sub    $0xc,%esp
c0029ebb:	68 7b 0d 03 c0       	push   $0xc0030d7b
c0029ec0:	68 65 0c 03 c0       	push   $0xc0030c65
c0029ec5:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029eca:	68 6b 01 00 00       	push   $0x16b
c0029ecf:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029ed4:	e8 4f f6 ff ff       	call   c0029528 <debug_panic>
  ASSERT (a != b);
c0029ed9:	8b 45 08             	mov    0x8(%ebp),%eax
c0029edc:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029edf:	75 21                	jne    c0029f02 <find_end_of_run+0xa4>
c0029ee1:	83 ec 0c             	sub    $0xc,%esp
c0029ee4:	68 88 0d 03 c0       	push   $0xc0030d88
c0029ee9:	68 65 0c 03 c0       	push   $0xc0030c65
c0029eee:	68 d8 0e 03 c0       	push   $0xc0030ed8
c0029ef3:	68 6c 01 00 00       	push   $0x16c
c0029ef8:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029efd:	e8 26 f6 ff ff       	call   c0029528 <debug_panic>
  
  do 
    {
      a = list_next (a);
c0029f02:	83 ec 0c             	sub    $0xc,%esp
c0029f05:	ff 75 08             	pushl  0x8(%ebp)
c0029f08:	e8 13 f9 ff ff       	call   c0029820 <list_next>
c0029f0d:	83 c4 10             	add    $0x10,%esp
c0029f10:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c0029f13:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f16:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029f19:	74 27                	je     c0029f42 <find_end_of_run+0xe4>
c0029f1b:	83 ec 0c             	sub    $0xc,%esp
c0029f1e:	ff 75 08             	pushl  0x8(%ebp)
c0029f21:	e8 a8 f9 ff ff       	call   c00298ce <list_prev>
c0029f26:	83 c4 10             	add    $0x10,%esp
c0029f29:	83 ec 04             	sub    $0x4,%esp
c0029f2c:	ff 75 14             	pushl  0x14(%ebp)
c0029f2f:	50                   	push   %eax
c0029f30:	ff 75 08             	pushl  0x8(%ebp)
c0029f33:	8b 45 10             	mov    0x10(%ebp),%eax
c0029f36:	ff d0                	call   *%eax
c0029f38:	83 c4 10             	add    $0x10,%esp
c0029f3b:	83 f0 01             	xor    $0x1,%eax
c0029f3e:	84 c0                	test   %al,%al
c0029f40:	75 c0                	jne    c0029f02 <find_end_of_run+0xa4>
  return a;
c0029f42:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029f45:	c9                   	leave  
c0029f46:	c3                   	ret    

c0029f47 <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c0029f47:	55                   	push   %ebp
c0029f48:	89 e5                	mov    %esp,%ebp
c0029f4a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c0029f4d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f51:	75 21                	jne    c0029f74 <inplace_merge+0x2d>
c0029f53:	83 ec 0c             	sub    $0xc,%esp
c0029f56:	68 8f 0d 03 c0       	push   $0xc0030d8f
c0029f5b:	68 65 0c 03 c0       	push   $0xc0030c65
c0029f60:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029f65:	68 80 01 00 00       	push   $0x180
c0029f6a:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029f6f:	e8 b4 f5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (a1b0 != NULL);
c0029f74:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029f78:	75 21                	jne    c0029f9b <inplace_merge+0x54>
c0029f7a:	83 ec 0c             	sub    $0xc,%esp
c0029f7d:	68 9a 0d 03 c0       	push   $0xc0030d9a
c0029f82:	68 65 0c 03 c0       	push   $0xc0030c65
c0029f87:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029f8c:	68 81 01 00 00       	push   $0x181
c0029f91:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029f96:	e8 8d f5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (b1 != NULL);
c0029f9b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029f9f:	75 21                	jne    c0029fc2 <inplace_merge+0x7b>
c0029fa1:	83 ec 0c             	sub    $0xc,%esp
c0029fa4:	68 a7 0d 03 c0       	push   $0xc0030da7
c0029fa9:	68 65 0c 03 c0       	push   $0xc0030c65
c0029fae:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029fb3:	68 82 01 00 00       	push   $0x182
c0029fb8:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029fbd:	e8 66 f5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (less != NULL);
c0029fc2:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0029fc6:	75 21                	jne    c0029fe9 <inplace_merge+0xa2>
c0029fc8:	83 ec 0c             	sub    $0xc,%esp
c0029fcb:	68 7b 0d 03 c0       	push   $0xc0030d7b
c0029fd0:	68 65 0c 03 c0       	push   $0xc0030c65
c0029fd5:	68 e8 0e 03 c0       	push   $0xc0030ee8
c0029fda:	68 83 01 00 00       	push   $0x183
c0029fdf:	68 7c 0c 03 c0       	push   $0xc0030c7c
c0029fe4:	e8 3f f5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c0029fe9:	ff 75 18             	pushl  0x18(%ebp)
c0029fec:	ff 75 14             	pushl  0x14(%ebp)
c0029fef:	ff 75 0c             	pushl  0xc(%ebp)
c0029ff2:	ff 75 08             	pushl  0x8(%ebp)
c0029ff5:	e8 0f fe ff ff       	call   c0029e09 <is_sorted>
c0029ffa:	83 c4 10             	add    $0x10,%esp
c0029ffd:	84 c0                	test   %al,%al
c0029fff:	75 21                	jne    c002a022 <inplace_merge+0xdb>
c002a001:	83 ec 0c             	sub    $0xc,%esp
c002a004:	68 b4 0d 03 c0       	push   $0xc0030db4
c002a009:	68 65 0c 03 c0       	push   $0xc0030c65
c002a00e:	68 e8 0e 03 c0       	push   $0xc0030ee8
c002a013:	68 84 01 00 00       	push   $0x184
c002a018:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a01d:	e8 06 f5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002a022:	ff 75 18             	pushl  0x18(%ebp)
c002a025:	ff 75 14             	pushl  0x14(%ebp)
c002a028:	ff 75 10             	pushl  0x10(%ebp)
c002a02b:	ff 75 0c             	pushl  0xc(%ebp)
c002a02e:	e8 d6 fd ff ff       	call   c0029e09 <is_sorted>
c002a033:	83 c4 10             	add    $0x10,%esp
c002a036:	84 c0                	test   %al,%al
c002a038:	0f 85 80 00 00 00    	jne    c002a0be <inplace_merge+0x177>
c002a03e:	83 ec 0c             	sub    $0xc,%esp
c002a041:	68 d4 0d 03 c0       	push   $0xc0030dd4
c002a046:	68 65 0c 03 c0       	push   $0xc0030c65
c002a04b:	68 e8 0e 03 c0       	push   $0xc0030ee8
c002a050:	68 85 01 00 00       	push   $0x185
c002a055:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a05a:	e8 c9 f4 ff ff       	call   c0029528 <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002a05f:	83 ec 04             	sub    $0x4,%esp
c002a062:	ff 75 18             	pushl  0x18(%ebp)
c002a065:	ff 75 08             	pushl  0x8(%ebp)
c002a068:	ff 75 0c             	pushl  0xc(%ebp)
c002a06b:	8b 45 14             	mov    0x14(%ebp),%eax
c002a06e:	ff d0                	call   *%eax
c002a070:	83 c4 10             	add    $0x10,%esp
c002a073:	83 f0 01             	xor    $0x1,%eax
c002a076:	84 c0                	test   %al,%al
c002a078:	74 13                	je     c002a08d <inplace_merge+0x146>
      a0 = list_next (a0);
c002a07a:	83 ec 0c             	sub    $0xc,%esp
c002a07d:	ff 75 08             	pushl  0x8(%ebp)
c002a080:	e8 9b f7 ff ff       	call   c0029820 <list_next>
c002a085:	83 c4 10             	add    $0x10,%esp
c002a088:	89 45 08             	mov    %eax,0x8(%ebp)
c002a08b:	eb 31                	jmp    c002a0be <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002a08d:	83 ec 0c             	sub    $0xc,%esp
c002a090:	ff 75 0c             	pushl  0xc(%ebp)
c002a093:	e8 88 f7 ff ff       	call   c0029820 <list_next>
c002a098:	83 c4 10             	add    $0x10,%esp
c002a09b:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002a09e:	83 ec 0c             	sub    $0xc,%esp
c002a0a1:	ff 75 0c             	pushl  0xc(%ebp)
c002a0a4:	e8 25 f8 ff ff       	call   c00298ce <list_prev>
c002a0a9:	83 c4 10             	add    $0x10,%esp
c002a0ac:	83 ec 04             	sub    $0x4,%esp
c002a0af:	ff 75 0c             	pushl  0xc(%ebp)
c002a0b2:	50                   	push   %eax
c002a0b3:	ff 75 08             	pushl  0x8(%ebp)
c002a0b6:	e8 8a f9 ff ff       	call   c0029a45 <list_splice>
c002a0bb:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c002a0be:	8b 45 08             	mov    0x8(%ebp),%eax
c002a0c1:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a0c4:	74 08                	je     c002a0ce <inplace_merge+0x187>
c002a0c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a0c9:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a0cc:	75 91                	jne    c002a05f <inplace_merge+0x118>
      }
}
c002a0ce:	90                   	nop
c002a0cf:	c9                   	leave  
c002a0d0:	c3                   	ret    

c002a0d1 <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002a0d1:	55                   	push   %ebp
c002a0d2:	89 e5                	mov    %esp,%ebp
c002a0d4:	53                   	push   %ebx
c002a0d5:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002a0d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a0dc:	75 21                	jne    c002a0ff <list_sort+0x2e>
c002a0de:	83 ec 0c             	sub    $0xc,%esp
c002a0e1:	68 58 0c 03 c0       	push   $0xc0030c58
c002a0e6:	68 65 0c 03 c0       	push   $0xc0030c65
c002a0eb:	68 f8 0e 03 c0       	push   $0xc0030ef8
c002a0f0:	68 99 01 00 00       	push   $0x199
c002a0f5:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a0fa:	e8 29 f4 ff ff       	call   c0029528 <debug_panic>
  ASSERT (less != NULL);
c002a0ff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a103:	75 21                	jne    c002a126 <list_sort+0x55>
c002a105:	83 ec 0c             	sub    $0xc,%esp
c002a108:	68 7b 0d 03 c0       	push   $0xc0030d7b
c002a10d:	68 65 0c 03 c0       	push   $0xc0030c65
c002a112:	68 f8 0e 03 c0       	push   $0xc0030ef8
c002a117:	68 9a 01 00 00       	push   $0x19a
c002a11c:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a121:	e8 02 f4 ff ff       	call   c0029528 <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002a126:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a12d:	83 ec 0c             	sub    $0xc,%esp
c002a130:	ff 75 08             	pushl  0x8(%ebp)
c002a133:	e8 b6 f6 ff ff       	call   c00297ee <list_begin>
c002a138:	83 c4 10             	add    $0x10,%esp
c002a13b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a13e:	eb 7c                	jmp    c002a1bc <list_sort+0xeb>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002a140:	ff 45 f4             	incl   -0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002a143:	83 ec 0c             	sub    $0xc,%esp
c002a146:	ff 75 08             	pushl  0x8(%ebp)
c002a149:	e8 1c f7 ff ff       	call   c002986a <list_end>
c002a14e:	83 c4 10             	add    $0x10,%esp
c002a151:	ff 75 10             	pushl  0x10(%ebp)
c002a154:	ff 75 0c             	pushl  0xc(%ebp)
c002a157:	50                   	push   %eax
c002a158:	ff 75 f0             	pushl  -0x10(%ebp)
c002a15b:	e8 fe fc ff ff       	call   c0029e5e <find_end_of_run>
c002a160:	83 c4 10             	add    $0x10,%esp
c002a163:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002a166:	83 ec 0c             	sub    $0xc,%esp
c002a169:	ff 75 08             	pushl  0x8(%ebp)
c002a16c:	e8 f9 f6 ff ff       	call   c002986a <list_end>
c002a171:	83 c4 10             	add    $0x10,%esp
c002a174:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002a177:	74 5c                	je     c002a1d5 <list_sort+0x104>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002a179:	83 ec 0c             	sub    $0xc,%esp
c002a17c:	ff 75 08             	pushl  0x8(%ebp)
c002a17f:	e8 e6 f6 ff ff       	call   c002986a <list_end>
c002a184:	83 c4 10             	add    $0x10,%esp
c002a187:	ff 75 10             	pushl  0x10(%ebp)
c002a18a:	ff 75 0c             	pushl  0xc(%ebp)
c002a18d:	50                   	push   %eax
c002a18e:	ff 75 ec             	pushl  -0x14(%ebp)
c002a191:	e8 c8 fc ff ff       	call   c0029e5e <find_end_of_run>
c002a196:	83 c4 10             	add    $0x10,%esp
c002a199:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002a19c:	83 ec 0c             	sub    $0xc,%esp
c002a19f:	ff 75 10             	pushl  0x10(%ebp)
c002a1a2:	ff 75 0c             	pushl  0xc(%ebp)
c002a1a5:	ff 75 e8             	pushl  -0x18(%ebp)
c002a1a8:	ff 75 ec             	pushl  -0x14(%ebp)
c002a1ab:	ff 75 f0             	pushl  -0x10(%ebp)
c002a1ae:	e8 94 fd ff ff       	call   c0029f47 <inplace_merge>
c002a1b3:	83 c4 20             	add    $0x20,%esp
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a1b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a1b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a1bc:	83 ec 0c             	sub    $0xc,%esp
c002a1bf:	ff 75 08             	pushl  0x8(%ebp)
c002a1c2:	e8 a3 f6 ff ff       	call   c002986a <list_end>
c002a1c7:	83 c4 10             	add    $0x10,%esp
c002a1ca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a1cd:	0f 85 6d ff ff ff    	jne    c002a140 <list_sort+0x6f>
c002a1d3:	eb 01                	jmp    c002a1d6 <list_sort+0x105>
            break;
c002a1d5:	90                   	nop
        }
    }
  while (output_run_cnt > 1);
c002a1d6:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a1da:	0f 87 46 ff ff ff    	ja     c002a126 <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002a1e0:	83 ec 0c             	sub    $0xc,%esp
c002a1e3:	ff 75 08             	pushl  0x8(%ebp)
c002a1e6:	e8 7f f6 ff ff       	call   c002986a <list_end>
c002a1eb:	83 c4 10             	add    $0x10,%esp
c002a1ee:	89 c3                	mov    %eax,%ebx
c002a1f0:	83 ec 0c             	sub    $0xc,%esp
c002a1f3:	ff 75 08             	pushl  0x8(%ebp)
c002a1f6:	e8 f3 f5 ff ff       	call   c00297ee <list_begin>
c002a1fb:	83 c4 10             	add    $0x10,%esp
c002a1fe:	ff 75 10             	pushl  0x10(%ebp)
c002a201:	ff 75 0c             	pushl  0xc(%ebp)
c002a204:	53                   	push   %ebx
c002a205:	50                   	push   %eax
c002a206:	e8 fe fb ff ff       	call   c0029e09 <is_sorted>
c002a20b:	83 c4 10             	add    $0x10,%esp
c002a20e:	84 c0                	test   %al,%al
c002a210:	75 21                	jne    c002a233 <list_sort+0x162>
c002a212:	83 ec 0c             	sub    $0xc,%esp
c002a215:	68 f4 0d 03 c0       	push   $0xc0030df4
c002a21a:	68 65 0c 03 c0       	push   $0xc0030c65
c002a21f:	68 f8 0e 03 c0       	push   $0xc0030ef8
c002a224:	68 b7 01 00 00       	push   $0x1b7
c002a229:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a22e:	e8 f5 f2 ff ff       	call   c0029528 <debug_panic>
}
c002a233:	90                   	nop
c002a234:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a237:	c9                   	leave  
c002a238:	c3                   	ret    

c002a239 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002a239:	55                   	push   %ebp
c002a23a:	89 e5                	mov    %esp,%ebp
c002a23c:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002a23f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a243:	75 21                	jne    c002a266 <list_insert_ordered+0x2d>
c002a245:	83 ec 0c             	sub    $0xc,%esp
c002a248:	68 58 0c 03 c0       	push   $0xc0030c58
c002a24d:	68 65 0c 03 c0       	push   $0xc0030c65
c002a252:	68 04 0f 03 c0       	push   $0xc0030f04
c002a257:	68 c3 01 00 00       	push   $0x1c3
c002a25c:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a261:	e8 c2 f2 ff ff       	call   c0029528 <debug_panic>
  ASSERT (elem != NULL);
c002a266:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a26a:	75 21                	jne    c002a28d <list_insert_ordered+0x54>
c002a26c:	83 ec 0c             	sub    $0xc,%esp
c002a26f:	68 0d 0d 03 c0       	push   $0xc0030d0d
c002a274:	68 65 0c 03 c0       	push   $0xc0030c65
c002a279:	68 04 0f 03 c0       	push   $0xc0030f04
c002a27e:	68 c4 01 00 00       	push   $0x1c4
c002a283:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a288:	e8 9b f2 ff ff       	call   c0029528 <debug_panic>
  ASSERT (less != NULL);
c002a28d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a291:	75 21                	jne    c002a2b4 <list_insert_ordered+0x7b>
c002a293:	83 ec 0c             	sub    $0xc,%esp
c002a296:	68 7b 0d 03 c0       	push   $0xc0030d7b
c002a29b:	68 65 0c 03 c0       	push   $0xc0030c65
c002a2a0:	68 04 0f 03 c0       	push   $0xc0030f04
c002a2a5:	68 c5 01 00 00       	push   $0x1c5
c002a2aa:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a2af:	e8 74 f2 ff ff       	call   c0029528 <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a2b4:	83 ec 0c             	sub    $0xc,%esp
c002a2b7:	ff 75 08             	pushl  0x8(%ebp)
c002a2ba:	e8 2f f5 ff ff       	call   c00297ee <list_begin>
c002a2bf:	83 c4 10             	add    $0x10,%esp
c002a2c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a2c5:	eb 29                	jmp    c002a2f0 <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002a2c7:	83 ec 04             	sub    $0x4,%esp
c002a2ca:	ff 75 14             	pushl  0x14(%ebp)
c002a2cd:	ff 75 f4             	pushl  -0xc(%ebp)
c002a2d0:	ff 75 0c             	pushl  0xc(%ebp)
c002a2d3:	8b 45 10             	mov    0x10(%ebp),%eax
c002a2d6:	ff d0                	call   *%eax
c002a2d8:	83 c4 10             	add    $0x10,%esp
c002a2db:	84 c0                	test   %al,%al
c002a2dd:	75 26                	jne    c002a305 <list_insert_ordered+0xcc>
  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a2df:	83 ec 0c             	sub    $0xc,%esp
c002a2e2:	ff 75 f4             	pushl  -0xc(%ebp)
c002a2e5:	e8 36 f5 ff ff       	call   c0029820 <list_next>
c002a2ea:	83 c4 10             	add    $0x10,%esp
c002a2ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a2f0:	83 ec 0c             	sub    $0xc,%esp
c002a2f3:	ff 75 08             	pushl  0x8(%ebp)
c002a2f6:	e8 6f f5 ff ff       	call   c002986a <list_end>
c002a2fb:	83 c4 10             	add    $0x10,%esp
c002a2fe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a301:	75 c4                	jne    c002a2c7 <list_insert_ordered+0x8e>
c002a303:	eb 01                	jmp    c002a306 <list_insert_ordered+0xcd>
      break;
c002a305:	90                   	nop
  return list_insert (e, elem);
c002a306:	83 ec 08             	sub    $0x8,%esp
c002a309:	ff 75 0c             	pushl  0xc(%ebp)
c002a30c:	ff 75 f4             	pushl  -0xc(%ebp)
c002a30f:	e8 9c f6 ff ff       	call   c00299b0 <list_insert>
c002a314:	83 c4 10             	add    $0x10,%esp
}
c002a317:	c9                   	leave  
c002a318:	c3                   	ret    

c002a319 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002a319:	55                   	push   %ebp
c002a31a:	89 e5                	mov    %esp,%ebp
c002a31c:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002a31f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a323:	75 21                	jne    c002a346 <list_unique+0x2d>
c002a325:	83 ec 0c             	sub    $0xc,%esp
c002a328:	68 58 0c 03 c0       	push   $0xc0030c58
c002a32d:	68 65 0c 03 c0       	push   $0xc0030c65
c002a332:	68 18 0f 03 c0       	push   $0xc0030f18
c002a337:	68 d7 01 00 00       	push   $0x1d7
c002a33c:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a341:	e8 e2 f1 ff ff       	call   c0029528 <debug_panic>
  ASSERT (less != NULL);
c002a346:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a34a:	75 21                	jne    c002a36d <list_unique+0x54>
c002a34c:	83 ec 0c             	sub    $0xc,%esp
c002a34f:	68 7b 0d 03 c0       	push   $0xc0030d7b
c002a354:	68 65 0c 03 c0       	push   $0xc0030c65
c002a359:	68 18 0f 03 c0       	push   $0xc0030f18
c002a35e:	68 d8 01 00 00       	push   $0x1d8
c002a363:	68 7c 0c 03 c0       	push   $0xc0030c7c
c002a368:	e8 bb f1 ff ff       	call   c0029528 <debug_panic>
  if (list_empty (list))
c002a36d:	83 ec 0c             	sub    $0xc,%esp
c002a370:	ff 75 08             	pushl  0x8(%ebp)
c002a373:	e8 a8 f9 ff ff       	call   c0029d20 <list_empty>
c002a378:	83 c4 10             	add    $0x10,%esp
c002a37b:	84 c0                	test   %al,%al
c002a37d:	0f 85 a0 00 00 00    	jne    c002a423 <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002a383:	83 ec 0c             	sub    $0xc,%esp
c002a386:	ff 75 08             	pushl  0x8(%ebp)
c002a389:	e8 60 f4 ff ff       	call   c00297ee <list_begin>
c002a38e:	83 c4 10             	add    $0x10,%esp
c002a391:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a394:	eb 63                	jmp    c002a3f9 <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002a396:	83 ec 04             	sub    $0x4,%esp
c002a399:	ff 75 14             	pushl  0x14(%ebp)
c002a39c:	ff 75 f0             	pushl  -0x10(%ebp)
c002a39f:	ff 75 f4             	pushl  -0xc(%ebp)
c002a3a2:	8b 45 10             	mov    0x10(%ebp),%eax
c002a3a5:	ff d0                	call   *%eax
c002a3a7:	83 c4 10             	add    $0x10,%esp
c002a3aa:	83 f0 01             	xor    $0x1,%eax
c002a3ad:	84 c0                	test   %al,%al
c002a3af:	74 42                	je     c002a3f3 <list_unique+0xda>
c002a3b1:	83 ec 04             	sub    $0x4,%esp
c002a3b4:	ff 75 14             	pushl  0x14(%ebp)
c002a3b7:	ff 75 f4             	pushl  -0xc(%ebp)
c002a3ba:	ff 75 f0             	pushl  -0x10(%ebp)
c002a3bd:	8b 45 10             	mov    0x10(%ebp),%eax
c002a3c0:	ff d0                	call   *%eax
c002a3c2:	83 c4 10             	add    $0x10,%esp
c002a3c5:	83 f0 01             	xor    $0x1,%eax
c002a3c8:	84 c0                	test   %al,%al
c002a3ca:	74 27                	je     c002a3f3 <list_unique+0xda>
      {
        list_remove (next);
c002a3cc:	83 ec 0c             	sub    $0xc,%esp
c002a3cf:	ff 75 f0             	pushl  -0x10(%ebp)
c002a3d2:	e8 c8 f7 ff ff       	call   c0029b9f <list_remove>
c002a3d7:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a3da:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a3de:	74 19                	je     c002a3f9 <list_unique+0xe0>
          list_push_back (duplicates, next);
c002a3e0:	83 ec 08             	sub    $0x8,%esp
c002a3e3:	ff 75 f0             	pushl  -0x10(%ebp)
c002a3e6:	ff 75 0c             	pushl  0xc(%ebp)
c002a3e9:	e8 8b f7 ff ff       	call   c0029b79 <list_push_back>
c002a3ee:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002a3f1:	eb 06                	jmp    c002a3f9 <list_unique+0xe0>
      }
    else
      elem = next;
c002a3f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a3f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002a3f9:	83 ec 0c             	sub    $0xc,%esp
c002a3fc:	ff 75 f4             	pushl  -0xc(%ebp)
c002a3ff:	e8 1c f4 ff ff       	call   c0029820 <list_next>
c002a404:	83 c4 10             	add    $0x10,%esp
c002a407:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a40a:	83 ec 0c             	sub    $0xc,%esp
c002a40d:	ff 75 08             	pushl  0x8(%ebp)
c002a410:	e8 55 f4 ff ff       	call   c002986a <list_end>
c002a415:	83 c4 10             	add    $0x10,%esp
c002a418:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002a41b:	0f 85 75 ff ff ff    	jne    c002a396 <list_unique+0x7d>
c002a421:	eb 01                	jmp    c002a424 <list_unique+0x10b>
    return;
c002a423:	90                   	nop
}
c002a424:	c9                   	leave  
c002a425:	c3                   	ret    

c002a426 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002a426:	55                   	push   %ebp
c002a427:	89 e5                	mov    %esp,%ebp
c002a429:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002a42c:	83 ec 0c             	sub    $0xc,%esp
c002a42f:	ff 75 08             	pushl  0x8(%ebp)
c002a432:	e8 b7 f3 ff ff       	call   c00297ee <list_begin>
c002a437:	83 c4 10             	add    $0x10,%esp
c002a43a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002a43d:	83 ec 0c             	sub    $0xc,%esp
c002a440:	ff 75 08             	pushl  0x8(%ebp)
c002a443:	e8 22 f4 ff ff       	call   c002986a <list_end>
c002a448:	83 c4 10             	add    $0x10,%esp
c002a44b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a44e:	74 55                	je     c002a4a5 <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a450:	83 ec 0c             	sub    $0xc,%esp
c002a453:	ff 75 f4             	pushl  -0xc(%ebp)
c002a456:	e8 c5 f3 ff ff       	call   c0029820 <list_next>
c002a45b:	83 c4 10             	add    $0x10,%esp
c002a45e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a461:	eb 2f                	jmp    c002a492 <list_max+0x6c>
        if (less (max, e, aux))
c002a463:	83 ec 04             	sub    $0x4,%esp
c002a466:	ff 75 10             	pushl  0x10(%ebp)
c002a469:	ff 75 f0             	pushl  -0x10(%ebp)
c002a46c:	ff 75 f4             	pushl  -0xc(%ebp)
c002a46f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a472:	ff d0                	call   *%eax
c002a474:	83 c4 10             	add    $0x10,%esp
c002a477:	84 c0                	test   %al,%al
c002a479:	74 06                	je     c002a481 <list_max+0x5b>
          max = e; 
c002a47b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a47e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002a481:	83 ec 0c             	sub    $0xc,%esp
c002a484:	ff 75 f0             	pushl  -0x10(%ebp)
c002a487:	e8 94 f3 ff ff       	call   c0029820 <list_next>
c002a48c:	83 c4 10             	add    $0x10,%esp
c002a48f:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a492:	83 ec 0c             	sub    $0xc,%esp
c002a495:	ff 75 08             	pushl  0x8(%ebp)
c002a498:	e8 cd f3 ff ff       	call   c002986a <list_end>
c002a49d:	83 c4 10             	add    $0x10,%esp
c002a4a0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a4a3:	75 be                	jne    c002a463 <list_max+0x3d>
    }
  return max;
c002a4a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a4a8:	c9                   	leave  
c002a4a9:	c3                   	ret    

c002a4aa <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002a4aa:	55                   	push   %ebp
c002a4ab:	89 e5                	mov    %esp,%ebp
c002a4ad:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002a4b0:	83 ec 0c             	sub    $0xc,%esp
c002a4b3:	ff 75 08             	pushl  0x8(%ebp)
c002a4b6:	e8 33 f3 ff ff       	call   c00297ee <list_begin>
c002a4bb:	83 c4 10             	add    $0x10,%esp
c002a4be:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002a4c1:	83 ec 0c             	sub    $0xc,%esp
c002a4c4:	ff 75 08             	pushl  0x8(%ebp)
c002a4c7:	e8 9e f3 ff ff       	call   c002986a <list_end>
c002a4cc:	83 c4 10             	add    $0x10,%esp
c002a4cf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a4d2:	74 55                	je     c002a529 <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a4d4:	83 ec 0c             	sub    $0xc,%esp
c002a4d7:	ff 75 f4             	pushl  -0xc(%ebp)
c002a4da:	e8 41 f3 ff ff       	call   c0029820 <list_next>
c002a4df:	83 c4 10             	add    $0x10,%esp
c002a4e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a4e5:	eb 2f                	jmp    c002a516 <list_min+0x6c>
        if (less (e, min, aux))
c002a4e7:	83 ec 04             	sub    $0x4,%esp
c002a4ea:	ff 75 10             	pushl  0x10(%ebp)
c002a4ed:	ff 75 f4             	pushl  -0xc(%ebp)
c002a4f0:	ff 75 f0             	pushl  -0x10(%ebp)
c002a4f3:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a4f6:	ff d0                	call   *%eax
c002a4f8:	83 c4 10             	add    $0x10,%esp
c002a4fb:	84 c0                	test   %al,%al
c002a4fd:	74 06                	je     c002a505 <list_min+0x5b>
          min = e; 
c002a4ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002a502:	89 45 f4             	mov    %eax,-0xc(%ebp)
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002a505:	83 ec 0c             	sub    $0xc,%esp
c002a508:	ff 75 f0             	pushl  -0x10(%ebp)
c002a50b:	e8 10 f3 ff ff       	call   c0029820 <list_next>
c002a510:	83 c4 10             	add    $0x10,%esp
c002a513:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a516:	83 ec 0c             	sub    $0xc,%esp
c002a519:	ff 75 08             	pushl  0x8(%ebp)
c002a51c:	e8 49 f3 ff ff       	call   c002986a <list_end>
c002a521:	83 c4 10             	add    $0x10,%esp
c002a524:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a527:	75 be                	jne    c002a4e7 <list_min+0x3d>
    }
  return min;
c002a529:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a52c:	c9                   	leave  
c002a52d:	c3                   	ret    

c002a52e <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002a52e:	55                   	push   %ebp
c002a52f:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002a531:	8b 45 08             	mov    0x8(%ebp),%eax
c002a534:	c1 e8 05             	shr    $0x5,%eax
}
c002a537:	5d                   	pop    %ebp
c002a538:	c3                   	ret    

c002a539 <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002a539:	55                   	push   %ebp
c002a53a:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002a53c:	8b 45 08             	mov    0x8(%ebp),%eax
c002a53f:	83 e0 1f             	and    $0x1f,%eax
c002a542:	ba 01 00 00 00       	mov    $0x1,%edx
c002a547:	88 c1                	mov    %al,%cl
c002a549:	d3 e2                	shl    %cl,%edx
c002a54b:	89 d0                	mov    %edx,%eax
}
c002a54d:	5d                   	pop    %ebp
c002a54e:	c3                   	ret    

c002a54f <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002a54f:	55                   	push   %ebp
c002a550:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002a552:	8b 45 08             	mov    0x8(%ebp),%eax
c002a555:	83 c0 1f             	add    $0x1f,%eax
c002a558:	c1 e8 05             	shr    $0x5,%eax
}
c002a55b:	5d                   	pop    %ebp
c002a55c:	c3                   	ret    

c002a55d <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002a55d:	55                   	push   %ebp
c002a55e:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002a560:	ff 75 08             	pushl  0x8(%ebp)
c002a563:	e8 e7 ff ff ff       	call   c002a54f <elem_cnt>
c002a568:	83 c4 04             	add    $0x4,%esp
c002a56b:	c1 e0 02             	shl    $0x2,%eax
}
c002a56e:	c9                   	leave  
c002a56f:	c3                   	ret    

c002a570 <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002a570:	55                   	push   %ebp
c002a571:	89 e5                	mov    %esp,%ebp
c002a573:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002a576:	83 ec 0c             	sub    $0xc,%esp
c002a579:	6a 08                	push   $0x8
c002a57b:	e8 db 8e ff ff       	call   c002345b <malloc>
c002a580:	83 c4 10             	add    $0x10,%esp
c002a583:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002a586:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002a58a:	74 5d                	je     c002a5e9 <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002a58c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a58f:	8b 55 08             	mov    0x8(%ebp),%edx
c002a592:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002a594:	83 ec 0c             	sub    $0xc,%esp
c002a597:	ff 75 08             	pushl  0x8(%ebp)
c002a59a:	e8 be ff ff ff       	call   c002a55d <byte_cnt>
c002a59f:	83 c4 10             	add    $0x10,%esp
c002a5a2:	83 ec 0c             	sub    $0xc,%esp
c002a5a5:	50                   	push   %eax
c002a5a6:	e8 b0 8e ff ff       	call   c002345b <malloc>
c002a5ab:	83 c4 10             	add    $0x10,%esp
c002a5ae:	89 c2                	mov    %eax,%edx
c002a5b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5b3:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002a5b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5b9:	8b 40 04             	mov    0x4(%eax),%eax
c002a5bc:	85 c0                	test   %eax,%eax
c002a5be:	75 06                	jne    c002a5c6 <bitmap_create+0x56>
c002a5c0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a5c4:	75 15                	jne    c002a5db <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002a5c6:	83 ec 08             	sub    $0x8,%esp
c002a5c9:	6a 00                	push   $0x0
c002a5cb:	ff 75 f4             	pushl  -0xc(%ebp)
c002a5ce:	e8 92 02 00 00       	call   c002a865 <bitmap_set_all>
c002a5d3:	83 c4 10             	add    $0x10,%esp
          return b;
c002a5d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a5d9:	eb 13                	jmp    c002a5ee <bitmap_create+0x7e>
        }
      free (b);
c002a5db:	83 ec 0c             	sub    $0xc,%esp
c002a5de:	ff 75 f4             	pushl  -0xc(%ebp)
c002a5e1:	e8 6f 91 ff ff       	call   c0023755 <free>
c002a5e6:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002a5e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002a5ee:	c9                   	leave  
c002a5ef:	c3                   	ret    

c002a5f0 <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002a5f0:	55                   	push   %ebp
c002a5f1:	89 e5                	mov    %esp,%ebp
c002a5f3:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002a5f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a5f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002a5fc:	83 ec 0c             	sub    $0xc,%esp
c002a5ff:	ff 75 08             	pushl  0x8(%ebp)
c002a602:	e8 4f 00 00 00       	call   c002a656 <bitmap_buf_size>
c002a607:	83 c4 10             	add    $0x10,%esp
c002a60a:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a60d:	76 1e                	jbe    c002a62d <bitmap_create_in_buf+0x3d>
c002a60f:	83 ec 0c             	sub    $0xc,%esp
c002a612:	68 24 0f 03 c0       	push   $0xc0030f24
c002a617:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a61c:	68 c8 0f 03 c0       	push   $0xc0030fc8
c002a621:	6a 68                	push   $0x68
c002a623:	68 63 0f 03 c0       	push   $0xc0030f63
c002a628:	e8 fb ee ff ff       	call   c0029528 <debug_panic>

  b->bit_cnt = bit_cnt;
c002a62d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a630:	8b 55 08             	mov    0x8(%ebp),%edx
c002a633:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002a635:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a638:	8d 50 08             	lea    0x8(%eax),%edx
c002a63b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a63e:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002a641:	83 ec 08             	sub    $0x8,%esp
c002a644:	6a 00                	push   $0x0
c002a646:	ff 75 f4             	pushl  -0xc(%ebp)
c002a649:	e8 17 02 00 00       	call   c002a865 <bitmap_set_all>
c002a64e:	83 c4 10             	add    $0x10,%esp
  return b;
c002a651:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a654:	c9                   	leave  
c002a655:	c3                   	ret    

c002a656 <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002a656:	55                   	push   %ebp
c002a657:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002a659:	ff 75 08             	pushl  0x8(%ebp)
c002a65c:	e8 fc fe ff ff       	call   c002a55d <byte_cnt>
c002a661:	83 c4 04             	add    $0x4,%esp
c002a664:	83 c0 08             	add    $0x8,%eax
}
c002a667:	c9                   	leave  
c002a668:	c3                   	ret    

c002a669 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002a669:	55                   	push   %ebp
c002a66a:	89 e5                	mov    %esp,%ebp
c002a66c:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002a66f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a673:	74 20                	je     c002a695 <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002a675:	8b 45 08             	mov    0x8(%ebp),%eax
c002a678:	8b 40 04             	mov    0x4(%eax),%eax
c002a67b:	83 ec 0c             	sub    $0xc,%esp
c002a67e:	50                   	push   %eax
c002a67f:	e8 d1 90 ff ff       	call   c0023755 <free>
c002a684:	83 c4 10             	add    $0x10,%esp
      free (b);
c002a687:	83 ec 0c             	sub    $0xc,%esp
c002a68a:	ff 75 08             	pushl  0x8(%ebp)
c002a68d:	e8 c3 90 ff ff       	call   c0023755 <free>
c002a692:	83 c4 10             	add    $0x10,%esp
    }
}
c002a695:	90                   	nop
c002a696:	c9                   	leave  
c002a697:	c3                   	ret    

c002a698 <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002a698:	55                   	push   %ebp
c002a699:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002a69b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a69e:	8b 00                	mov    (%eax),%eax
}
c002a6a0:	5d                   	pop    %ebp
c002a6a1:	c3                   	ret    

c002a6a2 <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002a6a2:	55                   	push   %ebp
c002a6a3:	89 e5                	mov    %esp,%ebp
c002a6a5:	83 ec 18             	sub    $0x18,%esp
c002a6a8:	8b 45 10             	mov    0x10(%ebp),%eax
c002a6ab:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a6ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a6b2:	75 21                	jne    c002a6d5 <bitmap_set+0x33>
c002a6b4:	83 ec 0c             	sub    $0xc,%esp
c002a6b7:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a6bc:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a6c1:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a6c6:	68 93 00 00 00       	push   $0x93
c002a6cb:	68 63 0f 03 c0       	push   $0xc0030f63
c002a6d0:	e8 53 ee ff ff       	call   c0029528 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a6d5:	8b 45 08             	mov    0x8(%ebp),%eax
c002a6d8:	8b 00                	mov    (%eax),%eax
c002a6da:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a6dd:	77 21                	ja     c002a700 <bitmap_set+0x5e>
c002a6df:	83 ec 0c             	sub    $0xc,%esp
c002a6e2:	68 87 0f 03 c0       	push   $0xc0030f87
c002a6e7:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a6ec:	68 e0 0f 03 c0       	push   $0xc0030fe0
c002a6f1:	68 94 00 00 00       	push   $0x94
c002a6f6:	68 63 0f 03 c0       	push   $0xc0030f63
c002a6fb:	e8 28 ee ff ff       	call   c0029528 <debug_panic>
  if (value)
c002a700:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002a704:	74 13                	je     c002a719 <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002a706:	83 ec 08             	sub    $0x8,%esp
c002a709:	ff 75 0c             	pushl  0xc(%ebp)
c002a70c:	ff 75 08             	pushl  0x8(%ebp)
c002a70f:	e8 19 00 00 00       	call   c002a72d <bitmap_mark>
c002a714:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002a717:	eb 11                	jmp    c002a72a <bitmap_set+0x88>
    bitmap_reset (b, idx);
c002a719:	83 ec 08             	sub    $0x8,%esp
c002a71c:	ff 75 0c             	pushl  0xc(%ebp)
c002a71f:	ff 75 08             	pushl  0x8(%ebp)
c002a722:	e8 3e 00 00 00       	call   c002a765 <bitmap_reset>
c002a727:	83 c4 10             	add    $0x10,%esp
}
c002a72a:	90                   	nop
c002a72b:	c9                   	leave  
c002a72c:	c3                   	ret    

c002a72d <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002a72d:	55                   	push   %ebp
c002a72e:	89 e5                	mov    %esp,%ebp
c002a730:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a733:	ff 75 0c             	pushl  0xc(%ebp)
c002a736:	e8 f3 fd ff ff       	call   c002a52e <elem_idx>
c002a73b:	83 c4 04             	add    $0x4,%esp
c002a73e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a741:	ff 75 0c             	pushl  0xc(%ebp)
c002a744:	e8 f0 fd ff ff       	call   c002a539 <bit_mask>
c002a749:	83 c4 04             	add    $0x4,%esp
c002a74c:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a74f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a752:	8b 40 04             	mov    0x4(%eax),%eax
c002a755:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a758:	c1 e2 02             	shl    $0x2,%edx
c002a75b:	01 c2                	add    %eax,%edx
c002a75d:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a760:	09 02                	or     %eax,(%edx)
}
c002a762:	90                   	nop
c002a763:	c9                   	leave  
c002a764:	c3                   	ret    

c002a765 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002a765:	55                   	push   %ebp
c002a766:	89 e5                	mov    %esp,%ebp
c002a768:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a76b:	ff 75 0c             	pushl  0xc(%ebp)
c002a76e:	e8 bb fd ff ff       	call   c002a52e <elem_idx>
c002a773:	83 c4 04             	add    $0x4,%esp
c002a776:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a779:	ff 75 0c             	pushl  0xc(%ebp)
c002a77c:	e8 b8 fd ff ff       	call   c002a539 <bit_mask>
c002a781:	83 c4 04             	add    $0x4,%esp
c002a784:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002a787:	8b 45 08             	mov    0x8(%ebp),%eax
c002a78a:	8b 40 04             	mov    0x4(%eax),%eax
c002a78d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a790:	c1 e2 02             	shl    $0x2,%edx
c002a793:	01 d0                	add    %edx,%eax
c002a795:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002a798:	f7 d2                	not    %edx
c002a79a:	21 10                	and    %edx,(%eax)
}
c002a79c:	90                   	nop
c002a79d:	c9                   	leave  
c002a79e:	c3                   	ret    

c002a79f <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002a79f:	55                   	push   %ebp
c002a7a0:	89 e5                	mov    %esp,%ebp
c002a7a2:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002a7a5:	ff 75 0c             	pushl  0xc(%ebp)
c002a7a8:	e8 81 fd ff ff       	call   c002a52e <elem_idx>
c002a7ad:	83 c4 04             	add    $0x4,%esp
c002a7b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002a7b3:	ff 75 0c             	pushl  0xc(%ebp)
c002a7b6:	e8 7e fd ff ff       	call   c002a539 <bit_mask>
c002a7bb:	83 c4 04             	add    $0x4,%esp
c002a7be:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002a7c1:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7c4:	8b 40 04             	mov    0x4(%eax),%eax
c002a7c7:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a7ca:	c1 e2 02             	shl    $0x2,%edx
c002a7cd:	01 c2                	add    %eax,%edx
c002a7cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002a7d2:	31 02                	xor    %eax,(%edx)
}
c002a7d4:	90                   	nop
c002a7d5:	c9                   	leave  
c002a7d6:	c3                   	ret    

c002a7d7 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002a7d7:	55                   	push   %ebp
c002a7d8:	89 e5                	mov    %esp,%ebp
c002a7da:	53                   	push   %ebx
c002a7db:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002a7de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a7e2:	75 21                	jne    c002a805 <bitmap_test+0x2e>
c002a7e4:	83 ec 0c             	sub    $0xc,%esp
c002a7e7:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a7ec:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a7f1:	68 ec 0f 03 c0       	push   $0xc0030fec
c002a7f6:	68 c8 00 00 00       	push   $0xc8
c002a7fb:	68 63 0f 03 c0       	push   $0xc0030f63
c002a800:	e8 23 ed ff ff       	call   c0029528 <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002a805:	8b 45 08             	mov    0x8(%ebp),%eax
c002a808:	8b 00                	mov    (%eax),%eax
c002a80a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a80d:	77 21                	ja     c002a830 <bitmap_test+0x59>
c002a80f:	83 ec 0c             	sub    $0xc,%esp
c002a812:	68 87 0f 03 c0       	push   $0xc0030f87
c002a817:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a81c:	68 ec 0f 03 c0       	push   $0xc0030fec
c002a821:	68 c9 00 00 00       	push   $0xc9
c002a826:	68 63 0f 03 c0       	push   $0xc0030f63
c002a82b:	e8 f8 ec ff ff       	call   c0029528 <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002a830:	8b 45 08             	mov    0x8(%ebp),%eax
c002a833:	8b 58 04             	mov    0x4(%eax),%ebx
c002a836:	83 ec 0c             	sub    $0xc,%esp
c002a839:	ff 75 0c             	pushl  0xc(%ebp)
c002a83c:	e8 ed fc ff ff       	call   c002a52e <elem_idx>
c002a841:	83 c4 10             	add    $0x10,%esp
c002a844:	c1 e0 02             	shl    $0x2,%eax
c002a847:	01 d8                	add    %ebx,%eax
c002a849:	8b 18                	mov    (%eax),%ebx
c002a84b:	83 ec 0c             	sub    $0xc,%esp
c002a84e:	ff 75 0c             	pushl  0xc(%ebp)
c002a851:	e8 e3 fc ff ff       	call   c002a539 <bit_mask>
c002a856:	83 c4 10             	add    $0x10,%esp
c002a859:	21 d8                	and    %ebx,%eax
c002a85b:	85 c0                	test   %eax,%eax
c002a85d:	0f 95 c0             	setne  %al
}
c002a860:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a863:	c9                   	leave  
c002a864:	c3                   	ret    

c002a865 <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002a865:	55                   	push   %ebp
c002a866:	89 e5                	mov    %esp,%ebp
c002a868:	53                   	push   %ebx
c002a869:	83 ec 14             	sub    $0x14,%esp
c002a86c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a86f:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002a872:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a876:	75 21                	jne    c002a899 <bitmap_set_all+0x34>
c002a878:	83 ec 0c             	sub    $0xc,%esp
c002a87b:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a880:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a885:	68 f8 0f 03 c0       	push   $0xc0030ff8
c002a88a:	68 d3 00 00 00       	push   $0xd3
c002a88f:	68 63 0f 03 c0       	push   $0xc0030f63
c002a894:	e8 8f ec ff ff       	call   c0029528 <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002a899:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002a89d:	83 ec 0c             	sub    $0xc,%esp
c002a8a0:	ff 75 08             	pushl  0x8(%ebp)
c002a8a3:	e8 f0 fd ff ff       	call   c002a698 <bitmap_size>
c002a8a8:	83 c4 10             	add    $0x10,%esp
c002a8ab:	53                   	push   %ebx
c002a8ac:	50                   	push   %eax
c002a8ad:	6a 00                	push   $0x0
c002a8af:	ff 75 08             	pushl  0x8(%ebp)
c002a8b2:	e8 09 00 00 00       	call   c002a8c0 <bitmap_set_multiple>
c002a8b7:	83 c4 10             	add    $0x10,%esp
}
c002a8ba:	90                   	nop
c002a8bb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a8be:	c9                   	leave  
c002a8bf:	c3                   	ret    

c002a8c0 <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a8c0:	55                   	push   %ebp
c002a8c1:	89 e5                	mov    %esp,%ebp
c002a8c3:	83 ec 28             	sub    $0x28,%esp
c002a8c6:	8b 45 14             	mov    0x14(%ebp),%eax
c002a8c9:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002a8cc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a8d0:	75 21                	jne    c002a8f3 <bitmap_set_multiple+0x33>
c002a8d2:	83 ec 0c             	sub    $0xc,%esp
c002a8d5:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a8da:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a8df:	68 08 10 03 c0       	push   $0xc0031008
c002a8e4:	68 de 00 00 00       	push   $0xde
c002a8e9:	68 63 0f 03 c0       	push   $0xc0030f63
c002a8ee:	e8 35 ec ff ff       	call   c0029528 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a8f3:	8b 45 08             	mov    0x8(%ebp),%eax
c002a8f6:	8b 00                	mov    (%eax),%eax
c002a8f8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a8fb:	73 21                	jae    c002a91e <bitmap_set_multiple+0x5e>
c002a8fd:	83 ec 0c             	sub    $0xc,%esp
c002a900:	68 98 0f 03 c0       	push   $0xc0030f98
c002a905:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a90a:	68 08 10 03 c0       	push   $0xc0031008
c002a90f:	68 df 00 00 00       	push   $0xdf
c002a914:	68 63 0f 03 c0       	push   $0xc0030f63
c002a919:	e8 0a ec ff ff       	call   c0029528 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a91e:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a921:	8b 45 10             	mov    0x10(%ebp),%eax
c002a924:	01 c2                	add    %eax,%edx
c002a926:	8b 45 08             	mov    0x8(%ebp),%eax
c002a929:	8b 00                	mov    (%eax),%eax
c002a92b:	39 c2                	cmp    %eax,%edx
c002a92d:	76 21                	jbe    c002a950 <bitmap_set_multiple+0x90>
c002a92f:	83 ec 0c             	sub    $0xc,%esp
c002a932:	68 ac 0f 03 c0       	push   $0xc0030fac
c002a937:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a93c:	68 08 10 03 c0       	push   $0xc0031008
c002a941:	68 e0 00 00 00       	push   $0xe0
c002a946:	68 63 0f 03 c0       	push   $0xc0030f63
c002a94b:	e8 d8 eb ff ff       	call   c0029528 <debug_panic>

  for (i = 0; i < cnt; i++)
c002a950:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002a957:	eb 1f                	jmp    c002a978 <bitmap_set_multiple+0xb8>
    bitmap_set (b, start + i, value);
c002a959:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002a95d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002a960:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002a963:	01 ca                	add    %ecx,%edx
c002a965:	83 ec 04             	sub    $0x4,%esp
c002a968:	50                   	push   %eax
c002a969:	52                   	push   %edx
c002a96a:	ff 75 08             	pushl  0x8(%ebp)
c002a96d:	e8 30 fd ff ff       	call   c002a6a2 <bitmap_set>
c002a972:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < cnt; i++)
c002a975:	ff 45 f4             	incl   -0xc(%ebp)
c002a978:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a97b:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a97e:	72 d9                	jb     c002a959 <bitmap_set_multiple+0x99>
}
c002a980:	90                   	nop
c002a981:	c9                   	leave  
c002a982:	c3                   	ret    

c002a983 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002a983:	55                   	push   %ebp
c002a984:	89 e5                	mov    %esp,%ebp
c002a986:	83 ec 28             	sub    $0x28,%esp
c002a989:	8b 45 14             	mov    0x14(%ebp),%eax
c002a98c:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002a98f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a993:	75 21                	jne    c002a9b6 <bitmap_count+0x33>
c002a995:	83 ec 0c             	sub    $0xc,%esp
c002a998:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002a99d:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a9a2:	68 1c 10 03 c0       	push   $0xc003101c
c002a9a7:	68 ed 00 00 00       	push   $0xed
c002a9ac:	68 63 0f 03 c0       	push   $0xc0030f63
c002a9b1:	e8 72 eb ff ff       	call   c0029528 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002a9b6:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9b9:	8b 00                	mov    (%eax),%eax
c002a9bb:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a9be:	73 21                	jae    c002a9e1 <bitmap_count+0x5e>
c002a9c0:	83 ec 0c             	sub    $0xc,%esp
c002a9c3:	68 98 0f 03 c0       	push   $0xc0030f98
c002a9c8:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a9cd:	68 1c 10 03 c0       	push   $0xc003101c
c002a9d2:	68 ee 00 00 00       	push   $0xee
c002a9d7:	68 63 0f 03 c0       	push   $0xc0030f63
c002a9dc:	e8 47 eb ff ff       	call   c0029528 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002a9e1:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a9e4:	8b 45 10             	mov    0x10(%ebp),%eax
c002a9e7:	01 c2                	add    %eax,%edx
c002a9e9:	8b 45 08             	mov    0x8(%ebp),%eax
c002a9ec:	8b 00                	mov    (%eax),%eax
c002a9ee:	39 c2                	cmp    %eax,%edx
c002a9f0:	76 21                	jbe    c002aa13 <bitmap_count+0x90>
c002a9f2:	83 ec 0c             	sub    $0xc,%esp
c002a9f5:	68 ac 0f 03 c0       	push   $0xc0030fac
c002a9fa:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002a9ff:	68 1c 10 03 c0       	push   $0xc003101c
c002aa04:	68 ef 00 00 00       	push   $0xef
c002aa09:	68 63 0f 03 c0       	push   $0xc0030f63
c002aa0e:	e8 15 eb ff ff       	call   c0029528 <debug_panic>

  value_cnt = 0;
c002aa13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002aa1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002aa21:	eb 22                	jmp    c002aa45 <bitmap_count+0xc2>
    if (bitmap_test (b, start + i) == value)
c002aa23:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aa26:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aa29:	01 d0                	add    %edx,%eax
c002aa2b:	83 ec 08             	sub    $0x8,%esp
c002aa2e:	50                   	push   %eax
c002aa2f:	ff 75 08             	pushl  0x8(%ebp)
c002aa32:	e8 a0 fd ff ff       	call   c002a7d7 <bitmap_test>
c002aa37:	83 c4 10             	add    $0x10,%esp
c002aa3a:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002aa3d:	75 03                	jne    c002aa42 <bitmap_count+0xbf>
      value_cnt++;
c002aa3f:	ff 45 f0             	incl   -0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002aa42:	ff 45 f4             	incl   -0xc(%ebp)
c002aa45:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aa48:	3b 45 10             	cmp    0x10(%ebp),%eax
c002aa4b:	72 d6                	jb     c002aa23 <bitmap_count+0xa0>
  return value_cnt;
c002aa4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002aa50:	c9                   	leave  
c002aa51:	c3                   	ret    

c002aa52 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002aa52:	55                   	push   %ebp
c002aa53:	89 e5                	mov    %esp,%ebp
c002aa55:	83 ec 28             	sub    $0x28,%esp
c002aa58:	8b 45 14             	mov    0x14(%ebp),%eax
c002aa5b:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002aa5e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aa62:	75 21                	jne    c002aa85 <bitmap_contains+0x33>
c002aa64:	83 ec 0c             	sub    $0xc,%esp
c002aa67:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002aa6c:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002aa71:	68 2c 10 03 c0       	push   $0xc003102c
c002aa76:	68 ff 00 00 00       	push   $0xff
c002aa7b:	68 63 0f 03 c0       	push   $0xc0030f63
c002aa80:	e8 a3 ea ff ff       	call   c0029528 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002aa85:	8b 45 08             	mov    0x8(%ebp),%eax
c002aa88:	8b 00                	mov    (%eax),%eax
c002aa8a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aa8d:	73 21                	jae    c002aab0 <bitmap_contains+0x5e>
c002aa8f:	83 ec 0c             	sub    $0xc,%esp
c002aa92:	68 98 0f 03 c0       	push   $0xc0030f98
c002aa97:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002aa9c:	68 2c 10 03 c0       	push   $0xc003102c
c002aaa1:	68 00 01 00 00       	push   $0x100
c002aaa6:	68 63 0f 03 c0       	push   $0xc0030f63
c002aaab:	e8 78 ea ff ff       	call   c0029528 <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002aab0:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aab3:	8b 45 10             	mov    0x10(%ebp),%eax
c002aab6:	01 c2                	add    %eax,%edx
c002aab8:	8b 45 08             	mov    0x8(%ebp),%eax
c002aabb:	8b 00                	mov    (%eax),%eax
c002aabd:	39 c2                	cmp    %eax,%edx
c002aabf:	76 21                	jbe    c002aae2 <bitmap_contains+0x90>
c002aac1:	83 ec 0c             	sub    $0xc,%esp
c002aac4:	68 ac 0f 03 c0       	push   $0xc0030fac
c002aac9:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002aace:	68 2c 10 03 c0       	push   $0xc003102c
c002aad3:	68 01 01 00 00       	push   $0x101
c002aad8:	68 63 0f 03 c0       	push   $0xc0030f63
c002aadd:	e8 46 ea ff ff       	call   c0029528 <debug_panic>

  for (i = 0; i < cnt; i++)
c002aae2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002aae9:	eb 23                	jmp    c002ab0e <bitmap_contains+0xbc>
    if (bitmap_test (b, start + i) == value)
c002aaeb:	8b 55 0c             	mov    0xc(%ebp),%edx
c002aaee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002aaf1:	01 d0                	add    %edx,%eax
c002aaf3:	83 ec 08             	sub    $0x8,%esp
c002aaf6:	50                   	push   %eax
c002aaf7:	ff 75 08             	pushl  0x8(%ebp)
c002aafa:	e8 d8 fc ff ff       	call   c002a7d7 <bitmap_test>
c002aaff:	83 c4 10             	add    $0x10,%esp
c002ab02:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002ab05:	75 04                	jne    c002ab0b <bitmap_contains+0xb9>
      return true;
c002ab07:	b0 01                	mov    $0x1,%al
c002ab09:	eb 0d                	jmp    c002ab18 <bitmap_contains+0xc6>
  for (i = 0; i < cnt; i++)
c002ab0b:	ff 45 f4             	incl   -0xc(%ebp)
c002ab0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ab11:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ab14:	72 d5                	jb     c002aaeb <bitmap_contains+0x99>
  return false;
c002ab16:	b0 00                	mov    $0x0,%al
}
c002ab18:	c9                   	leave  
c002ab19:	c3                   	ret    

c002ab1a <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ab1a:	55                   	push   %ebp
c002ab1b:	89 e5                	mov    %esp,%ebp
c002ab1d:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002ab20:	6a 01                	push   $0x1
c002ab22:	ff 75 10             	pushl  0x10(%ebp)
c002ab25:	ff 75 0c             	pushl  0xc(%ebp)
c002ab28:	ff 75 08             	pushl  0x8(%ebp)
c002ab2b:	e8 22 ff ff ff       	call   c002aa52 <bitmap_contains>
c002ab30:	83 c4 10             	add    $0x10,%esp
}
c002ab33:	c9                   	leave  
c002ab34:	c3                   	ret    

c002ab35 <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ab35:	55                   	push   %ebp
c002ab36:	89 e5                	mov    %esp,%ebp
c002ab38:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002ab3b:	6a 01                	push   $0x1
c002ab3d:	ff 75 10             	pushl  0x10(%ebp)
c002ab40:	ff 75 0c             	pushl  0xc(%ebp)
c002ab43:	ff 75 08             	pushl  0x8(%ebp)
c002ab46:	e8 07 ff ff ff       	call   c002aa52 <bitmap_contains>
c002ab4b:	83 c4 10             	add    $0x10,%esp
c002ab4e:	0f b6 c0             	movzbl %al,%eax
c002ab51:	85 c0                	test   %eax,%eax
c002ab53:	0f 95 c0             	setne  %al
c002ab56:	83 f0 01             	xor    $0x1,%eax
c002ab59:	0f b6 c0             	movzbl %al,%eax
c002ab5c:	83 e0 01             	and    $0x1,%eax
}
c002ab5f:	c9                   	leave  
c002ab60:	c3                   	ret    

c002ab61 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002ab61:	55                   	push   %ebp
c002ab62:	89 e5                	mov    %esp,%ebp
c002ab64:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002ab67:	6a 00                	push   $0x0
c002ab69:	ff 75 10             	pushl  0x10(%ebp)
c002ab6c:	ff 75 0c             	pushl  0xc(%ebp)
c002ab6f:	ff 75 08             	pushl  0x8(%ebp)
c002ab72:	e8 db fe ff ff       	call   c002aa52 <bitmap_contains>
c002ab77:	83 c4 10             	add    $0x10,%esp
c002ab7a:	0f b6 c0             	movzbl %al,%eax
c002ab7d:	85 c0                	test   %eax,%eax
c002ab7f:	0f 95 c0             	setne  %al
c002ab82:	83 f0 01             	xor    $0x1,%eax
c002ab85:	0f b6 c0             	movzbl %al,%eax
c002ab88:	83 e0 01             	and    $0x1,%eax
}
c002ab8b:	c9                   	leave  
c002ab8c:	c3                   	ret    

c002ab8d <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002ab8d:	55                   	push   %ebp
c002ab8e:	89 e5                	mov    %esp,%ebp
c002ab90:	83 ec 28             	sub    $0x28,%esp
c002ab93:	8b 45 14             	mov    0x14(%ebp),%eax
c002ab96:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002ab99:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ab9d:	75 21                	jne    c002abc0 <bitmap_scan+0x33>
c002ab9f:	83 ec 0c             	sub    $0xc,%esp
c002aba2:	68 7d 0f 03 c0       	push   $0xc0030f7d
c002aba7:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002abac:	68 3c 10 03 c0       	push   $0xc003103c
c002abb1:	68 2a 01 00 00       	push   $0x12a
c002abb6:	68 63 0f 03 c0       	push   $0xc0030f63
c002abbb:	e8 68 e9 ff ff       	call   c0029528 <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002abc0:	8b 45 08             	mov    0x8(%ebp),%eax
c002abc3:	8b 00                	mov    (%eax),%eax
c002abc5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002abc8:	73 21                	jae    c002abeb <bitmap_scan+0x5e>
c002abca:	83 ec 0c             	sub    $0xc,%esp
c002abcd:	68 98 0f 03 c0       	push   $0xc0030f98
c002abd2:	68 4c 0f 03 c0       	push   $0xc0030f4c
c002abd7:	68 3c 10 03 c0       	push   $0xc003103c
c002abdc:	68 2b 01 00 00       	push   $0x12b
c002abe1:	68 63 0f 03 c0       	push   $0xc0030f63
c002abe6:	e8 3d e9 ff ff       	call   c0029528 <debug_panic>

  if (cnt <= b->bit_cnt) 
c002abeb:	8b 45 08             	mov    0x8(%ebp),%eax
c002abee:	8b 00                	mov    (%eax),%eax
c002abf0:	3b 45 10             	cmp    0x10(%ebp),%eax
c002abf3:	72 51                	jb     c002ac46 <bitmap_scan+0xb9>
    {
      size_t last = b->bit_cnt - cnt;
c002abf5:	8b 45 08             	mov    0x8(%ebp),%eax
c002abf8:	8b 00                	mov    (%eax),%eax
c002abfa:	2b 45 10             	sub    0x10(%ebp),%eax
c002abfd:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002ac00:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ac03:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002ac06:	eb 36                	jmp    c002ac3e <bitmap_scan+0xb1>
        if (!bitmap_contains (b, i, cnt, !value))
c002ac08:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ac0c:	85 c0                	test   %eax,%eax
c002ac0e:	0f 95 c0             	setne  %al
c002ac11:	83 f0 01             	xor    $0x1,%eax
c002ac14:	0f b6 c0             	movzbl %al,%eax
c002ac17:	83 e0 01             	and    $0x1,%eax
c002ac1a:	0f b6 c0             	movzbl %al,%eax
c002ac1d:	50                   	push   %eax
c002ac1e:	ff 75 10             	pushl  0x10(%ebp)
c002ac21:	ff 75 f4             	pushl  -0xc(%ebp)
c002ac24:	ff 75 08             	pushl  0x8(%ebp)
c002ac27:	e8 26 fe ff ff       	call   c002aa52 <bitmap_contains>
c002ac2c:	83 c4 10             	add    $0x10,%esp
c002ac2f:	83 f0 01             	xor    $0x1,%eax
c002ac32:	84 c0                	test   %al,%al
c002ac34:	74 05                	je     c002ac3b <bitmap_scan+0xae>
          return i; 
c002ac36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac39:	eb 10                	jmp    c002ac4b <bitmap_scan+0xbe>
      for (i = start; i <= last; i++)
c002ac3b:	ff 45 f4             	incl   -0xc(%ebp)
c002ac3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac41:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002ac44:	76 c2                	jbe    c002ac08 <bitmap_scan+0x7b>
    }
  return BITMAP_ERROR;
c002ac46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002ac4b:	c9                   	leave  
c002ac4c:	c3                   	ret    

c002ac4d <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002ac4d:	55                   	push   %ebp
c002ac4e:	89 e5                	mov    %esp,%ebp
c002ac50:	83 ec 28             	sub    $0x28,%esp
c002ac53:	8b 45 14             	mov    0x14(%ebp),%eax
c002ac56:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002ac59:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ac5d:	50                   	push   %eax
c002ac5e:	ff 75 10             	pushl  0x10(%ebp)
c002ac61:	ff 75 0c             	pushl  0xc(%ebp)
c002ac64:	ff 75 08             	pushl  0x8(%ebp)
c002ac67:	e8 21 ff ff ff       	call   c002ab8d <bitmap_scan>
c002ac6c:	83 c4 10             	add    $0x10,%esp
c002ac6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002ac72:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002ac76:	74 27                	je     c002ac9f <bitmap_scan_and_flip+0x52>
    bitmap_set_multiple (b, idx, cnt, !value);
c002ac78:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002ac7c:	85 c0                	test   %eax,%eax
c002ac7e:	0f 95 c0             	setne  %al
c002ac81:	83 f0 01             	xor    $0x1,%eax
c002ac84:	0f b6 c0             	movzbl %al,%eax
c002ac87:	83 e0 01             	and    $0x1,%eax
c002ac8a:	0f b6 c0             	movzbl %al,%eax
c002ac8d:	50                   	push   %eax
c002ac8e:	ff 75 10             	pushl  0x10(%ebp)
c002ac91:	ff 75 f4             	pushl  -0xc(%ebp)
c002ac94:	ff 75 08             	pushl  0x8(%ebp)
c002ac97:	e8 24 fc ff ff       	call   c002a8c0 <bitmap_set_multiple>
c002ac9c:	83 c4 10             	add    $0x10,%esp
  return idx;
c002ac9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002aca2:	c9                   	leave  
c002aca3:	c3                   	ret    

c002aca4 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002aca4:	55                   	push   %ebp
c002aca5:	89 e5                	mov    %esp,%ebp
c002aca7:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002acaa:	8b 45 08             	mov    0x8(%ebp),%eax
c002acad:	8b 00                	mov    (%eax),%eax
c002acaf:	50                   	push   %eax
c002acb0:	e8 a8 f8 ff ff       	call   c002a55d <byte_cnt>
c002acb5:	83 c4 04             	add    $0x4,%esp
c002acb8:	89 c2                	mov    %eax,%edx
c002acba:	8b 45 08             	mov    0x8(%ebp),%eax
c002acbd:	8b 40 04             	mov    0x4(%eax),%eax
c002acc0:	6a 00                	push   $0x0
c002acc2:	52                   	push   %edx
c002acc3:	50                   	push   %eax
c002acc4:	6a 00                	push   $0x0
c002acc6:	e8 d5 cf ff ff       	call   c0027ca0 <hex_dump>
c002accb:	83 c4 10             	add    $0x10,%esp
}
c002acce:	90                   	nop
c002accf:	c9                   	leave  
c002acd0:	c3                   	ret    

c002acd1 <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002acd1:	55                   	push   %ebp
c002acd2:	89 e5                	mov    %esp,%ebp
c002acd4:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002acd7:	8b 45 08             	mov    0x8(%ebp),%eax
c002acda:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002ace0:	8b 45 08             	mov    0x8(%ebp),%eax
c002ace3:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002acea:	8b 45 08             	mov    0x8(%ebp),%eax
c002aced:	8b 40 04             	mov    0x4(%eax),%eax
c002acf0:	c1 e0 04             	shl    $0x4,%eax
c002acf3:	83 ec 0c             	sub    $0xc,%esp
c002acf6:	50                   	push   %eax
c002acf7:	e8 5f 87 ff ff       	call   c002345b <malloc>
c002acfc:	83 c4 10             	add    $0x10,%esp
c002acff:	89 c2                	mov    %eax,%edx
c002ad01:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad04:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002ad07:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad0a:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ad0d:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002ad10:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad13:	8b 55 10             	mov    0x10(%ebp),%edx
c002ad16:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002ad19:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad1c:	8b 55 14             	mov    0x14(%ebp),%edx
c002ad1f:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002ad22:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad25:	8b 40 08             	mov    0x8(%eax),%eax
c002ad28:	85 c0                	test   %eax,%eax
c002ad2a:	74 14                	je     c002ad40 <hash_init+0x6f>
    {
      hash_clear (h, NULL);
c002ad2c:	83 ec 08             	sub    $0x8,%esp
c002ad2f:	6a 00                	push   $0x0
c002ad31:	ff 75 08             	pushl  0x8(%ebp)
c002ad34:	e8 0b 00 00 00       	call   c002ad44 <hash_clear>
c002ad39:	83 c4 10             	add    $0x10,%esp
      return true;
c002ad3c:	b0 01                	mov    $0x1,%al
c002ad3e:	eb 02                	jmp    c002ad42 <hash_init+0x71>
    }
  else
    return false;
c002ad40:	b0 00                	mov    $0x0,%al
}
c002ad42:	c9                   	leave  
c002ad43:	c3                   	ret    

c002ad44 <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002ad44:	55                   	push   %ebp
c002ad45:	89 e5                	mov    %esp,%ebp
c002ad47:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002ad4a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002ad51:	eb 71                	jmp    c002adc4 <hash_clear+0x80>
    {
      struct list *bucket = &h->buckets[i];
c002ad53:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad56:	8b 40 08             	mov    0x8(%eax),%eax
c002ad59:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002ad5c:	c1 e2 04             	shl    $0x4,%edx
c002ad5f:	01 d0                	add    %edx,%eax
c002ad61:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002ad64:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ad68:	74 49                	je     c002adb3 <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002ad6a:	eb 32                	jmp    c002ad9e <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002ad6c:	83 ec 0c             	sub    $0xc,%esp
c002ad6f:	ff 75 f0             	pushl  -0x10(%ebp)
c002ad72:	e8 81 ee ff ff       	call   c0029bf8 <list_pop_front>
c002ad77:	83 c4 10             	add    $0x10,%esp
c002ad7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002ad7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002ad80:	83 c0 04             	add    $0x4,%eax
c002ad83:	83 e8 04             	sub    $0x4,%eax
c002ad86:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002ad89:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad8c:	8b 40 14             	mov    0x14(%eax),%eax
c002ad8f:	83 ec 08             	sub    $0x8,%esp
c002ad92:	50                   	push   %eax
c002ad93:	ff 75 e8             	pushl  -0x18(%ebp)
c002ad96:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ad99:	ff d0                	call   *%eax
c002ad9b:	83 c4 10             	add    $0x10,%esp
        while (!list_empty (bucket)) 
c002ad9e:	83 ec 0c             	sub    $0xc,%esp
c002ada1:	ff 75 f0             	pushl  -0x10(%ebp)
c002ada4:	e8 77 ef ff ff       	call   c0029d20 <list_empty>
c002ada9:	83 c4 10             	add    $0x10,%esp
c002adac:	83 f0 01             	xor    $0x1,%eax
c002adaf:	84 c0                	test   %al,%al
c002adb1:	75 b9                	jne    c002ad6c <hash_clear+0x28>
          }

      list_init (bucket); 
c002adb3:	83 ec 0c             	sub    $0xc,%esp
c002adb6:	ff 75 f0             	pushl  -0x10(%ebp)
c002adb9:	e8 db e9 ff ff       	call   c0029799 <list_init>
c002adbe:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
c002adc1:	ff 45 f4             	incl   -0xc(%ebp)
c002adc4:	8b 45 08             	mov    0x8(%ebp),%eax
c002adc7:	8b 40 04             	mov    0x4(%eax),%eax
c002adca:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002adcd:	77 84                	ja     c002ad53 <hash_clear+0xf>
    }    

  h->elem_cnt = 0;
c002adcf:	8b 45 08             	mov    0x8(%ebp),%eax
c002add2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002add8:	90                   	nop
c002add9:	c9                   	leave  
c002adda:	c3                   	ret    

c002addb <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002addb:	55                   	push   %ebp
c002addc:	89 e5                	mov    %esp,%ebp
c002adde:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002ade1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002ade5:	74 11                	je     c002adf8 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002ade7:	83 ec 08             	sub    $0x8,%esp
c002adea:	ff 75 0c             	pushl  0xc(%ebp)
c002aded:	ff 75 08             	pushl  0x8(%ebp)
c002adf0:	e8 4f ff ff ff       	call   c002ad44 <hash_clear>
c002adf5:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002adf8:	8b 45 08             	mov    0x8(%ebp),%eax
c002adfb:	8b 40 08             	mov    0x8(%eax),%eax
c002adfe:	83 ec 0c             	sub    $0xc,%esp
c002ae01:	50                   	push   %eax
c002ae02:	e8 4e 89 ff ff       	call   c0023755 <free>
c002ae07:	83 c4 10             	add    $0x10,%esp
}
c002ae0a:	90                   	nop
c002ae0b:	c9                   	leave  
c002ae0c:	c3                   	ret    

c002ae0d <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002ae0d:	55                   	push   %ebp
c002ae0e:	89 e5                	mov    %esp,%ebp
c002ae10:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002ae13:	83 ec 08             	sub    $0x8,%esp
c002ae16:	ff 75 0c             	pushl  0xc(%ebp)
c002ae19:	ff 75 08             	pushl  0x8(%ebp)
c002ae1c:	e8 7e 04 00 00       	call   c002b29f <find_bucket>
c002ae21:	83 c4 10             	add    $0x10,%esp
c002ae24:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002ae27:	83 ec 04             	sub    $0x4,%esp
c002ae2a:	ff 75 0c             	pushl  0xc(%ebp)
c002ae2d:	ff 75 f4             	pushl  -0xc(%ebp)
c002ae30:	ff 75 08             	pushl  0x8(%ebp)
c002ae33:	e8 a3 04 00 00       	call   c002b2db <find_elem>
c002ae38:	83 c4 10             	add    $0x10,%esp
c002ae3b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002ae3e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002ae42:	75 14                	jne    c002ae58 <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002ae44:	83 ec 04             	sub    $0x4,%esp
c002ae47:	ff 75 0c             	pushl  0xc(%ebp)
c002ae4a:	ff 75 f4             	pushl  -0xc(%ebp)
c002ae4d:	ff 75 08             	pushl  0x8(%ebp)
c002ae50:	e8 ee 06 00 00       	call   c002b543 <insert_elem>
c002ae55:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002ae58:	83 ec 0c             	sub    $0xc,%esp
c002ae5b:	ff 75 08             	pushl  0x8(%ebp)
c002ae5e:	e8 43 05 00 00       	call   c002b3a6 <rehash>
c002ae63:	83 c4 10             	add    $0x10,%esp

  return old; 
c002ae66:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002ae69:	c9                   	leave  
c002ae6a:	c3                   	ret    

c002ae6b <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002ae6b:	55                   	push   %ebp
c002ae6c:	89 e5                	mov    %esp,%ebp
c002ae6e:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002ae71:	83 ec 08             	sub    $0x8,%esp
c002ae74:	ff 75 0c             	pushl  0xc(%ebp)
c002ae77:	ff 75 08             	pushl  0x8(%ebp)
c002ae7a:	e8 20 04 00 00       	call   c002b29f <find_bucket>
c002ae7f:	83 c4 10             	add    $0x10,%esp
c002ae82:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002ae85:	83 ec 04             	sub    $0x4,%esp
c002ae88:	ff 75 0c             	pushl  0xc(%ebp)
c002ae8b:	ff 75 f4             	pushl  -0xc(%ebp)
c002ae8e:	ff 75 08             	pushl  0x8(%ebp)
c002ae91:	e8 45 04 00 00       	call   c002b2db <find_elem>
c002ae96:	83 c4 10             	add    $0x10,%esp
c002ae99:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002ae9c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002aea0:	74 11                	je     c002aeb3 <hash_replace+0x48>
    remove_elem (h, old);
c002aea2:	83 ec 08             	sub    $0x8,%esp
c002aea5:	ff 75 f0             	pushl  -0x10(%ebp)
c002aea8:	ff 75 08             	pushl  0x8(%ebp)
c002aeab:	e8 bb 06 00 00       	call   c002b56b <remove_elem>
c002aeb0:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002aeb3:	83 ec 04             	sub    $0x4,%esp
c002aeb6:	ff 75 0c             	pushl  0xc(%ebp)
c002aeb9:	ff 75 f4             	pushl  -0xc(%ebp)
c002aebc:	ff 75 08             	pushl  0x8(%ebp)
c002aebf:	e8 7f 06 00 00       	call   c002b543 <insert_elem>
c002aec4:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002aec7:	83 ec 0c             	sub    $0xc,%esp
c002aeca:	ff 75 08             	pushl  0x8(%ebp)
c002aecd:	e8 d4 04 00 00       	call   c002b3a6 <rehash>
c002aed2:	83 c4 10             	add    $0x10,%esp

  return old;
c002aed5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002aed8:	c9                   	leave  
c002aed9:	c3                   	ret    

c002aeda <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002aeda:	55                   	push   %ebp
c002aedb:	89 e5                	mov    %esp,%ebp
c002aedd:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002aee0:	83 ec 08             	sub    $0x8,%esp
c002aee3:	ff 75 0c             	pushl  0xc(%ebp)
c002aee6:	ff 75 08             	pushl  0x8(%ebp)
c002aee9:	e8 b1 03 00 00       	call   c002b29f <find_bucket>
c002aeee:	83 c4 10             	add    $0x10,%esp
c002aef1:	83 ec 04             	sub    $0x4,%esp
c002aef4:	ff 75 0c             	pushl  0xc(%ebp)
c002aef7:	50                   	push   %eax
c002aef8:	ff 75 08             	pushl  0x8(%ebp)
c002aefb:	e8 db 03 00 00       	call   c002b2db <find_elem>
c002af00:	83 c4 10             	add    $0x10,%esp
}
c002af03:	c9                   	leave  
c002af04:	c3                   	ret    

c002af05 <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002af05:	55                   	push   %ebp
c002af06:	89 e5                	mov    %esp,%ebp
c002af08:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002af0b:	83 ec 08             	sub    $0x8,%esp
c002af0e:	ff 75 0c             	pushl  0xc(%ebp)
c002af11:	ff 75 08             	pushl  0x8(%ebp)
c002af14:	e8 86 03 00 00       	call   c002b29f <find_bucket>
c002af19:	83 c4 10             	add    $0x10,%esp
c002af1c:	83 ec 04             	sub    $0x4,%esp
c002af1f:	ff 75 0c             	pushl  0xc(%ebp)
c002af22:	50                   	push   %eax
c002af23:	ff 75 08             	pushl  0x8(%ebp)
c002af26:	e8 b0 03 00 00       	call   c002b2db <find_elem>
c002af2b:	83 c4 10             	add    $0x10,%esp
c002af2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002af31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002af35:	74 1f                	je     c002af56 <hash_delete+0x51>
    {
      remove_elem (h, found);
c002af37:	83 ec 08             	sub    $0x8,%esp
c002af3a:	ff 75 f4             	pushl  -0xc(%ebp)
c002af3d:	ff 75 08             	pushl  0x8(%ebp)
c002af40:	e8 26 06 00 00       	call   c002b56b <remove_elem>
c002af45:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002af48:	83 ec 0c             	sub    $0xc,%esp
c002af4b:	ff 75 08             	pushl  0x8(%ebp)
c002af4e:	e8 53 04 00 00       	call   c002b3a6 <rehash>
c002af53:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002af56:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002af59:	c9                   	leave  
c002af5a:	c3                   	ret    

c002af5b <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002af5b:	55                   	push   %ebp
c002af5c:	89 e5                	mov    %esp,%ebp
c002af5e:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002af61:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002af65:	75 21                	jne    c002af88 <hash_apply+0x2d>
c002af67:	83 ec 0c             	sub    $0xc,%esp
c002af6a:	68 48 10 03 c0       	push   $0xc0031048
c002af6f:	68 57 10 03 c0       	push   $0xc0031057
c002af74:	68 b0 10 03 c0       	push   $0xc00310b0
c002af79:	68 a7 00 00 00       	push   $0xa7
c002af7e:	68 6e 10 03 c0       	push   $0xc003106e
c002af83:	e8 a0 e5 ff ff       	call   c0029528 <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002af88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002af8f:	eb 6d                	jmp    c002affe <hash_apply+0xa3>
    {
      struct list *bucket = &h->buckets[i];
c002af91:	8b 45 08             	mov    0x8(%ebp),%eax
c002af94:	8b 40 08             	mov    0x8(%eax),%eax
c002af97:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002af9a:	c1 e2 04             	shl    $0x4,%edx
c002af9d:	01 d0                	add    %edx,%eax
c002af9f:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002afa2:	83 ec 0c             	sub    $0xc,%esp
c002afa5:	ff 75 ec             	pushl  -0x14(%ebp)
c002afa8:	e8 41 e8 ff ff       	call   c00297ee <list_begin>
c002afad:	83 c4 10             	add    $0x10,%esp
c002afb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002afb3:	eb 33                	jmp    c002afe8 <hash_apply+0x8d>
        {
          next = list_next (elem);
c002afb5:	83 ec 0c             	sub    $0xc,%esp
c002afb8:	ff 75 f0             	pushl  -0x10(%ebp)
c002afbb:	e8 60 e8 ff ff       	call   c0029820 <list_next>
c002afc0:	83 c4 10             	add    $0x10,%esp
c002afc3:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002afc6:	8b 45 08             	mov    0x8(%ebp),%eax
c002afc9:	8b 40 14             	mov    0x14(%eax),%eax
c002afcc:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002afcf:	83 c2 04             	add    $0x4,%edx
c002afd2:	83 ea 04             	sub    $0x4,%edx
c002afd5:	83 ec 08             	sub    $0x8,%esp
c002afd8:	50                   	push   %eax
c002afd9:	52                   	push   %edx
c002afda:	8b 45 0c             	mov    0xc(%ebp),%eax
c002afdd:	ff d0                	call   *%eax
c002afdf:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002afe2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002afe5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002afe8:	83 ec 0c             	sub    $0xc,%esp
c002afeb:	ff 75 ec             	pushl  -0x14(%ebp)
c002afee:	e8 77 e8 ff ff       	call   c002986a <list_end>
c002aff3:	83 c4 10             	add    $0x10,%esp
c002aff6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002aff9:	75 ba                	jne    c002afb5 <hash_apply+0x5a>
  for (i = 0; i < h->bucket_cnt; i++) 
c002affb:	ff 45 f4             	incl   -0xc(%ebp)
c002affe:	8b 45 08             	mov    0x8(%ebp),%eax
c002b001:	8b 40 04             	mov    0x4(%eax),%eax
c002b004:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b007:	77 88                	ja     c002af91 <hash_apply+0x36>
        }
    }
}
c002b009:	90                   	nop
c002b00a:	c9                   	leave  
c002b00b:	c3                   	ret    

c002b00c <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002b00c:	55                   	push   %ebp
c002b00d:	89 e5                	mov    %esp,%ebp
c002b00f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002b012:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b016:	75 21                	jne    c002b039 <hash_first+0x2d>
c002b018:	83 ec 0c             	sub    $0xc,%esp
c002b01b:	68 86 10 03 c0       	push   $0xc0031086
c002b020:	68 57 10 03 c0       	push   $0xc0031057
c002b025:	68 bc 10 03 c0       	push   $0xc00310bc
c002b02a:	68 ca 00 00 00       	push   $0xca
c002b02f:	68 6e 10 03 c0       	push   $0xc003106e
c002b034:	e8 ef e4 ff ff       	call   c0029528 <debug_panic>
  ASSERT (h != NULL);
c002b039:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b03d:	75 21                	jne    c002b060 <hash_first+0x54>
c002b03f:	83 ec 0c             	sub    $0xc,%esp
c002b042:	68 90 10 03 c0       	push   $0xc0031090
c002b047:	68 57 10 03 c0       	push   $0xc0031057
c002b04c:	68 bc 10 03 c0       	push   $0xc00310bc
c002b051:	68 cb 00 00 00       	push   $0xcb
c002b056:	68 6e 10 03 c0       	push   $0xc003106e
c002b05b:	e8 c8 e4 ff ff       	call   c0029528 <debug_panic>

  i->hash = h;
c002b060:	8b 45 08             	mov    0x8(%ebp),%eax
c002b063:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b066:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002b068:	8b 45 08             	mov    0x8(%ebp),%eax
c002b06b:	8b 00                	mov    (%eax),%eax
c002b06d:	8b 50 08             	mov    0x8(%eax),%edx
c002b070:	8b 45 08             	mov    0x8(%ebp),%eax
c002b073:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002b076:	8b 45 08             	mov    0x8(%ebp),%eax
c002b079:	8b 40 04             	mov    0x4(%eax),%eax
c002b07c:	83 ec 0c             	sub    $0xc,%esp
c002b07f:	50                   	push   %eax
c002b080:	e8 c4 e8 ff ff       	call   c0029949 <list_head>
c002b085:	83 c4 10             	add    $0x10,%esp
c002b088:	83 c0 04             	add    $0x4,%eax
c002b08b:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b08e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b091:	89 50 08             	mov    %edx,0x8(%eax)
}
c002b094:	90                   	nop
c002b095:	c9                   	leave  
c002b096:	c3                   	ret    

c002b097 <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002b097:	55                   	push   %ebp
c002b098:	89 e5                	mov    %esp,%ebp
c002b09a:	53                   	push   %ebx
c002b09b:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002b09e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b0a2:	75 21                	jne    c002b0c5 <hash_next+0x2e>
c002b0a4:	83 ec 0c             	sub    $0xc,%esp
c002b0a7:	68 86 10 03 c0       	push   $0xc0031086
c002b0ac:	68 57 10 03 c0       	push   $0xc0031057
c002b0b1:	68 c8 10 03 c0       	push   $0xc00310c8
c002b0b6:	68 dd 00 00 00       	push   $0xdd
c002b0bb:	68 6e 10 03 c0       	push   $0xc003106e
c002b0c0:	e8 63 e4 ff ff       	call   c0029528 <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002b0c5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0c8:	8b 40 08             	mov    0x8(%eax),%eax
c002b0cb:	83 ec 0c             	sub    $0xc,%esp
c002b0ce:	50                   	push   %eax
c002b0cf:	e8 4c e7 ff ff       	call   c0029820 <list_next>
c002b0d4:	83 c4 10             	add    $0x10,%esp
c002b0d7:	83 c0 04             	add    $0x4,%eax
c002b0da:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b0dd:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0e0:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b0e3:	eb 58                	jmp    c002b13d <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b0e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0e8:	8b 40 04             	mov    0x4(%eax),%eax
c002b0eb:	8d 50 10             	lea    0x10(%eax),%edx
c002b0ee:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0f1:	89 50 04             	mov    %edx,0x4(%eax)
c002b0f4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0f7:	8b 50 04             	mov    0x4(%eax),%edx
c002b0fa:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0fd:	8b 00                	mov    (%eax),%eax
c002b0ff:	8b 48 08             	mov    0x8(%eax),%ecx
c002b102:	8b 45 08             	mov    0x8(%ebp),%eax
c002b105:	8b 00                	mov    (%eax),%eax
c002b107:	8b 40 04             	mov    0x4(%eax),%eax
c002b10a:	c1 e0 04             	shl    $0x4,%eax
c002b10d:	01 c8                	add    %ecx,%eax
c002b10f:	39 c2                	cmp    %eax,%edx
c002b111:	72 0c                	jb     c002b11f <hash_next+0x88>
        {
          i->elem = NULL;
c002b113:	8b 45 08             	mov    0x8(%ebp),%eax
c002b116:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002b11d:	eb 40                	jmp    c002b15f <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002b11f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b122:	8b 40 04             	mov    0x4(%eax),%eax
c002b125:	83 ec 0c             	sub    $0xc,%esp
c002b128:	50                   	push   %eax
c002b129:	e8 c0 e6 ff ff       	call   c00297ee <list_begin>
c002b12e:	83 c4 10             	add    $0x10,%esp
c002b131:	83 c0 04             	add    $0x4,%eax
c002b134:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b137:	8b 45 08             	mov    0x8(%ebp),%eax
c002b13a:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b13d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b140:	8b 58 08             	mov    0x8(%eax),%ebx
c002b143:	8b 45 08             	mov    0x8(%ebp),%eax
c002b146:	8b 40 04             	mov    0x4(%eax),%eax
c002b149:	83 ec 0c             	sub    $0xc,%esp
c002b14c:	50                   	push   %eax
c002b14d:	e8 18 e7 ff ff       	call   c002986a <list_end>
c002b152:	83 c4 10             	add    $0x10,%esp
c002b155:	83 c0 04             	add    $0x4,%eax
c002b158:	83 e8 04             	sub    $0x4,%eax
c002b15b:	39 c3                	cmp    %eax,%ebx
c002b15d:	74 86                	je     c002b0e5 <hash_next+0x4e>
    }
  
  return i->elem;
c002b15f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b162:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b165:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b168:	c9                   	leave  
c002b169:	c3                   	ret    

c002b16a <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002b16a:	55                   	push   %ebp
c002b16b:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002b16d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b170:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b173:	5d                   	pop    %ebp
c002b174:	c3                   	ret    

c002b175 <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002b175:	55                   	push   %ebp
c002b176:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002b178:	8b 45 08             	mov    0x8(%ebp),%eax
c002b17b:	8b 00                	mov    (%eax),%eax
}
c002b17d:	5d                   	pop    %ebp
c002b17e:	c3                   	ret    

c002b17f <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002b17f:	55                   	push   %ebp
c002b180:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002b182:	8b 45 08             	mov    0x8(%ebp),%eax
c002b185:	8b 00                	mov    (%eax),%eax
c002b187:	85 c0                	test   %eax,%eax
c002b189:	0f 94 c0             	sete   %al
}
c002b18c:	5d                   	pop    %ebp
c002b18d:	c3                   	ret    

c002b18e <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002b18e:	55                   	push   %ebp
c002b18f:	89 e5                	mov    %esp,%ebp
c002b191:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002b194:	8b 45 08             	mov    0x8(%ebp),%eax
c002b197:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002b19a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b19e:	75 21                	jne    c002b1c1 <hash_bytes+0x33>
c002b1a0:	83 ec 0c             	sub    $0xc,%esp
c002b1a3:	68 9a 10 03 c0       	push   $0xc003109a
c002b1a8:	68 57 10 03 c0       	push   $0xc0031057
c002b1ad:	68 d4 10 03 c0       	push   $0xc00310d4
c002b1b2:	68 10 01 00 00       	push   $0x110
c002b1b7:	68 6e 10 03 c0       	push   $0xc003106e
c002b1bc:	e8 67 e3 ff ff       	call   c0029528 <debug_panic>

  hash = FNV_32_BASIS;
c002b1c1:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002b1c8:	eb 30                	jmp    c002b1fa <hash_bytes+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b1ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b1cd:	89 d0                	mov    %edx,%eax
c002b1cf:	c1 e0 10             	shl    $0x10,%eax
c002b1d2:	01 d0                	add    %edx,%eax
c002b1d4:	01 c0                	add    %eax,%eax
c002b1d6:	01 d0                	add    %edx,%eax
c002b1d8:	c1 e0 03             	shl    $0x3,%eax
c002b1db:	01 d0                	add    %edx,%eax
c002b1dd:	c1 e0 03             	shl    $0x3,%eax
c002b1e0:	01 d0                	add    %edx,%eax
c002b1e2:	01 c0                	add    %eax,%eax
c002b1e4:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b1e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b1ea:	8d 50 01             	lea    0x1(%eax),%edx
c002b1ed:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b1f0:	8a 00                	mov    (%eax),%al
c002b1f2:	0f b6 c0             	movzbl %al,%eax
c002b1f5:	31 c8                	xor    %ecx,%eax
c002b1f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (size-- > 0)
c002b1fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b1fd:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b200:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b203:	85 c0                	test   %eax,%eax
c002b205:	75 c3                	jne    c002b1ca <hash_bytes+0x3c>

  return hash;
c002b207:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002b20a:	c9                   	leave  
c002b20b:	c3                   	ret    

c002b20c <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002b20c:	55                   	push   %ebp
c002b20d:	89 e5                	mov    %esp,%ebp
c002b20f:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002b212:	8b 45 08             	mov    0x8(%ebp),%eax
c002b215:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002b218:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b21c:	75 21                	jne    c002b23f <hash_string+0x33>
c002b21e:	83 ec 0c             	sub    $0xc,%esp
c002b221:	68 a6 10 03 c0       	push   $0xc00310a6
c002b226:	68 57 10 03 c0       	push   $0xc0031057
c002b22b:	68 e0 10 03 c0       	push   $0xc00310e0
c002b230:	68 20 01 00 00       	push   $0x120
c002b235:	68 6e 10 03 c0       	push   $0xc003106e
c002b23a:	e8 e9 e2 ff ff       	call   c0029528 <debug_panic>

  hash = FNV_32_BASIS;
c002b23f:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002b246:	eb 30                	jmp    c002b278 <hash_string+0x6c>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b248:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b24b:	89 d0                	mov    %edx,%eax
c002b24d:	c1 e0 10             	shl    $0x10,%eax
c002b250:	01 d0                	add    %edx,%eax
c002b252:	01 c0                	add    %eax,%eax
c002b254:	01 d0                	add    %edx,%eax
c002b256:	c1 e0 03             	shl    $0x3,%eax
c002b259:	01 d0                	add    %edx,%eax
c002b25b:	c1 e0 03             	shl    $0x3,%eax
c002b25e:	01 d0                	add    %edx,%eax
c002b260:	01 c0                	add    %eax,%eax
c002b262:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
c002b265:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b268:	8d 50 01             	lea    0x1(%eax),%edx
c002b26b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b26e:	8a 00                	mov    (%eax),%al
c002b270:	0f b6 c0             	movzbl %al,%eax
c002b273:	31 c8                	xor    %ecx,%eax
c002b275:	89 45 f0             	mov    %eax,-0x10(%ebp)
  while (*s != '\0')
c002b278:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b27b:	8a 00                	mov    (%eax),%al
c002b27d:	84 c0                	test   %al,%al
c002b27f:	75 c7                	jne    c002b248 <hash_string+0x3c>

  return hash;
c002b281:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b284:	c9                   	leave  
c002b285:	c3                   	ret    

c002b286 <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002b286:	55                   	push   %ebp
c002b287:	89 e5                	mov    %esp,%ebp
c002b289:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002b28c:	83 ec 08             	sub    $0x8,%esp
c002b28f:	6a 04                	push   $0x4
c002b291:	8d 45 08             	lea    0x8(%ebp),%eax
c002b294:	50                   	push   %eax
c002b295:	e8 f4 fe ff ff       	call   c002b18e <hash_bytes>
c002b29a:	83 c4 10             	add    $0x10,%esp
}
c002b29d:	c9                   	leave  
c002b29e:	c3                   	ret    

c002b29f <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002b29f:	55                   	push   %ebp
c002b2a0:	89 e5                	mov    %esp,%ebp
c002b2a2:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002b2a5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2a8:	8b 40 0c             	mov    0xc(%eax),%eax
c002b2ab:	8b 55 08             	mov    0x8(%ebp),%edx
c002b2ae:	8b 52 14             	mov    0x14(%edx),%edx
c002b2b1:	83 ec 08             	sub    $0x8,%esp
c002b2b4:	52                   	push   %edx
c002b2b5:	ff 75 0c             	pushl  0xc(%ebp)
c002b2b8:	ff d0                	call   *%eax
c002b2ba:	83 c4 10             	add    $0x10,%esp
c002b2bd:	89 c2                	mov    %eax,%edx
c002b2bf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2c2:	8b 40 04             	mov    0x4(%eax),%eax
c002b2c5:	48                   	dec    %eax
c002b2c6:	21 d0                	and    %edx,%eax
c002b2c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002b2cb:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2ce:	8b 40 08             	mov    0x8(%eax),%eax
c002b2d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b2d4:	c1 e2 04             	shl    $0x4,%edx
c002b2d7:	01 d0                	add    %edx,%eax
}
c002b2d9:	c9                   	leave  
c002b2da:	c3                   	ret    

c002b2db <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b2db:	55                   	push   %ebp
c002b2dc:	89 e5                	mov    %esp,%ebp
c002b2de:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b2e1:	83 ec 0c             	sub    $0xc,%esp
c002b2e4:	ff 75 0c             	pushl  0xc(%ebp)
c002b2e7:	e8 02 e5 ff ff       	call   c00297ee <list_begin>
c002b2ec:	83 c4 10             	add    $0x10,%esp
c002b2ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b2f2:	eb 66                	jmp    c002b35a <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002b2f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b2f7:	83 c0 04             	add    $0x4,%eax
c002b2fa:	83 e8 04             	sub    $0x4,%eax
c002b2fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002b300:	8b 45 08             	mov    0x8(%ebp),%eax
c002b303:	8b 40 10             	mov    0x10(%eax),%eax
c002b306:	8b 55 08             	mov    0x8(%ebp),%edx
c002b309:	8b 52 14             	mov    0x14(%edx),%edx
c002b30c:	83 ec 04             	sub    $0x4,%esp
c002b30f:	52                   	push   %edx
c002b310:	ff 75 10             	pushl  0x10(%ebp)
c002b313:	ff 75 f0             	pushl  -0x10(%ebp)
c002b316:	ff d0                	call   *%eax
c002b318:	83 c4 10             	add    $0x10,%esp
c002b31b:	83 f0 01             	xor    $0x1,%eax
c002b31e:	84 c0                	test   %al,%al
c002b320:	74 27                	je     c002b349 <find_elem+0x6e>
c002b322:	8b 45 08             	mov    0x8(%ebp),%eax
c002b325:	8b 40 10             	mov    0x10(%eax),%eax
c002b328:	8b 55 08             	mov    0x8(%ebp),%edx
c002b32b:	8b 52 14             	mov    0x14(%edx),%edx
c002b32e:	83 ec 04             	sub    $0x4,%esp
c002b331:	52                   	push   %edx
c002b332:	ff 75 f0             	pushl  -0x10(%ebp)
c002b335:	ff 75 10             	pushl  0x10(%ebp)
c002b338:	ff d0                	call   *%eax
c002b33a:	83 c4 10             	add    $0x10,%esp
c002b33d:	83 f0 01             	xor    $0x1,%eax
c002b340:	84 c0                	test   %al,%al
c002b342:	74 05                	je     c002b349 <find_elem+0x6e>
        return hi; 
c002b344:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b347:	eb 29                	jmp    c002b372 <find_elem+0x97>
  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b349:	83 ec 0c             	sub    $0xc,%esp
c002b34c:	ff 75 f4             	pushl  -0xc(%ebp)
c002b34f:	e8 cc e4 ff ff       	call   c0029820 <list_next>
c002b354:	83 c4 10             	add    $0x10,%esp
c002b357:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b35a:	83 ec 0c             	sub    $0xc,%esp
c002b35d:	ff 75 0c             	pushl  0xc(%ebp)
c002b360:	e8 05 e5 ff ff       	call   c002986a <list_end>
c002b365:	83 c4 10             	add    $0x10,%esp
c002b368:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b36b:	75 87                	jne    c002b2f4 <find_elem+0x19>
    }
  return NULL;
c002b36d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b372:	c9                   	leave  
c002b373:	c3                   	ret    

c002b374 <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002b374:	55                   	push   %ebp
c002b375:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002b377:	8b 45 08             	mov    0x8(%ebp),%eax
c002b37a:	48                   	dec    %eax
c002b37b:	23 45 08             	and    0x8(%ebp),%eax
}
c002b37e:	5d                   	pop    %ebp
c002b37f:	c3                   	ret    

c002b380 <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002b380:	55                   	push   %ebp
c002b381:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002b383:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b387:	74 16                	je     c002b39f <is_power_of_2+0x1f>
c002b389:	ff 75 08             	pushl  0x8(%ebp)
c002b38c:	e8 e3 ff ff ff       	call   c002b374 <turn_off_least_1bit>
c002b391:	83 c4 04             	add    $0x4,%esp
c002b394:	85 c0                	test   %eax,%eax
c002b396:	75 07                	jne    c002b39f <is_power_of_2+0x1f>
c002b398:	b8 01 00 00 00       	mov    $0x1,%eax
c002b39d:	eb 05                	jmp    c002b3a4 <is_power_of_2+0x24>
c002b39f:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b3a4:	c9                   	leave  
c002b3a5:	c3                   	ret    

c002b3a6 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002b3a6:	55                   	push   %ebp
c002b3a7:	89 e5                	mov    %esp,%ebp
c002b3a9:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002b3ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b3b0:	75 21                	jne    c002b3d3 <rehash+0x2d>
c002b3b2:	83 ec 0c             	sub    $0xc,%esp
c002b3b5:	68 90 10 03 c0       	push   $0xc0031090
c002b3ba:	68 57 10 03 c0       	push   $0xc0031057
c002b3bf:	68 ec 10 03 c0       	push   $0xc00310ec
c002b3c4:	68 66 01 00 00       	push   $0x166
c002b3c9:	68 6e 10 03 c0       	push   $0xc003106e
c002b3ce:	e8 55 e1 ff ff       	call   c0029528 <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002b3d3:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3d6:	8b 40 08             	mov    0x8(%eax),%eax
c002b3d9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002b3dc:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3df:	8b 40 04             	mov    0x4(%eax),%eax
c002b3e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002b3e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3e8:	8b 00                	mov    (%eax),%eax
c002b3ea:	d1 e8                	shr    %eax
c002b3ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002b3ef:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002b3f3:	77 1a                	ja     c002b40f <rehash+0x69>
    new_bucket_cnt = 4;
c002b3f5:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b3fc:	eb 11                	jmp    c002b40f <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002b3fe:	83 ec 0c             	sub    $0xc,%esp
c002b401:	ff 75 f4             	pushl  -0xc(%ebp)
c002b404:	e8 6b ff ff ff       	call   c002b374 <turn_off_least_1bit>
c002b409:	83 c4 10             	add    $0x10,%esp
c002b40c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002b40f:	83 ec 0c             	sub    $0xc,%esp
c002b412:	ff 75 f4             	pushl  -0xc(%ebp)
c002b415:	e8 66 ff ff ff       	call   c002b380 <is_power_of_2>
c002b41a:	83 c4 10             	add    $0x10,%esp
c002b41d:	85 c0                	test   %eax,%eax
c002b41f:	74 dd                	je     c002b3fe <rehash+0x58>

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002b421:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b424:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b427:	0f 84 10 01 00 00    	je     c002b53d <rehash+0x197>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002b42d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b430:	c1 e0 04             	shl    $0x4,%eax
c002b433:	83 ec 0c             	sub    $0xc,%esp
c002b436:	50                   	push   %eax
c002b437:	e8 1f 80 ff ff       	call   c002345b <malloc>
c002b43c:	83 c4 10             	add    $0x10,%esp
c002b43f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002b442:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002b446:	0f 84 f4 00 00 00    	je     c002b540 <rehash+0x19a>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002b44c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b453:	eb 1c                	jmp    c002b471 <rehash+0xcb>
    list_init (&new_buckets[i]);
c002b455:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b458:	c1 e0 04             	shl    $0x4,%eax
c002b45b:	89 c2                	mov    %eax,%edx
c002b45d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002b460:	01 d0                	add    %edx,%eax
c002b462:	83 ec 0c             	sub    $0xc,%esp
c002b465:	50                   	push   %eax
c002b466:	e8 2e e3 ff ff       	call   c0029799 <list_init>
c002b46b:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < new_bucket_cnt; i++) 
c002b46e:	ff 45 f0             	incl   -0x10(%ebp)
c002b471:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b474:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b477:	72 dc                	jb     c002b455 <rehash+0xaf>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002b479:	8b 45 08             	mov    0x8(%ebp),%eax
c002b47c:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002b47f:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002b482:	8b 45 08             	mov    0x8(%ebp),%eax
c002b485:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b488:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002b48b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002b492:	e9 8a 00 00 00       	jmp    c002b521 <rehash+0x17b>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002b497:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b49a:	c1 e0 04             	shl    $0x4,%eax
c002b49d:	89 c2                	mov    %eax,%edx
c002b49f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b4a2:	01 d0                	add    %edx,%eax
c002b4a4:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002b4a7:	83 ec 0c             	sub    $0xc,%esp
c002b4aa:	ff 75 dc             	pushl  -0x24(%ebp)
c002b4ad:	e8 3c e3 ff ff       	call   c00297ee <list_begin>
c002b4b2:	83 c4 10             	add    $0x10,%esp
c002b4b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b4b8:	eb 51                	jmp    c002b50b <rehash+0x165>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002b4ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b4bd:	83 c0 04             	add    $0x4,%eax
c002b4c0:	83 e8 04             	sub    $0x4,%eax
          struct list *new_bucket
c002b4c3:	83 ec 08             	sub    $0x8,%esp
c002b4c6:	50                   	push   %eax
c002b4c7:	ff 75 08             	pushl  0x8(%ebp)
c002b4ca:	e8 d0 fd ff ff       	call   c002b29f <find_bucket>
c002b4cf:	83 c4 10             	add    $0x10,%esp
c002b4d2:	89 45 d8             	mov    %eax,-0x28(%ebp)
          next = list_next (elem);
c002b4d5:	83 ec 0c             	sub    $0xc,%esp
c002b4d8:	ff 75 ec             	pushl  -0x14(%ebp)
c002b4db:	e8 40 e3 ff ff       	call   c0029820 <list_next>
c002b4e0:	83 c4 10             	add    $0x10,%esp
c002b4e3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002b4e6:	83 ec 0c             	sub    $0xc,%esp
c002b4e9:	ff 75 ec             	pushl  -0x14(%ebp)
c002b4ec:	e8 ae e6 ff ff       	call   c0029b9f <list_remove>
c002b4f1:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002b4f4:	83 ec 08             	sub    $0x8,%esp
c002b4f7:	ff 75 ec             	pushl  -0x14(%ebp)
c002b4fa:	ff 75 d8             	pushl  -0x28(%ebp)
c002b4fd:	e8 51 e6 ff ff       	call   c0029b53 <list_push_front>
c002b502:	83 c4 10             	add    $0x10,%esp
           elem != list_end (old_bucket); elem = next) 
c002b505:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002b508:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002b50b:	83 ec 0c             	sub    $0xc,%esp
c002b50e:	ff 75 dc             	pushl  -0x24(%ebp)
c002b511:	e8 54 e3 ff ff       	call   c002986a <list_end>
c002b516:	83 c4 10             	add    $0x10,%esp
      for (elem = list_begin (old_bucket);
c002b519:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002b51c:	75 9c                	jne    c002b4ba <rehash+0x114>
  for (i = 0; i < old_bucket_cnt; i++) 
c002b51e:	ff 45 f0             	incl   -0x10(%ebp)
c002b521:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b524:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002b527:	0f 82 6a ff ff ff    	jb     c002b497 <rehash+0xf1>
        }
    }

  free (old_buckets);
c002b52d:	83 ec 0c             	sub    $0xc,%esp
c002b530:	ff 75 e8             	pushl  -0x18(%ebp)
c002b533:	e8 1d 82 ff ff       	call   c0023755 <free>
c002b538:	83 c4 10             	add    $0x10,%esp
c002b53b:	eb 04                	jmp    c002b541 <rehash+0x19b>
    return;
c002b53d:	90                   	nop
c002b53e:	eb 01                	jmp    c002b541 <rehash+0x19b>
      return;
c002b540:	90                   	nop
}
c002b541:	c9                   	leave  
c002b542:	c3                   	ret    

c002b543 <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b543:	55                   	push   %ebp
c002b544:	89 e5                	mov    %esp,%ebp
c002b546:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002b549:	8b 45 08             	mov    0x8(%ebp),%eax
c002b54c:	8b 00                	mov    (%eax),%eax
c002b54e:	8d 50 01             	lea    0x1(%eax),%edx
c002b551:	8b 45 08             	mov    0x8(%ebp),%eax
c002b554:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002b556:	8b 45 10             	mov    0x10(%ebp),%eax
c002b559:	83 ec 08             	sub    $0x8,%esp
c002b55c:	50                   	push   %eax
c002b55d:	ff 75 0c             	pushl  0xc(%ebp)
c002b560:	e8 ee e5 ff ff       	call   c0029b53 <list_push_front>
c002b565:	83 c4 10             	add    $0x10,%esp
}
c002b568:	90                   	nop
c002b569:	c9                   	leave  
c002b56a:	c3                   	ret    

c002b56b <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002b56b:	55                   	push   %ebp
c002b56c:	89 e5                	mov    %esp,%ebp
c002b56e:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002b571:	8b 45 08             	mov    0x8(%ebp),%eax
c002b574:	8b 00                	mov    (%eax),%eax
c002b576:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b579:	8b 45 08             	mov    0x8(%ebp),%eax
c002b57c:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002b57e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b581:	83 ec 0c             	sub    $0xc,%esp
c002b584:	50                   	push   %eax
c002b585:	e8 15 e6 ff ff       	call   c0029b9f <list_remove>
c002b58a:	83 c4 10             	add    $0x10,%esp
}
c002b58d:	90                   	nop
c002b58e:	c9                   	leave  
c002b58f:	c3                   	ret    

c002b590 <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002b590:	55                   	push   %ebp
c002b591:	89 e5                	mov    %esp,%ebp
c002b593:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002b596:	83 ec 0c             	sub    $0xc,%esp
c002b599:	68 e8 8b 03 c0       	push   $0xc0038be8
c002b59e:	e8 a0 74 ff ff       	call   c0022a43 <lock_init>
c002b5a3:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002b5a6:	c6 05 00 8c 03 c0 01 	movb   $0x1,0xc0038c00
}
c002b5ad:	90                   	nop
c002b5ae:	c9                   	leave  
c002b5af:	c3                   	ret    

c002b5b0 <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002b5b0:	55                   	push   %ebp
c002b5b1:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002b5b3:	c6 05 00 8c 03 c0 00 	movb   $0x0,0xc0038c00
}
c002b5ba:	90                   	nop
c002b5bb:	5d                   	pop    %ebp
c002b5bc:	c3                   	ret    

c002b5bd <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002b5bd:	55                   	push   %ebp
c002b5be:	89 e5                	mov    %esp,%ebp
c002b5c0:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002b5c3:	a1 08 8c 03 c0       	mov    0xc0038c08,%eax
c002b5c8:	8b 15 0c 8c 03 c0    	mov    0xc0038c0c,%edx
c002b5ce:	83 ec 04             	sub    $0x4,%esp
c002b5d1:	52                   	push   %edx
c002b5d2:	50                   	push   %eax
c002b5d3:	68 f4 10 03 c0       	push   $0xc00310f4
c002b5d8:	e8 8c bb ff ff       	call   c0027169 <printf>
c002b5dd:	83 c4 10             	add    $0x10,%esp
}
c002b5e0:	90                   	nop
c002b5e1:	c9                   	leave  
c002b5e2:	c3                   	ret    

c002b5e3 <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002b5e3:	55                   	push   %ebp
c002b5e4:	89 e5                	mov    %esp,%ebp
c002b5e6:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b5e9:	e8 6b 60 ff ff       	call   c0021659 <intr_context>
c002b5ee:	83 f0 01             	xor    $0x1,%eax
c002b5f1:	84 c0                	test   %al,%al
c002b5f3:	74 3a                	je     c002b62f <acquire_console+0x4c>
c002b5f5:	a0 00 8c 03 c0       	mov    0xc0038c00,%al
c002b5fa:	84 c0                	test   %al,%al
c002b5fc:	74 31                	je     c002b62f <acquire_console+0x4c>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002b5fe:	83 ec 0c             	sub    $0xc,%esp
c002b601:	68 e8 8b 03 c0       	push   $0xc0038be8
c002b606:	e8 43 76 ff ff       	call   c0022c4e <lock_held_by_current_thread>
c002b60b:	83 c4 10             	add    $0x10,%esp
c002b60e:	84 c0                	test   %al,%al
c002b610:	74 0d                	je     c002b61f <acquire_console+0x3c>
        console_lock_depth++; 
c002b612:	a1 04 8c 03 c0       	mov    0xc0038c04,%eax
c002b617:	40                   	inc    %eax
c002b618:	a3 04 8c 03 c0       	mov    %eax,0xc0038c04
      else
        lock_acquire (&console_lock); 
    }
}
c002b61d:	eb 10                	jmp    c002b62f <acquire_console+0x4c>
        lock_acquire (&console_lock); 
c002b61f:	83 ec 0c             	sub    $0xc,%esp
c002b622:	68 e8 8b 03 c0       	push   $0xc0038be8
c002b627:	e8 64 74 ff ff       	call   c0022a90 <lock_acquire>
c002b62c:	83 c4 10             	add    $0x10,%esp
}
c002b62f:	90                   	nop
c002b630:	c9                   	leave  
c002b631:	c3                   	ret    

c002b632 <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002b632:	55                   	push   %ebp
c002b633:	89 e5                	mov    %esp,%ebp
c002b635:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002b638:	e8 1c 60 ff ff       	call   c0021659 <intr_context>
c002b63d:	83 f0 01             	xor    $0x1,%eax
c002b640:	84 c0                	test   %al,%al
c002b642:	74 2f                	je     c002b673 <release_console+0x41>
c002b644:	a0 00 8c 03 c0       	mov    0xc0038c00,%al
c002b649:	84 c0                	test   %al,%al
c002b64b:	74 26                	je     c002b673 <release_console+0x41>
    {
      if (console_lock_depth > 0)
c002b64d:	a1 04 8c 03 c0       	mov    0xc0038c04,%eax
c002b652:	85 c0                	test   %eax,%eax
c002b654:	7e 0d                	jle    c002b663 <release_console+0x31>
        console_lock_depth--;
c002b656:	a1 04 8c 03 c0       	mov    0xc0038c04,%eax
c002b65b:	48                   	dec    %eax
c002b65c:	a3 04 8c 03 c0       	mov    %eax,0xc0038c04
      else
        lock_release (&console_lock); 
    }
}
c002b661:	eb 10                	jmp    c002b673 <release_console+0x41>
        lock_release (&console_lock); 
c002b663:	83 ec 0c             	sub    $0xc,%esp
c002b666:	68 e8 8b 03 c0       	push   $0xc0038be8
c002b66b:	e8 60 75 ff ff       	call   c0022bd0 <lock_release>
c002b670:	83 c4 10             	add    $0x10,%esp
}
c002b673:	90                   	nop
c002b674:	c9                   	leave  
c002b675:	c3                   	ret    

c002b676 <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002b676:	55                   	push   %ebp
c002b677:	89 e5                	mov    %esp,%ebp
c002b679:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002b67c:	e8 d8 5f ff ff       	call   c0021659 <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002b681:	84 c0                	test   %al,%al
c002b683:	75 20                	jne    c002b6a5 <console_locked_by_current_thread+0x2f>
          || !use_console_lock
c002b685:	a0 00 8c 03 c0       	mov    0xc0038c00,%al
c002b68a:	83 f0 01             	xor    $0x1,%eax
c002b68d:	84 c0                	test   %al,%al
c002b68f:	75 14                	jne    c002b6a5 <console_locked_by_current_thread+0x2f>
          || lock_held_by_current_thread (&console_lock));
c002b691:	83 ec 0c             	sub    $0xc,%esp
c002b694:	68 e8 8b 03 c0       	push   $0xc0038be8
c002b699:	e8 b0 75 ff ff       	call   c0022c4e <lock_held_by_current_thread>
c002b69e:	83 c4 10             	add    $0x10,%esp
c002b6a1:	84 c0                	test   %al,%al
c002b6a3:	74 07                	je     c002b6ac <console_locked_by_current_thread+0x36>
c002b6a5:	b8 01 00 00 00       	mov    $0x1,%eax
c002b6aa:	eb 05                	jmp    c002b6b1 <console_locked_by_current_thread+0x3b>
c002b6ac:	b8 00 00 00 00       	mov    $0x0,%eax
c002b6b1:	83 e0 01             	and    $0x1,%eax
}
c002b6b4:	c9                   	leave  
c002b6b5:	c3                   	ret    

c002b6b6 <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002b6b6:	55                   	push   %ebp
c002b6b7:	89 e5                	mov    %esp,%ebp
c002b6b9:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002b6bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002b6c3:	e8 1b ff ff ff       	call   c002b5e3 <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002b6c8:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002b6cb:	50                   	push   %eax
c002b6cc:	68 95 b7 02 c0       	push   $0xc002b795
c002b6d1:	ff 75 0c             	pushl  0xc(%ebp)
c002b6d4:	ff 75 08             	pushl  0x8(%ebp)
c002b6d7:	e8 b3 ba ff ff       	call   c002718f <__vprintf>
c002b6dc:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b6df:	e8 4e ff ff ff       	call   c002b632 <release_console>

  return char_cnt;
c002b6e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b6e7:	c9                   	leave  
c002b6e8:	c3                   	ret    

c002b6e9 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002b6e9:	55                   	push   %ebp
c002b6ea:	89 e5                	mov    %esp,%ebp
c002b6ec:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b6ef:	e8 ef fe ff ff       	call   c002b5e3 <acquire_console>
  while (*s != '\0')
c002b6f4:	eb 1a                	jmp    c002b710 <puts+0x27>
    putchar_have_lock (*s++);
c002b6f6:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6f9:	8d 50 01             	lea    0x1(%eax),%edx
c002b6fc:	89 55 08             	mov    %edx,0x8(%ebp)
c002b6ff:	8a 00                	mov    (%eax),%al
c002b701:	0f b6 c0             	movzbl %al,%eax
c002b704:	83 ec 0c             	sub    $0xc,%esp
c002b707:	50                   	push   %eax
c002b708:	e8 bc 00 00 00       	call   c002b7c9 <putchar_have_lock>
c002b70d:	83 c4 10             	add    $0x10,%esp
  while (*s != '\0')
c002b710:	8b 45 08             	mov    0x8(%ebp),%eax
c002b713:	8a 00                	mov    (%eax),%al
c002b715:	84 c0                	test   %al,%al
c002b717:	75 dd                	jne    c002b6f6 <puts+0xd>
  putchar_have_lock ('\n');
c002b719:	83 ec 0c             	sub    $0xc,%esp
c002b71c:	6a 0a                	push   $0xa
c002b71e:	e8 a6 00 00 00       	call   c002b7c9 <putchar_have_lock>
c002b723:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b726:	e8 07 ff ff ff       	call   c002b632 <release_console>

  return 0;
c002b72b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b730:	c9                   	leave  
c002b731:	c3                   	ret    

c002b732 <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002b732:	55                   	push   %ebp
c002b733:	89 e5                	mov    %esp,%ebp
c002b735:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b738:	e8 a6 fe ff ff       	call   c002b5e3 <acquire_console>
  while (n-- > 0)
c002b73d:	eb 1a                	jmp    c002b759 <putbuf+0x27>
    putchar_have_lock (*buffer++);
c002b73f:	8b 45 08             	mov    0x8(%ebp),%eax
c002b742:	8d 50 01             	lea    0x1(%eax),%edx
c002b745:	89 55 08             	mov    %edx,0x8(%ebp)
c002b748:	8a 00                	mov    (%eax),%al
c002b74a:	0f b6 c0             	movzbl %al,%eax
c002b74d:	83 ec 0c             	sub    $0xc,%esp
c002b750:	50                   	push   %eax
c002b751:	e8 73 00 00 00       	call   c002b7c9 <putchar_have_lock>
c002b756:	83 c4 10             	add    $0x10,%esp
  while (n-- > 0)
c002b759:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b75c:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b75f:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b762:	85 c0                	test   %eax,%eax
c002b764:	75 d9                	jne    c002b73f <putbuf+0xd>
  release_console ();
c002b766:	e8 c7 fe ff ff       	call   c002b632 <release_console>
}
c002b76b:	90                   	nop
c002b76c:	c9                   	leave  
c002b76d:	c3                   	ret    

c002b76e <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002b76e:	55                   	push   %ebp
c002b76f:	89 e5                	mov    %esp,%ebp
c002b771:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002b774:	e8 6a fe ff ff       	call   c002b5e3 <acquire_console>
  putchar_have_lock (c);
c002b779:	8b 45 08             	mov    0x8(%ebp),%eax
c002b77c:	0f b6 c0             	movzbl %al,%eax
c002b77f:	83 ec 0c             	sub    $0xc,%esp
c002b782:	50                   	push   %eax
c002b783:	e8 41 00 00 00       	call   c002b7c9 <putchar_have_lock>
c002b788:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002b78b:	e8 a2 fe ff ff       	call   c002b632 <release_console>
  
  return c;
c002b790:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002b793:	c9                   	leave  
c002b794:	c3                   	ret    

c002b795 <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002b795:	55                   	push   %ebp
c002b796:	89 e5                	mov    %esp,%ebp
c002b798:	83 ec 28             	sub    $0x28,%esp
c002b79b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b79e:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002b7a1:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b7a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002b7a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b7aa:	8b 00                	mov    (%eax),%eax
c002b7ac:	8d 50 01             	lea    0x1(%eax),%edx
c002b7af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b7b2:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002b7b4:	8a 45 e4             	mov    -0x1c(%ebp),%al
c002b7b7:	0f b6 c0             	movzbl %al,%eax
c002b7ba:	83 ec 0c             	sub    $0xc,%esp
c002b7bd:	50                   	push   %eax
c002b7be:	e8 06 00 00 00       	call   c002b7c9 <putchar_have_lock>
c002b7c3:	83 c4 10             	add    $0x10,%esp
}
c002b7c6:	90                   	nop
c002b7c7:	c9                   	leave  
c002b7c8:	c3                   	ret    

c002b7c9 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002b7c9:	55                   	push   %ebp
c002b7ca:	89 e5                	mov    %esp,%ebp
c002b7cc:	83 ec 18             	sub    $0x18,%esp
c002b7cf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7d2:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002b7d5:	e8 9c fe ff ff       	call   c002b676 <console_locked_by_current_thread>
c002b7da:	84 c0                	test   %al,%al
c002b7dc:	75 21                	jne    c002b7ff <putchar_have_lock+0x36>
c002b7de:	83 ec 0c             	sub    $0xc,%esp
c002b7e1:	68 18 11 03 c0       	push   $0xc0031118
c002b7e6:	68 3c 11 03 c0       	push   $0xc003113c
c002b7eb:	68 70 11 03 c0       	push   $0xc0031170
c002b7f0:	68 bb 00 00 00       	push   $0xbb
c002b7f5:	68 53 11 03 c0       	push   $0xc0031153
c002b7fa:	e8 29 dd ff ff       	call   c0029528 <debug_panic>
  write_cnt++;
c002b7ff:	a1 08 8c 03 c0       	mov    0xc0038c08,%eax
c002b804:	8b 15 0c 8c 03 c0    	mov    0xc0038c0c,%edx
c002b80a:	83 c0 01             	add    $0x1,%eax
c002b80d:	83 d2 00             	adc    $0x0,%edx
c002b810:	a3 08 8c 03 c0       	mov    %eax,0xc0038c08
c002b815:	89 15 0c 8c 03 c0    	mov    %edx,0xc0038c0c
  serial_putc (c);
c002b81b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002b81f:	83 ec 0c             	sub    $0xc,%esp
c002b822:	50                   	push   %eax
c002b823:	e8 6a 91 ff ff       	call   c0024992 <serial_putc>
c002b828:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002b82b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002b82f:	83 ec 0c             	sub    $0xc,%esp
c002b832:	50                   	push   %eax
c002b833:	e8 f2 8c ff ff       	call   c002452a <vga_putc>
c002b838:	83 c4 10             	add    $0x10,%esp
}
c002b83b:	90                   	nop
c002b83c:	c9                   	leave  
c002b83d:	c3                   	ret    

c002b83e <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c002b83e:	55                   	push   %ebp
c002b83f:	89 e5                	mov    %esp,%ebp
c002b841:	83 ec 18             	sub    $0x18,%esp
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002b844:	c7 45 f4 60 13 03 c0 	movl   $0xc0031360,-0xc(%ebp)
c002b84b:	eb 4e                	jmp    c002b89b <run_test+0x5d>
    if (!strcmp (name, t->name))
c002b84d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b850:	8b 00                	mov    (%eax),%eax
c002b852:	83 ec 08             	sub    $0x8,%esp
c002b855:	50                   	push   %eax
c002b856:	ff 75 08             	pushl  0x8(%ebp)
c002b859:	e8 07 cd ff ff       	call   c0028565 <strcmp>
c002b85e:	83 c4 10             	add    $0x10,%esp
c002b861:	85 c0                	test   %eax,%eax
c002b863:	75 32                	jne    c002b897 <run_test+0x59>
      {
        test_name = name;
c002b865:	8b 45 08             	mov    0x8(%ebp),%eax
c002b868:	a3 10 8c 03 c0       	mov    %eax,0xc0038c10
        msg ("begin");
c002b86d:	83 ec 0c             	sub    $0xc,%esp
c002b870:	68 38 14 03 c0       	push   $0xc0031438
c002b875:	e8 49 00 00 00       	call   c002b8c3 <msg>
c002b87a:	83 c4 10             	add    $0x10,%esp
        t->function ();
c002b87d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b880:	8b 40 04             	mov    0x4(%eax),%eax
c002b883:	ff d0                	call   *%eax
        msg ("end");
c002b885:	83 ec 0c             	sub    $0xc,%esp
c002b888:	68 3e 14 03 c0       	push   $0xc003143e
c002b88d:	e8 31 00 00 00       	call   c002b8c3 <msg>
c002b892:	83 c4 10             	add    $0x10,%esp
        return;
c002b895:	eb 2a                	jmp    c002b8c1 <run_test+0x83>
  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002b897:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
c002b89b:	b8 38 14 03 c0       	mov    $0xc0031438,%eax
c002b8a0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002b8a3:	72 a8                	jb     c002b84d <run_test+0xf>
      }
  PANIC ("no test named \"%s\"", name);
c002b8a5:	83 ec 0c             	sub    $0xc,%esp
c002b8a8:	ff 75 08             	pushl  0x8(%ebp)
c002b8ab:	68 42 14 03 c0       	push   $0xc0031442
c002b8b0:	68 9c 14 03 c0       	push   $0xc003149c
c002b8b5:	6a 3c                	push   $0x3c
c002b8b7:	68 55 14 03 c0       	push   $0xc0031455
c002b8bc:	e8 67 dc ff ff       	call   c0029528 <debug_panic>
}
c002b8c1:	c9                   	leave  
c002b8c2:	c3                   	ret    

c002b8c3 <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002b8c3:	55                   	push   %ebp
c002b8c4:	89 e5                	mov    %esp,%ebp
c002b8c6:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c002b8c9:	a1 10 8c 03 c0       	mov    0xc0038c10,%eax
c002b8ce:	83 ec 08             	sub    $0x8,%esp
c002b8d1:	50                   	push   %eax
c002b8d2:	68 71 14 03 c0       	push   $0xc0031471
c002b8d7:	e8 8d b8 ff ff       	call   c0027169 <printf>
c002b8dc:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002b8df:	8d 45 0c             	lea    0xc(%ebp),%eax
c002b8e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002b8e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b8e8:	83 ec 08             	sub    $0x8,%esp
c002b8eb:	50                   	push   %eax
c002b8ec:	ff 75 08             	pushl  0x8(%ebp)
c002b8ef:	e8 c2 fd ff ff       	call   c002b6b6 <vprintf>
c002b8f4:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002b8f7:	83 ec 0c             	sub    $0xc,%esp
c002b8fa:	6a 0a                	push   $0xa
c002b8fc:	e8 6d fe ff ff       	call   c002b76e <putchar>
c002b901:	83 c4 10             	add    $0x10,%esp
}
c002b904:	90                   	nop
c002b905:	c9                   	leave  
c002b906:	c3                   	ret    

c002b907 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002b907:	55                   	push   %ebp
c002b908:	89 e5                	mov    %esp,%ebp
c002b90a:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002b90d:	a1 10 8c 03 c0       	mov    0xc0038c10,%eax
c002b912:	83 ec 08             	sub    $0x8,%esp
c002b915:	50                   	push   %eax
c002b916:	68 77 14 03 c0       	push   $0xc0031477
c002b91b:	e8 49 b8 ff ff       	call   c0027169 <printf>
c002b920:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002b923:	8d 45 0c             	lea    0xc(%ebp),%eax
c002b926:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002b929:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b92c:	83 ec 08             	sub    $0x8,%esp
c002b92f:	50                   	push   %eax
c002b930:	ff 75 08             	pushl  0x8(%ebp)
c002b933:	e8 7e fd ff ff       	call   c002b6b6 <vprintf>
c002b938:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002b93b:	83 ec 0c             	sub    $0xc,%esp
c002b93e:	6a 0a                	push   $0xa
c002b940:	e8 29 fe ff ff       	call   c002b76e <putchar>
c002b945:	83 c4 10             	add    $0x10,%esp

  PANIC ("test failed");
c002b948:	68 83 14 03 c0       	push   $0xc0031483
c002b94d:	68 a8 14 03 c0       	push   $0xc00314a8
c002b952:	6a 5d                	push   $0x5d
c002b954:	68 55 14 03 c0       	push   $0xc0031455
c002b959:	e8 ca db ff ff       	call   c0029528 <debug_panic>

c002b95e <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002b95e:	55                   	push   %ebp
c002b95f:	89 e5                	mov    %esp,%ebp
c002b961:	83 ec 08             	sub    $0x8,%esp
  printf ("(%s) PASS\n", test_name);
c002b964:	a1 10 8c 03 c0       	mov    0xc0038c10,%eax
c002b969:	83 ec 08             	sub    $0x8,%esp
c002b96c:	50                   	push   %eax
c002b96d:	68 8f 14 03 c0       	push   $0xc003148f
c002b972:	e8 f2 b7 ff ff       	call   c0027169 <printf>
c002b977:	83 c4 10             	add    $0x10,%esp
}
c002b97a:	90                   	nop
c002b97b:	c9                   	leave  
c002b97c:	c3                   	ret    

c002b97d <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c002b97d:	55                   	push   %ebp
c002b97e:	89 e5                	mov    %esp,%ebp
c002b980:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 1);
c002b983:	83 ec 08             	sub    $0x8,%esp
c002b986:	6a 01                	push   $0x1
c002b988:	6a 05                	push   $0x5
c002b98a:	e8 1e 00 00 00       	call   c002b9ad <test_sleep>
c002b98f:	83 c4 10             	add    $0x10,%esp
}
c002b992:	90                   	nop
c002b993:	c9                   	leave  
c002b994:	c3                   	ret    

c002b995 <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c002b995:	55                   	push   %ebp
c002b996:	89 e5                	mov    %esp,%ebp
c002b998:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 7);
c002b99b:	83 ec 08             	sub    $0x8,%esp
c002b99e:	6a 07                	push   $0x7
c002b9a0:	6a 05                	push   $0x5
c002b9a2:	e8 06 00 00 00       	call   c002b9ad <test_sleep>
c002b9a7:	83 c4 10             	add    $0x10,%esp
}
c002b9aa:	90                   	nop
c002b9ab:	c9                   	leave  
c002b9ac:	c3                   	ret    

c002b9ad <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002b9ad:	55                   	push   %ebp
c002b9ae:	89 e5                	mov    %esp,%ebp
c002b9b0:	83 ec 68             	sub    $0x68,%esp
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002b9b3:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002b9b8:	83 f0 01             	xor    $0x1,%eax
c002b9bb:	84 c0                	test   %al,%al
c002b9bd:	75 1e                	jne    c002b9dd <test_sleep+0x30>
c002b9bf:	83 ec 0c             	sub    $0xc,%esp
c002b9c2:	68 b0 14 03 c0       	push   $0xc00314b0
c002b9c7:	68 be 14 03 c0       	push   $0xc00314be
c002b9cc:	68 c4 16 03 c0       	push   $0xc00316c4
c002b9d1:	6a 3c                	push   $0x3c
c002b9d3:	68 d8 14 03 c0       	push   $0xc00314d8
c002b9d8:	e8 4b db ff ff       	call   c0029528 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002b9dd:	83 ec 04             	sub    $0x4,%esp
c002b9e0:	ff 75 0c             	pushl  0xc(%ebp)
c002b9e3:	ff 75 08             	pushl  0x8(%ebp)
c002b9e6:	68 fc 14 03 c0       	push   $0xc00314fc
c002b9eb:	e8 d3 fe ff ff       	call   c002b8c3 <msg>
c002b9f0:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 0 sleeps 10 ticks each time,");
c002b9f3:	83 ec 0c             	sub    $0xc,%esp
c002b9f6:	68 28 15 03 c0       	push   $0xc0031528
c002b9fb:	e8 c3 fe ff ff       	call   c002b8c3 <msg>
c002ba00:	83 c4 10             	add    $0x10,%esp
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002ba03:	83 ec 0c             	sub    $0xc,%esp
c002ba06:	68 4c 15 03 c0       	push   $0xc003154c
c002ba0b:	e8 b3 fe ff ff       	call   c002b8c3 <msg>
c002ba10:	83 c4 10             	add    $0x10,%esp
  msg ("If successful, product of iteration count and");
c002ba13:	83 ec 0c             	sub    $0xc,%esp
c002ba16:	68 7c 15 03 c0       	push   $0xc003157c
c002ba1b:	e8 a3 fe ff ff       	call   c002b8c3 <msg>
c002ba20:	83 c4 10             	add    $0x10,%esp
  msg ("sleep duration will appear in nondescending order.");
c002ba23:	83 ec 0c             	sub    $0xc,%esp
c002ba26:	68 ac 15 03 c0       	push   $0xc00315ac
c002ba2b:	e8 93 fe ff ff       	call   c002b8c3 <msg>
c002ba30:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c002ba33:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba36:	c1 e0 04             	shl    $0x4,%eax
c002ba39:	83 ec 0c             	sub    $0xc,%esp
c002ba3c:	50                   	push   %eax
c002ba3d:	e8 19 7a ff ff       	call   c002345b <malloc>
c002ba42:	83 c4 10             	add    $0x10,%esp
c002ba45:	89 45 e8             	mov    %eax,-0x18(%ebp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002ba48:	8b 55 0c             	mov    0xc(%ebp),%edx
c002ba4b:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba4e:	0f af c2             	imul   %edx,%eax
c002ba51:	c1 e0 03             	shl    $0x3,%eax
c002ba54:	83 ec 0c             	sub    $0xc,%esp
c002ba57:	50                   	push   %eax
c002ba58:	e8 fe 79 ff ff       	call   c002345b <malloc>
c002ba5d:	83 c4 10             	add    $0x10,%esp
c002ba60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (threads == NULL || output == NULL)
c002ba63:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002ba67:	74 06                	je     c002ba6f <test_sleep+0xc2>
c002ba69:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002ba6d:	75 16                	jne    c002ba85 <test_sleep+0xd8>
    PANIC ("couldn't allocate memory for test");
c002ba6f:	68 e0 15 03 c0       	push   $0xc00315e0
c002ba74:	68 c4 16 03 c0       	push   $0xc00316c4
c002ba79:	6a 48                	push   $0x48
c002ba7b:	68 d8 14 03 c0       	push   $0xc00314d8
c002ba80:	e8 a3 da ff ff       	call   c0029528 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002ba85:	e8 14 82 ff ff       	call   c0023c9e <timer_ticks>
c002ba8a:	83 c0 64             	add    $0x64,%eax
c002ba8d:	83 d2 00             	adc    $0x0,%edx
c002ba90:	89 45 b0             	mov    %eax,-0x50(%ebp)
c002ba93:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  test.iterations = iterations;
c002ba96:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ba99:	89 45 b8             	mov    %eax,-0x48(%ebp)
  lock_init (&test.output_lock);
c002ba9c:	83 ec 0c             	sub    $0xc,%esp
c002ba9f:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002baa2:	83 c0 0c             	add    $0xc,%eax
c002baa5:	50                   	push   %eax
c002baa6:	e8 98 6f ff ff       	call   c0022a43 <lock_init>
c002baab:	83 c4 10             	add    $0x10,%esp
  test.output_pos = output;
c002baae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002bab1:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002bab4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002bab8:	75 1e                	jne    c002bad8 <test_sleep+0x12b>
c002baba:	83 ec 0c             	sub    $0xc,%esp
c002babd:	68 02 16 03 c0       	push   $0xc0031602
c002bac2:	68 be 14 03 c0       	push   $0xc00314be
c002bac7:	68 c4 16 03 c0       	push   $0xc00316c4
c002bacc:	6a 51                	push   $0x51
c002bace:	68 d8 14 03 c0       	push   $0xc00314d8
c002bad3:	e8 50 da ff ff       	call   c0029528 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002bad8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002badf:	eb 71                	jmp    c002bb52 <test_sleep+0x1a5>
    {
      struct sleep_thread *t = threads + i;
c002bae1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bae4:	c1 e0 04             	shl    $0x4,%eax
c002bae7:	89 c2                	mov    %eax,%edx
c002bae9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002baec:	01 d0                	add    %edx,%eax
c002baee:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char name[16];
      
      t->test = &test;
c002baf1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002baf4:	8d 55 b0             	lea    -0x50(%ebp),%edx
c002baf7:	89 10                	mov    %edx,(%eax)
      t->id = i;
c002baf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bafc:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002baff:	89 50 04             	mov    %edx,0x4(%eax)
      t->duration = (i + 1) * 10;
c002bb02:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bb05:	8d 50 01             	lea    0x1(%eax),%edx
c002bb08:	89 d0                	mov    %edx,%eax
c002bb0a:	c1 e0 02             	shl    $0x2,%eax
c002bb0d:	01 d0                	add    %edx,%eax
c002bb0f:	01 c0                	add    %eax,%eax
c002bb11:	89 c2                	mov    %eax,%edx
c002bb13:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bb16:	89 50 08             	mov    %edx,0x8(%eax)
      t->iterations = 0;
c002bb19:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bb1c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

      snprintf (name, sizeof name, "thread %d", i);
c002bb23:	ff 75 ec             	pushl  -0x14(%ebp)
c002bb26:	68 11 16 03 c0       	push   $0xc0031611
c002bb2b:	6a 10                	push   $0x10
c002bb2d:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bb30:	50                   	push   %eax
c002bb31:	e8 0a b6 ff ff       	call   c0027140 <snprintf>
c002bb36:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002bb39:	ff 75 e0             	pushl  -0x20(%ebp)
c002bb3c:	68 e7 bc 02 c0       	push   $0xc002bce7
c002bb41:	6a 1f                	push   $0x1f
c002bb43:	8d 45 a0             	lea    -0x60(%ebp),%eax
c002bb46:	50                   	push   %eax
c002bb47:	e8 fe 4e ff ff       	call   c0020a4a <thread_create>
c002bb4c:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002bb4f:	ff 45 ec             	incl   -0x14(%ebp)
c002bb52:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bb55:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bb58:	7c 87                	jl     c002bae1 <test_sleep+0x134>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002bb5a:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb5d:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002bb61:	89 c2                	mov    %eax,%edx
c002bb63:	89 d0                	mov    %edx,%eax
c002bb65:	c1 e0 02             	shl    $0x2,%eax
c002bb68:	01 d0                	add    %edx,%eax
c002bb6a:	01 c0                	add    %eax,%eax
c002bb6c:	05 c8 00 00 00       	add    $0xc8,%eax
c002bb71:	99                   	cltd   
c002bb72:	83 ec 08             	sub    $0x8,%esp
c002bb75:	52                   	push   %edx
c002bb76:	50                   	push   %eax
c002bb77:	e8 76 81 ff ff       	call   c0023cf2 <timer_sleep>
c002bb7c:	83 c4 10             	add    $0x10,%esp

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c002bb7f:	83 ec 0c             	sub    $0xc,%esp
c002bb82:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bb85:	83 c0 0c             	add    $0xc,%eax
c002bb88:	50                   	push   %eax
c002bb89:	e8 02 6f ff ff       	call   c0022a90 <lock_acquire>
c002bb8e:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  product = 0;
c002bb91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (op = output; op < test.output_pos; op++) 
c002bb98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002bb9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002bb9e:	e9 ba 00 00 00       	jmp    c002bc5d <test_sleep+0x2b0>
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c002bba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bba6:	8b 00                	mov    (%eax),%eax
c002bba8:	85 c0                	test   %eax,%eax
c002bbaa:	78 0a                	js     c002bbb6 <test_sleep+0x209>
c002bbac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bbaf:	8b 00                	mov    (%eax),%eax
c002bbb1:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bbb4:	7c 1e                	jl     c002bbd4 <test_sleep+0x227>
c002bbb6:	83 ec 0c             	sub    $0xc,%esp
c002bbb9:	68 1b 16 03 c0       	push   $0xc003161b
c002bbbe:	68 be 14 03 c0       	push   $0xc00314be
c002bbc3:	68 c4 16 03 c0       	push   $0xc00316c4
c002bbc8:	6a 6e                	push   $0x6e
c002bbca:	68 d8 14 03 c0       	push   $0xc00314d8
c002bbcf:	e8 54 d9 ff ff       	call   c0029528 <debug_panic>
      t = threads + *op;
c002bbd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bbd7:	8b 00                	mov    (%eax),%eax
c002bbd9:	c1 e0 04             	shl    $0x4,%eax
c002bbdc:	89 c2                	mov    %eax,%edx
c002bbde:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bbe1:	01 d0                	add    %edx,%eax
c002bbe3:	89 45 dc             	mov    %eax,-0x24(%ebp)

      new_prod = ++t->iterations * t->duration;
c002bbe6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bbe9:	8b 40 0c             	mov    0xc(%eax),%eax
c002bbec:	8d 50 01             	lea    0x1(%eax),%edx
c002bbef:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bbf2:	89 50 0c             	mov    %edx,0xc(%eax)
c002bbf5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bbf8:	8b 50 0c             	mov    0xc(%eax),%edx
c002bbfb:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bbfe:	8b 40 08             	mov    0x8(%eax),%eax
c002bc01:	0f af c2             	imul   %edx,%eax
c002bc04:	89 45 d8             	mov    %eax,-0x28(%ebp)
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002bc07:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bc0a:	8b 48 0c             	mov    0xc(%eax),%ecx
c002bc0d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bc10:	8b 50 08             	mov    0x8(%eax),%edx
c002bc13:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bc16:	8b 40 04             	mov    0x4(%eax),%eax
c002bc19:	83 ec 0c             	sub    $0xc,%esp
c002bc1c:	ff 75 d8             	pushl  -0x28(%ebp)
c002bc1f:	51                   	push   %ecx
c002bc20:	52                   	push   %edx
c002bc21:	50                   	push   %eax
c002bc22:	68 38 16 03 c0       	push   $0xc0031638
c002bc27:	e8 97 fc ff ff       	call   c002b8c3 <msg>
c002bc2c:	83 c4 20             	add    $0x20,%esp
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c002bc2f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002bc32:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002bc35:	7c 08                	jl     c002bc3f <test_sleep+0x292>
        product = new_prod;
c002bc37:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002bc3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002bc3d:	eb 1a                	jmp    c002bc59 <test_sleep+0x2ac>
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c002bc3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002bc42:	8b 40 04             	mov    0x4(%eax),%eax
c002bc45:	ff 75 d8             	pushl  -0x28(%ebp)
c002bc48:	ff 75 f0             	pushl  -0x10(%ebp)
c002bc4b:	50                   	push   %eax
c002bc4c:	68 6c 16 03 c0       	push   $0xc003166c
c002bc51:	e8 b1 fc ff ff       	call   c002b907 <fail>
c002bc56:	83 c4 10             	add    $0x10,%esp
  for (op = output; op < test.output_pos; op++) 
c002bc59:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002bc5d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002bc60:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bc63:	0f 87 3a ff ff ff    	ja     c002bba3 <test_sleep+0x1f6>
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002bc69:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002bc70:	eb 3c                	jmp    c002bcae <test_sleep+0x301>
    if (threads[i].iterations != iterations)
c002bc72:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc75:	c1 e0 04             	shl    $0x4,%eax
c002bc78:	89 c2                	mov    %eax,%edx
c002bc7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bc7d:	01 d0                	add    %edx,%eax
c002bc7f:	8b 40 0c             	mov    0xc(%eax),%eax
c002bc82:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002bc85:	74 24                	je     c002bcab <test_sleep+0x2fe>
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
c002bc87:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bc8a:	c1 e0 04             	shl    $0x4,%eax
c002bc8d:	89 c2                	mov    %eax,%edx
c002bc8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bc92:	01 d0                	add    %edx,%eax
      fail ("thread %d woke up %d times instead of %d",
c002bc94:	8b 40 0c             	mov    0xc(%eax),%eax
c002bc97:	ff 75 0c             	pushl  0xc(%ebp)
c002bc9a:	50                   	push   %eax
c002bc9b:	ff 75 ec             	pushl  -0x14(%ebp)
c002bc9e:	68 98 16 03 c0       	push   $0xc0031698
c002bca3:	e8 5f fc ff ff       	call   c002b907 <fail>
c002bca8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002bcab:	ff 45 ec             	incl   -0x14(%ebp)
c002bcae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bcb1:	3b 45 08             	cmp    0x8(%ebp),%eax
c002bcb4:	7c bc                	jl     c002bc72 <test_sleep+0x2c5>
  
  lock_release (&test.output_lock);
c002bcb6:	83 ec 0c             	sub    $0xc,%esp
c002bcb9:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002bcbc:	83 c0 0c             	add    $0xc,%eax
c002bcbf:	50                   	push   %eax
c002bcc0:	e8 0b 6f ff ff       	call   c0022bd0 <lock_release>
c002bcc5:	83 c4 10             	add    $0x10,%esp
  free (output);
c002bcc8:	83 ec 0c             	sub    $0xc,%esp
c002bccb:	ff 75 e4             	pushl  -0x1c(%ebp)
c002bcce:	e8 82 7a ff ff       	call   c0023755 <free>
c002bcd3:	83 c4 10             	add    $0x10,%esp
  free (threads);
c002bcd6:	83 ec 0c             	sub    $0xc,%esp
c002bcd9:	ff 75 e8             	pushl  -0x18(%ebp)
c002bcdc:	e8 74 7a ff ff       	call   c0023755 <free>
c002bce1:	83 c4 10             	add    $0x10,%esp
}
c002bce4:	90                   	nop
c002bce5:	c9                   	leave  
c002bce6:	c3                   	ret    

c002bce7 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002bce7:	55                   	push   %ebp
c002bce8:	89 e5                	mov    %esp,%ebp
c002bcea:	53                   	push   %ebx
c002bceb:	83 ec 24             	sub    $0x24,%esp
  struct sleep_thread *t = t_;
c002bcee:	8b 45 08             	mov    0x8(%ebp),%eax
c002bcf1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct sleep_test *test = t->test;
c002bcf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bcf7:	8b 00                	mov    (%eax),%eax
c002bcf9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002bcfc:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002bd03:	eb 7b                	jmp    c002bd80 <sleeper+0x99>
    {
      int64_t sleep_until = test->start + i * t->duration;
c002bd05:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd08:	8b 08                	mov    (%eax),%ecx
c002bd0a:	8b 58 04             	mov    0x4(%eax),%ebx
c002bd0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bd10:	8b 40 08             	mov    0x8(%eax),%eax
c002bd13:	0f af 45 f4          	imul   -0xc(%ebp),%eax
c002bd17:	99                   	cltd   
c002bd18:	01 c8                	add    %ecx,%eax
c002bd1a:	11 da                	adc    %ebx,%edx
c002bd1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002bd1f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002bd22:	e8 77 7f ff ff       	call   c0023c9e <timer_ticks>
c002bd27:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002bd2a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002bd2d:	29 c1                	sub    %eax,%ecx
c002bd2f:	19 d3                	sbb    %edx,%ebx
c002bd31:	89 c8                	mov    %ecx,%eax
c002bd33:	89 da                	mov    %ebx,%edx
c002bd35:	83 ec 08             	sub    $0x8,%esp
c002bd38:	52                   	push   %edx
c002bd39:	50                   	push   %eax
c002bd3a:	e8 b3 7f ff ff       	call   c0023cf2 <timer_sleep>
c002bd3f:	83 c4 10             	add    $0x10,%esp
      lock_acquire (&test->output_lock);
c002bd42:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd45:	83 c0 0c             	add    $0xc,%eax
c002bd48:	83 ec 0c             	sub    $0xc,%esp
c002bd4b:	50                   	push   %eax
c002bd4c:	e8 3f 6d ff ff       	call   c0022a90 <lock_acquire>
c002bd51:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = t->id;
c002bd54:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd57:	8b 40 24             	mov    0x24(%eax),%eax
c002bd5a:	8d 48 04             	lea    0x4(%eax),%ecx
c002bd5d:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002bd60:	89 4a 24             	mov    %ecx,0x24(%edx)
c002bd63:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002bd66:	8b 52 04             	mov    0x4(%edx),%edx
c002bd69:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002bd6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd6e:	83 c0 0c             	add    $0xc,%eax
c002bd71:	83 ec 0c             	sub    $0xc,%esp
c002bd74:	50                   	push   %eax
c002bd75:	e8 56 6e ff ff       	call   c0022bd0 <lock_release>
c002bd7a:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i <= test->iterations; i++) 
c002bd7d:	ff 45 f4             	incl   -0xc(%ebp)
c002bd80:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bd83:	8b 40 08             	mov    0x8(%eax),%eax
c002bd86:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bd89:	0f 8d 76 ff ff ff    	jge    c002bd05 <sleeper+0x1e>
    }
}
c002bd8f:	90                   	nop
c002bd90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bd93:	c9                   	leave  
c002bd94:	c3                   	ret    

c002bd95 <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c002bd95:	55                   	push   %ebp
c002bd96:	89 e5                	mov    %esp,%ebp
c002bd98:	83 ec 08             	sub    $0x8,%esp
  test_sleep (3, 5);
c002bd9b:	83 ec 08             	sub    $0x8,%esp
c002bd9e:	6a 05                	push   $0x5
c002bda0:	6a 03                	push   $0x3
c002bda2:	e8 06 00 00 00       	call   c002bdad <test_sleep>
c002bda7:	83 c4 10             	add    $0x10,%esp
}
c002bdaa:	90                   	nop
c002bdab:	c9                   	leave  
c002bdac:	c3                   	ret    

c002bdad <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002bdad:	55                   	push   %ebp
c002bdae:	89 e5                	mov    %esp,%ebp
c002bdb0:	53                   	push   %ebx
c002bdb1:	83 ec 34             	sub    $0x34,%esp
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002bdb4:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002bdb9:	83 f0 01             	xor    $0x1,%eax
c002bdbc:	84 c0                	test   %al,%al
c002bdbe:	75 1e                	jne    c002bdde <test_sleep+0x31>
c002bdc0:	83 ec 0c             	sub    $0xc,%esp
c002bdc3:	68 d0 16 03 c0       	push   $0xc00316d0
c002bdc8:	68 de 16 03 c0       	push   $0xc00316de
c002bdcd:	68 58 18 03 c0       	push   $0xc0031858
c002bdd2:	6a 28                	push   $0x28
c002bdd4:	68 f8 16 03 c0       	push   $0xc00316f8
c002bdd9:	e8 4a d7 ff ff       	call   c0029528 <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002bdde:	83 ec 04             	sub    $0x4,%esp
c002bde1:	ff 75 0c             	pushl  0xc(%ebp)
c002bde4:	ff 75 08             	pushl  0x8(%ebp)
c002bde7:	68 24 17 03 c0       	push   $0xc0031724
c002bdec:	e8 d2 fa ff ff       	call   c002b8c3 <msg>
c002bdf1:	83 c4 10             	add    $0x10,%esp
  msg ("Each thread sleeps 10 ticks each time.");
c002bdf4:	83 ec 0c             	sub    $0xc,%esp
c002bdf7:	68 50 17 03 c0       	push   $0xc0031750
c002bdfc:	e8 c2 fa ff ff       	call   c002b8c3 <msg>
c002be01:	83 c4 10             	add    $0x10,%esp
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002be04:	83 ec 0c             	sub    $0xc,%esp
c002be07:	68 78 17 03 c0       	push   $0xc0031778
c002be0c:	e8 b2 fa ff ff       	call   c002b8c3 <msg>
c002be11:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002be14:	8b 55 0c             	mov    0xc(%ebp),%edx
c002be17:	8b 45 08             	mov    0x8(%ebp),%eax
c002be1a:	0f af c2             	imul   %edx,%eax
c002be1d:	c1 e0 03             	shl    $0x3,%eax
c002be20:	83 ec 0c             	sub    $0xc,%esp
c002be23:	50                   	push   %eax
c002be24:	e8 32 76 ff ff       	call   c002345b <malloc>
c002be29:	83 c4 10             	add    $0x10,%esp
c002be2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (output == NULL)
c002be2f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002be33:	75 16                	jne    c002be4b <test_sleep+0x9e>
    PANIC ("couldn't allocate memory for test");
c002be35:	68 bc 17 03 c0       	push   $0xc00317bc
c002be3a:	68 58 18 03 c0       	push   $0xc0031858
c002be3f:	6a 31                	push   $0x31
c002be41:	68 f8 16 03 c0       	push   $0xc00316f8
c002be46:	e8 dd d6 ff ff       	call   c0029528 <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002be4b:	e8 4e 7e ff ff       	call   c0023c9e <timer_ticks>
c002be50:	83 c0 64             	add    $0x64,%eax
c002be53:	83 d2 00             	adc    $0x0,%edx
c002be56:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002be59:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  test.iterations = iterations;
c002be5c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002be5f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  test.output_pos = output;
c002be62:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002be65:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002be68:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002be6c:	75 1e                	jne    c002be8c <test_sleep+0xdf>
c002be6e:	83 ec 0c             	sub    $0xc,%esp
c002be71:	68 de 17 03 c0       	push   $0xc00317de
c002be76:	68 de 16 03 c0       	push   $0xc00316de
c002be7b:	68 58 18 03 c0       	push   $0xc0031858
c002be80:	6a 39                	push   $0x39
c002be82:	68 f8 16 03 c0       	push   $0xc00316f8
c002be87:	e8 9c d6 ff ff       	call   c0029528 <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002be8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002be93:	eb 30                	jmp    c002bec5 <test_sleep+0x118>
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c002be95:	ff 75 f4             	pushl  -0xc(%ebp)
c002be98:	68 ed 17 03 c0       	push   $0xc00317ed
c002be9d:	6a 10                	push   $0x10
c002be9f:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002bea2:	50                   	push   %eax
c002bea3:	e8 98 b2 ff ff       	call   c0027140 <snprintf>
c002bea8:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002beab:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002beae:	50                   	push   %eax
c002beaf:	68 81 bf 02 c0       	push   $0xc002bf81
c002beb4:	6a 1f                	push   $0x1f
c002beb6:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002beb9:	50                   	push   %eax
c002beba:	e8 8b 4b ff ff       	call   c0020a4a <thread_create>
c002bebf:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002bec2:	ff 45 f4             	incl   -0xc(%ebp)
c002bec5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bec8:	3b 45 08             	cmp    0x8(%ebp),%eax
c002becb:	7c c8                	jl     c002be95 <test_sleep+0xe8>
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c002becd:	8b 55 0c             	mov    0xc(%ebp),%edx
c002bed0:	89 d0                	mov    %edx,%eax
c002bed2:	c1 e0 02             	shl    $0x2,%eax
c002bed5:	01 d0                	add    %edx,%eax
c002bed7:	01 c0                	add    %eax,%eax
c002bed9:	05 c8 00 00 00       	add    $0xc8,%eax
c002bede:	99                   	cltd   
c002bedf:	83 ec 08             	sub    $0x8,%esp
c002bee2:	52                   	push   %edx
c002bee3:	50                   	push   %eax
c002bee4:	e8 09 7e ff ff       	call   c0023cf2 <timer_sleep>
c002bee9:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002beec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002beef:	8b 00                	mov    (%eax),%eax
c002bef1:	83 ec 08             	sub    $0x8,%esp
c002bef4:	50                   	push   %eax
c002bef5:	68 f8 17 03 c0       	push   $0xc00317f8
c002befa:	e8 c4 f9 ff ff       	call   c002b8c3 <msg>
c002beff:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002bf02:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002bf09:	eb 4e                	jmp    c002bf59 <test_sleep+0x1ac>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
c002bf0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf0e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002bf15:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf18:	01 d0                	add    %edx,%eax
c002bf1a:	8b 10                	mov    (%eax),%edx
c002bf1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf1f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002bf24:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c002bf2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf2e:	01 c8                	add    %ecx,%eax
c002bf30:	8b 00                	mov    (%eax),%eax
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002bf32:	89 d3                	mov    %edx,%ebx
c002bf34:	29 c3                	sub    %eax,%ebx
c002bf36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf39:	99                   	cltd   
c002bf3a:	f7 7d 08             	idivl  0x8(%ebp)
c002bf3d:	89 d1                	mov    %edx,%ecx
c002bf3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf42:	99                   	cltd   
c002bf43:	f7 7d 08             	idivl  0x8(%ebp)
c002bf46:	53                   	push   %ebx
c002bf47:	51                   	push   %ecx
c002bf48:	50                   	push   %eax
c002bf49:	68 28 18 03 c0       	push   $0xc0031828
c002bf4e:	e8 70 f9 ff ff       	call   c002b8c3 <msg>
c002bf53:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002bf56:	ff 45 f4             	incl   -0xc(%ebp)
c002bf59:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bf5c:	89 c2                	mov    %eax,%edx
c002bf5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bf61:	29 c2                	sub    %eax,%edx
c002bf63:	89 d0                	mov    %edx,%eax
c002bf65:	c1 f8 02             	sar    $0x2,%eax
c002bf68:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bf6b:	7f 9e                	jg     c002bf0b <test_sleep+0x15e>
  
  free (output);
c002bf6d:	83 ec 0c             	sub    $0xc,%esp
c002bf70:	ff 75 f0             	pushl  -0x10(%ebp)
c002bf73:	e8 dd 77 ff ff       	call   c0023755 <free>
c002bf78:	83 c4 10             	add    $0x10,%esp
}
c002bf7b:	90                   	nop
c002bf7c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002bf7f:	c9                   	leave  
c002bf80:	c3                   	ret    

c002bf81 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002bf81:	55                   	push   %ebp
c002bf82:	89 e5                	mov    %esp,%ebp
c002bf84:	53                   	push   %ebx
c002bf85:	83 ec 14             	sub    $0x14,%esp
  struct sleep_test *test = test_;
c002bf88:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002bf8e:	83 ec 08             	sub    $0x8,%esp
c002bf91:	6a 00                	push   $0x0
c002bf93:	6a 01                	push   $0x1
c002bf95:	e8 58 7d ff ff       	call   c0023cf2 <timer_sleep>
c002bf9a:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i <= test->iterations; i++) 
c002bf9d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002bfa4:	eb 6b                	jmp    c002c011 <sleeper+0x90>
    {
      int64_t sleep_until = test->start + i * 10;
c002bfa6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bfa9:	8b 08                	mov    (%eax),%ecx
c002bfab:	8b 58 04             	mov    0x4(%eax),%ebx
c002bfae:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002bfb1:	89 d0                	mov    %edx,%eax
c002bfb3:	c1 e0 02             	shl    $0x2,%eax
c002bfb6:	01 d0                	add    %edx,%eax
c002bfb8:	01 c0                	add    %eax,%eax
c002bfba:	99                   	cltd   
c002bfbb:	01 c8                	add    %ecx,%eax
c002bfbd:	11 da                	adc    %ebx,%edx
c002bfbf:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002bfc2:	89 55 ec             	mov    %edx,-0x14(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002bfc5:	e8 d4 7c ff ff       	call   c0023c9e <timer_ticks>
c002bfca:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002bfcd:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002bfd0:	29 c1                	sub    %eax,%ecx
c002bfd2:	19 d3                	sbb    %edx,%ebx
c002bfd4:	89 c8                	mov    %ecx,%eax
c002bfd6:	89 da                	mov    %ebx,%edx
c002bfd8:	83 ec 08             	sub    $0x8,%esp
c002bfdb:	52                   	push   %edx
c002bfdc:	50                   	push   %eax
c002bfdd:	e8 10 7d ff ff       	call   c0023cf2 <timer_sleep>
c002bfe2:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = timer_ticks () - test->start;
c002bfe5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bfe8:	8b 58 0c             	mov    0xc(%eax),%ebx
c002bfeb:	8d 53 04             	lea    0x4(%ebx),%edx
c002bfee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bff1:	89 50 0c             	mov    %edx,0xc(%eax)
c002bff4:	e8 a5 7c ff ff       	call   c0023c9e <timer_ticks>
c002bff9:	89 c1                	mov    %eax,%ecx
c002bffb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bffe:	8b 50 04             	mov    0x4(%eax),%edx
c002c001:	8b 00                	mov    (%eax),%eax
c002c003:	29 c1                	sub    %eax,%ecx
c002c005:	89 c8                	mov    %ecx,%eax
c002c007:	89 03                	mov    %eax,(%ebx)
      thread_yield ();
c002c009:	e8 4b 4d ff ff       	call   c0020d59 <thread_yield>
  for (i = 1; i <= test->iterations; i++) 
c002c00e:	ff 45 f4             	incl   -0xc(%ebp)
c002c011:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c014:	8b 40 08             	mov    0x8(%eax),%eax
c002c017:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c01a:	7d 8a                	jge    c002bfa6 <sleeper+0x25>
    }
}
c002c01c:	90                   	nop
c002c01d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c020:	c9                   	leave  
c002c021:	c3                   	ret    

c002c022 <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c002c022:	55                   	push   %ebp
c002c023:	89 e5                	mov    %esp,%ebp
c002c025:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c028:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002c02d:	83 f0 01             	xor    $0x1,%eax
c002c030:	84 c0                	test   %al,%al
c002c032:	75 1e                	jne    c002c052 <test_alarm_priority+0x30>
c002c034:	83 ec 0c             	sub    $0xc,%esp
c002c037:	68 64 18 03 c0       	push   $0xc0031864
c002c03c:	68 72 18 03 c0       	push   $0xc0031872
c002c041:	68 d0 18 03 c0       	push   $0xc00318d0
c002c046:	6a 16                	push   $0x16
c002c048:	68 8c 18 03 c0       	push   $0xc003188c
c002c04d:	e8 d6 d4 ff ff       	call   c0029528 <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002c052:	e8 47 7c ff ff       	call   c0023c9e <timer_ticks>
c002c057:	05 f4 01 00 00       	add    $0x1f4,%eax
c002c05c:	83 d2 00             	adc    $0x0,%edx
c002c05f:	a3 18 8c 03 c0       	mov    %eax,0xc0038c18
c002c064:	89 15 1c 8c 03 c0    	mov    %edx,0xc0038c1c
  sema_init (&wait_sema, 0);
c002c06a:	83 ec 08             	sub    $0x8,%esp
c002c06d:	6a 00                	push   $0x0
c002c06f:	68 20 8c 03 c0       	push   $0xc0038c20
c002c074:	e8 12 67 ff ff       	call   c002278b <sema_init>
c002c079:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 10; i++) 
c002c07c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c083:	eb 4b                	jmp    c002c0d0 <test_alarm_priority+0xae>
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002c085:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c088:	83 c0 05             	add    $0x5,%eax
c002c08b:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002c090:	99                   	cltd   
c002c091:	f7 f9                	idiv   %ecx
c002c093:	89 d0                	mov    %edx,%eax
c002c095:	ba 1e 00 00 00       	mov    $0x1e,%edx
c002c09a:	29 c2                	sub    %eax,%edx
c002c09c:	89 d0                	mov    %edx,%eax
c002c09e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002c0a1:	ff 75 f0             	pushl  -0x10(%ebp)
c002c0a4:	68 b1 18 03 c0       	push   $0xc00318b1
c002c0a9:	6a 10                	push   $0x10
c002c0ab:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c0ae:	50                   	push   %eax
c002c0af:	e8 8c b0 ff ff       	call   c0027140 <snprintf>
c002c0b4:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
c002c0b7:	6a 00                	push   $0x0
c002c0b9:	68 08 c1 02 c0       	push   $0xc002c108
c002c0be:	ff 75 f0             	pushl  -0x10(%ebp)
c002c0c1:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c0c4:	50                   	push   %eax
c002c0c5:	e8 80 49 ff ff       	call   c0020a4a <thread_create>
c002c0ca:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002c0cd:	ff 45 f4             	incl   -0xc(%ebp)
c002c0d0:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c0d4:	7e af                	jle    c002c085 <test_alarm_priority+0x63>
    }

  thread_set_priority (PRI_MIN);
c002c0d6:	83 ec 0c             	sub    $0xc,%esp
c002c0d9:	6a 00                	push   $0x0
c002c0db:	e8 88 4d ff ff       	call   c0020e68 <thread_set_priority>
c002c0e0:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 10; i++)
c002c0e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c0ea:	eb 13                	jmp    c002c0ff <test_alarm_priority+0xdd>
    sema_down (&wait_sema);
c002c0ec:	83 ec 0c             	sub    $0xc,%esp
c002c0ef:	68 20 8c 03 c0       	push   $0xc0038c20
c002c0f4:	e8 d9 66 ff ff       	call   c00227d2 <sema_down>
c002c0f9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++)
c002c0fc:	ff 45 f4             	incl   -0xc(%ebp)
c002c0ff:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c103:	7e e7                	jle    c002c0ec <test_alarm_priority+0xca>
}
c002c105:	90                   	nop
c002c106:	c9                   	leave  
c002c107:	c3                   	ret    

c002c108 <alarm_priority_thread>:

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002c108:	55                   	push   %ebp
c002c109:	89 e5                	mov    %esp,%ebp
c002c10b:	56                   	push   %esi
c002c10c:	53                   	push   %ebx
c002c10d:	83 ec 10             	sub    $0x10,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002c110:	e8 89 7b ff ff       	call   c0023c9e <timer_ticks>
c002c115:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c118:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) == 0)
c002c11b:	eb 01                	jmp    c002c11e <alarm_priority_thread+0x16>
    continue;
c002c11d:	90                   	nop
  while (timer_elapsed (start_time) == 0)
c002c11e:	83 ec 08             	sub    $0x8,%esp
c002c121:	ff 75 f4             	pushl  -0xc(%ebp)
c002c124:	ff 75 f0             	pushl  -0x10(%ebp)
c002c127:	e8 a7 7b ff ff       	call   c0023cd3 <timer_elapsed>
c002c12c:	83 c4 10             	add    $0x10,%esp
c002c12f:	89 c1                	mov    %eax,%ecx
c002c131:	80 f5 00             	xor    $0x0,%ch
c002c134:	89 cb                	mov    %ecx,%ebx
c002c136:	89 d0                	mov    %edx,%eax
c002c138:	80 f4 00             	xor    $0x0,%ah
c002c13b:	89 c6                	mov    %eax,%esi
c002c13d:	89 f0                	mov    %esi,%eax
c002c13f:	09 d8                	or     %ebx,%eax
c002c141:	85 c0                	test   %eax,%eax
c002c143:	74 d8                	je     c002c11d <alarm_priority_thread+0x15>

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002c145:	8b 1d 18 8c 03 c0    	mov    0xc0038c18,%ebx
c002c14b:	8b 35 1c 8c 03 c0    	mov    0xc0038c1c,%esi
c002c151:	e8 48 7b ff ff       	call   c0023c9e <timer_ticks>
c002c156:	29 c3                	sub    %eax,%ebx
c002c158:	19 d6                	sbb    %edx,%esi
c002c15a:	89 d8                	mov    %ebx,%eax
c002c15c:	89 f2                	mov    %esi,%edx
c002c15e:	83 ec 08             	sub    $0x8,%esp
c002c161:	52                   	push   %edx
c002c162:	50                   	push   %eax
c002c163:	e8 8a 7b ff ff       	call   c0023cf2 <timer_sleep>
c002c168:	83 c4 10             	add    $0x10,%esp

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002c16b:	e8 e3 4a ff ff       	call   c0020c53 <thread_name>
c002c170:	83 ec 08             	sub    $0x8,%esp
c002c173:	50                   	push   %eax
c002c174:	68 bd 18 03 c0       	push   $0xc00318bd
c002c179:	e8 45 f7 ff ff       	call   c002b8c3 <msg>
c002c17e:	83 c4 10             	add    $0x10,%esp

  sema_up (&wait_sema);
c002c181:	83 ec 0c             	sub    $0xc,%esp
c002c184:	68 20 8c 03 c0       	push   $0xc0038c20
c002c189:	e8 4e 67 ff ff       	call   c00228dc <sema_up>
c002c18e:	83 c4 10             	add    $0x10,%esp
}
c002c191:	90                   	nop
c002c192:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002c195:	5b                   	pop    %ebx
c002c196:	5e                   	pop    %esi
c002c197:	5d                   	pop    %ebp
c002c198:	c3                   	ret    

c002c199 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002c199:	55                   	push   %ebp
c002c19a:	89 e5                	mov    %esp,%ebp
c002c19c:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (0);
c002c19f:	83 ec 08             	sub    $0x8,%esp
c002c1a2:	6a 00                	push   $0x0
c002c1a4:	6a 00                	push   $0x0
c002c1a6:	e8 47 7b ff ff       	call   c0023cf2 <timer_sleep>
c002c1ab:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c1ae:	e8 ab f7 ff ff       	call   c002b95e <pass>
}
c002c1b3:	90                   	nop
c002c1b4:	c9                   	leave  
c002c1b5:	c3                   	ret    

c002c1b6 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002c1b6:	55                   	push   %ebp
c002c1b7:	89 e5                	mov    %esp,%ebp
c002c1b9:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (-100);
c002c1bc:	83 ec 08             	sub    $0x8,%esp
c002c1bf:	6a ff                	push   $0xffffffff
c002c1c1:	6a 9c                	push   $0xffffff9c
c002c1c3:	e8 2a 7b ff ff       	call   c0023cf2 <timer_sleep>
c002c1c8:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c1cb:	e8 8e f7 ff ff       	call   c002b95e <pass>
}
c002c1d0:	90                   	nop
c002c1d1:	c9                   	leave  
c002c1d2:	c3                   	ret    

c002c1d3 <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c002c1d3:	55                   	push   %ebp
c002c1d4:	89 e5                	mov    %esp,%ebp
c002c1d6:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c1d9:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002c1de:	83 f0 01             	xor    $0x1,%eax
c002c1e1:	84 c0                	test   %al,%al
c002c1e3:	75 1e                	jne    c002c203 <test_priority_change+0x30>
c002c1e5:	83 ec 0c             	sub    $0xc,%esp
c002c1e8:	68 e4 18 03 c0       	push   $0xc00318e4
c002c1ed:	68 f2 18 03 c0       	push   $0xc00318f2
c002c1f2:	68 e8 19 03 c0       	push   $0xc00319e8
c002c1f7:	6a 10                	push   $0x10
c002c1f9:	68 0c 19 03 c0       	push   $0xc003190c
c002c1fe:	e8 25 d3 ff ff       	call   c0029528 <debug_panic>

  msg ("Creating a high-priority thread 2.");
c002c203:	83 ec 0c             	sub    $0xc,%esp
c002c206:	68 34 19 03 c0       	push   $0xc0031934
c002c20b:	e8 b3 f6 ff ff       	call   c002b8c3 <msg>
c002c210:	83 c4 10             	add    $0x10,%esp
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002c213:	6a 00                	push   $0x0
c002c215:	68 59 c2 02 c0       	push   $0xc002c259
c002c21a:	6a 20                	push   $0x20
c002c21c:	68 57 19 03 c0       	push   $0xc0031957
c002c221:	e8 24 48 ff ff       	call   c0020a4a <thread_create>
c002c226:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just lowered its priority.");
c002c229:	83 ec 0c             	sub    $0xc,%esp
c002c22c:	68 60 19 03 c0       	push   $0xc0031960
c002c231:	e8 8d f6 ff ff       	call   c002b8c3 <msg>
c002c236:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 2);
c002c239:	83 ec 0c             	sub    $0xc,%esp
c002c23c:	6a 1d                	push   $0x1d
c002c23e:	e8 25 4c ff ff       	call   c0020e68 <thread_set_priority>
c002c243:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just exited.");
c002c246:	83 ec 0c             	sub    $0xc,%esp
c002c249:	68 90 19 03 c0       	push   $0xc0031990
c002c24e:	e8 70 f6 ff ff       	call   c002b8c3 <msg>
c002c253:	83 c4 10             	add    $0x10,%esp
}
c002c256:	90                   	nop
c002c257:	c9                   	leave  
c002c258:	c3                   	ret    

c002c259 <changing_thread>:

static void
changing_thread (void *aux UNUSED) 
{
c002c259:	55                   	push   %ebp
c002c25a:	89 e5                	mov    %esp,%ebp
c002c25c:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread 2 now lowering priority.");
c002c25f:	83 ec 0c             	sub    $0xc,%esp
c002c262:	68 b4 19 03 c0       	push   $0xc00319b4
c002c267:	e8 57 f6 ff ff       	call   c002b8c3 <msg>
c002c26c:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 1);
c002c26f:	83 ec 0c             	sub    $0xc,%esp
c002c272:	6a 1e                	push   $0x1e
c002c274:	e8 ef 4b ff ff       	call   c0020e68 <thread_set_priority>
c002c279:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 exiting.");
c002c27c:	83 ec 0c             	sub    $0xc,%esp
c002c27f:	68 d4 19 03 c0       	push   $0xc00319d4
c002c284:	e8 3a f6 ff ff       	call   c002b8c3 <msg>
c002c289:	83 c4 10             	add    $0x10,%esp
}
c002c28c:	90                   	nop
c002c28d:	c9                   	leave  
c002c28e:	c3                   	ret    

c002c28f <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002c28f:	55                   	push   %ebp
c002c290:	89 e5                	mov    %esp,%ebp
c002c292:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c295:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002c29a:	83 f0 01             	xor    $0x1,%eax
c002c29d:	84 c0                	test   %al,%al
c002c29f:	75 1e                	jne    c002c2bf <test_priority_donate_one+0x30>
c002c2a1:	83 ec 0c             	sub    $0xc,%esp
c002c2a4:	68 00 1a 03 c0       	push   $0xc0031a00
c002c2a9:	68 0e 1a 03 c0       	push   $0xc0031a0e
c002c2ae:	68 90 1b 03 c0       	push   $0xc0031b90
c002c2b3:	6a 1b                	push   $0x1b
c002c2b5:	68 28 1a 03 c0       	push   $0xc0031a28
c002c2ba:	e8 69 d2 ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c2bf:	e8 b8 4b ff ff       	call   c0020e7c <thread_get_priority>
c002c2c4:	83 f8 1f             	cmp    $0x1f,%eax
c002c2c7:	74 1e                	je     c002c2e7 <test_priority_donate_one+0x58>
c002c2c9:	83 ec 0c             	sub    $0xc,%esp
c002c2cc:	68 54 1a 03 c0       	push   $0xc0031a54
c002c2d1:	68 0e 1a 03 c0       	push   $0xc0031a0e
c002c2d6:	68 90 1b 03 c0       	push   $0xc0031b90
c002c2db:	6a 1e                	push   $0x1e
c002c2dd:	68 28 1a 03 c0       	push   $0xc0031a28
c002c2e2:	e8 41 d2 ff ff       	call   c0029528 <debug_panic>

  lock_init (&lock);
c002c2e7:	83 ec 0c             	sub    $0xc,%esp
c002c2ea:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c2ed:	50                   	push   %eax
c002c2ee:	e8 50 67 ff ff       	call   c0022a43 <lock_init>
c002c2f3:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002c2f6:	83 ec 0c             	sub    $0xc,%esp
c002c2f9:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c2fc:	50                   	push   %eax
c002c2fd:	e8 8e 67 ff ff       	call   c0022a90 <lock_acquire>
c002c302:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002c305:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c308:	50                   	push   %eax
c002c309:	68 97 c3 02 c0       	push   $0xc002c397
c002c30e:	6a 20                	push   $0x20
c002c310:	68 7a 1a 03 c0       	push   $0xc0031a7a
c002c315:	e8 30 47 ff ff       	call   c0020a4a <thread_create>
c002c31a:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c31d:	e8 5a 4b ff ff       	call   c0020e7c <thread_get_priority>
c002c322:	83 ec 04             	sub    $0x4,%esp
c002c325:	50                   	push   %eax
c002c326:	6a 20                	push   $0x20
c002c328:	68 84 1a 03 c0       	push   $0xc0031a84
c002c32d:	e8 91 f5 ff ff       	call   c002b8c3 <msg>
c002c332:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002c335:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c338:	50                   	push   %eax
c002c339:	68 e2 c3 02 c0       	push   $0xc002c3e2
c002c33e:	6a 21                	push   $0x21
c002c340:	68 bf 1a 03 c0       	push   $0xc0031abf
c002c345:	e8 00 47 ff ff       	call   c0020a4a <thread_create>
c002c34a:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002c34d:	e8 2a 4b ff ff       	call   c0020e7c <thread_get_priority>
c002c352:	83 ec 04             	sub    $0x4,%esp
c002c355:	50                   	push   %eax
c002c356:	6a 21                	push   $0x21
c002c358:	68 84 1a 03 c0       	push   $0xc0031a84
c002c35d:	e8 61 f5 ff ff       	call   c002b8c3 <msg>
c002c362:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002c365:	83 ec 0c             	sub    $0xc,%esp
c002c368:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c36b:	50                   	push   %eax
c002c36c:	e8 5f 68 ff ff       	call   c0022bd0 <lock_release>
c002c371:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002c374:	83 ec 0c             	sub    $0xc,%esp
c002c377:	68 c8 1a 03 c0       	push   $0xc0031ac8
c002c37c:	e8 42 f5 ff ff       	call   c002b8c3 <msg>
c002c381:	83 c4 10             	add    $0x10,%esp
  msg ("This should be the last line before finishing this test.");
c002c384:	83 ec 0c             	sub    $0xc,%esp
c002c387:	68 08 1b 03 c0       	push   $0xc0031b08
c002c38c:	e8 32 f5 ff ff       	call   c002b8c3 <msg>
c002c391:	83 c4 10             	add    $0x10,%esp
}
c002c394:	90                   	nop
c002c395:	c9                   	leave  
c002c396:	c3                   	ret    

c002c397 <acquire1_thread_func>:

static void
acquire1_thread_func (void *lock_) 
{
c002c397:	55                   	push   %ebp
c002c398:	89 e5                	mov    %esp,%ebp
c002c39a:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c39d:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3a0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c3a3:	83 ec 0c             	sub    $0xc,%esp
c002c3a6:	ff 75 f4             	pushl  -0xc(%ebp)
c002c3a9:	e8 e2 66 ff ff       	call   c0022a90 <lock_acquire>
c002c3ae:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: got the lock");
c002c3b1:	83 ec 0c             	sub    $0xc,%esp
c002c3b4:	68 41 1b 03 c0       	push   $0xc0031b41
c002c3b9:	e8 05 f5 ff ff       	call   c002b8c3 <msg>
c002c3be:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c3c1:	83 ec 0c             	sub    $0xc,%esp
c002c3c4:	ff 75 f4             	pushl  -0xc(%ebp)
c002c3c7:	e8 04 68 ff ff       	call   c0022bd0 <lock_release>
c002c3cc:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: done");
c002c3cf:	83 ec 0c             	sub    $0xc,%esp
c002c3d2:	68 58 1b 03 c0       	push   $0xc0031b58
c002c3d7:	e8 e7 f4 ff ff       	call   c002b8c3 <msg>
c002c3dc:	83 c4 10             	add    $0x10,%esp
}
c002c3df:	90                   	nop
c002c3e0:	c9                   	leave  
c002c3e1:	c3                   	ret    

c002c3e2 <acquire2_thread_func>:

static void
acquire2_thread_func (void *lock_) 
{
c002c3e2:	55                   	push   %ebp
c002c3e3:	89 e5                	mov    %esp,%ebp
c002c3e5:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c3e8:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3eb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c3ee:	83 ec 0c             	sub    $0xc,%esp
c002c3f1:	ff 75 f4             	pushl  -0xc(%ebp)
c002c3f4:	e8 97 66 ff ff       	call   c0022a90 <lock_acquire>
c002c3f9:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: got the lock");
c002c3fc:	83 ec 0c             	sub    $0xc,%esp
c002c3ff:	68 67 1b 03 c0       	push   $0xc0031b67
c002c404:	e8 ba f4 ff ff       	call   c002b8c3 <msg>
c002c409:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c40c:	83 ec 0c             	sub    $0xc,%esp
c002c40f:	ff 75 f4             	pushl  -0xc(%ebp)
c002c412:	e8 b9 67 ff ff       	call   c0022bd0 <lock_release>
c002c417:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: done");
c002c41a:	83 ec 0c             	sub    $0xc,%esp
c002c41d:	68 7e 1b 03 c0       	push   $0xc0031b7e
c002c422:	e8 9c f4 ff ff       	call   c002b8c3 <msg>
c002c427:	83 c4 10             	add    $0x10,%esp
}
c002c42a:	90                   	nop
c002c42b:	c9                   	leave  
c002c42c:	c3                   	ret    

c002c42d <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002c42d:	55                   	push   %ebp
c002c42e:	89 e5                	mov    %esp,%ebp
c002c430:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c433:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002c438:	83 f0 01             	xor    $0x1,%eax
c002c43b:	84 c0                	test   %al,%al
c002c43d:	75 1e                	jne    c002c45d <test_priority_donate_multiple+0x30>
c002c43f:	83 ec 0c             	sub    $0xc,%esp
c002c442:	68 ac 1b 03 c0       	push   $0xc0031bac
c002c447:	68 ba 1b 03 c0       	push   $0xc0031bba
c002c44c:	68 10 1d 03 c0       	push   $0xc0031d10
c002c451:	6a 1b                	push   $0x1b
c002c453:	68 d4 1b 03 c0       	push   $0xc0031bd4
c002c458:	e8 cb d0 ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c45d:	e8 1a 4a ff ff       	call   c0020e7c <thread_get_priority>
c002c462:	83 f8 1f             	cmp    $0x1f,%eax
c002c465:	74 1e                	je     c002c485 <test_priority_donate_multiple+0x58>
c002c467:	83 ec 0c             	sub    $0xc,%esp
c002c46a:	68 04 1c 03 c0       	push   $0xc0031c04
c002c46f:	68 ba 1b 03 c0       	push   $0xc0031bba
c002c474:	68 10 1d 03 c0       	push   $0xc0031d10
c002c479:	6a 1e                	push   $0x1e
c002c47b:	68 d4 1b 03 c0       	push   $0xc0031bd4
c002c480:	e8 a3 d0 ff ff       	call   c0029528 <debug_panic>

  lock_init (&a);
c002c485:	83 ec 0c             	sub    $0xc,%esp
c002c488:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c48b:	50                   	push   %eax
c002c48c:	e8 b2 65 ff ff       	call   c0022a43 <lock_init>
c002c491:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c494:	83 ec 0c             	sub    $0xc,%esp
c002c497:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c49a:	50                   	push   %eax
c002c49b:	e8 a3 65 ff ff       	call   c0022a43 <lock_init>
c002c4a0:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c4a3:	83 ec 0c             	sub    $0xc,%esp
c002c4a6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c4a9:	50                   	push   %eax
c002c4aa:	e8 e1 65 ff ff       	call   c0022a90 <lock_acquire>
c002c4af:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c4b2:	83 ec 0c             	sub    $0xc,%esp
c002c4b5:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c4b8:	50                   	push   %eax
c002c4b9:	e8 d2 65 ff ff       	call   c0022a90 <lock_acquire>
c002c4be:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002c4c1:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c4c4:	50                   	push   %eax
c002c4c5:	68 92 c5 02 c0       	push   $0xc002c592
c002c4ca:	6a 20                	push   $0x20
c002c4cc:	68 2a 1c 03 c0       	push   $0xc0031c2a
c002c4d1:	e8 74 45 ff ff       	call   c0020a4a <thread_create>
c002c4d6:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c4d9:	e8 9e 49 ff ff       	call   c0020e7c <thread_get_priority>
c002c4de:	83 ec 04             	sub    $0x4,%esp
c002c4e1:	50                   	push   %eax
c002c4e2:	6a 20                	push   $0x20
c002c4e4:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c4e9:	e8 d5 f3 ff ff       	call   c002b8c3 <msg>
c002c4ee:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002c4f1:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c4f4:	50                   	push   %eax
c002c4f5:	68 dd c5 02 c0       	push   $0xc002c5dd
c002c4fa:	6a 21                	push   $0x21
c002c4fc:	68 67 1c 03 c0       	push   $0xc0031c67
c002c501:	e8 44 45 ff ff       	call   c0020a4a <thread_create>
c002c506:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c509:	e8 6e 49 ff ff       	call   c0020e7c <thread_get_priority>
c002c50e:	83 ec 04             	sub    $0x4,%esp
c002c511:	50                   	push   %eax
c002c512:	6a 21                	push   $0x21
c002c514:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c519:	e8 a5 f3 ff ff       	call   c002b8c3 <msg>
c002c51e:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002c521:	83 ec 0c             	sub    $0xc,%esp
c002c524:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c527:	50                   	push   %eax
c002c528:	e8 a3 66 ff ff       	call   c0022bd0 <lock_release>
c002c52d:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b should have just finished.");
c002c530:	83 ec 0c             	sub    $0xc,%esp
c002c533:	68 6c 1c 03 c0       	push   $0xc0031c6c
c002c538:	e8 86 f3 ff ff       	call   c002b8c3 <msg>
c002c53d:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c540:	e8 37 49 ff ff       	call   c0020e7c <thread_get_priority>
c002c545:	83 ec 04             	sub    $0x4,%esp
c002c548:	50                   	push   %eax
c002c549:	6a 20                	push   $0x20
c002c54b:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c550:	e8 6e f3 ff ff       	call   c002b8c3 <msg>
c002c555:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002c558:	83 ec 0c             	sub    $0xc,%esp
c002c55b:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c55e:	50                   	push   %eax
c002c55f:	e8 6c 66 ff ff       	call   c0022bd0 <lock_release>
c002c564:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a should have just finished.");
c002c567:	83 ec 0c             	sub    $0xc,%esp
c002c56a:	68 90 1c 03 c0       	push   $0xc0031c90
c002c56f:	e8 4f f3 ff ff       	call   c002b8c3 <msg>
c002c574:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c577:	e8 00 49 ff ff       	call   c0020e7c <thread_get_priority>
c002c57c:	83 ec 04             	sub    $0x4,%esp
c002c57f:	50                   	push   %eax
c002c580:	6a 1f                	push   $0x1f
c002c582:	68 2c 1c 03 c0       	push   $0xc0031c2c
c002c587:	e8 37 f3 ff ff       	call   c002b8c3 <msg>
c002c58c:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c58f:	90                   	nop
c002c590:	c9                   	leave  
c002c591:	c3                   	ret    

c002c592 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c592:	55                   	push   %ebp
c002c593:	89 e5                	mov    %esp,%ebp
c002c595:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c598:	8b 45 08             	mov    0x8(%ebp),%eax
c002c59b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c59e:	83 ec 0c             	sub    $0xc,%esp
c002c5a1:	ff 75 f4             	pushl  -0xc(%ebp)
c002c5a4:	e8 e7 64 ff ff       	call   c0022a90 <lock_acquire>
c002c5a9:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002c5ac:	83 ec 0c             	sub    $0xc,%esp
c002c5af:	68 b4 1c 03 c0       	push   $0xc0031cb4
c002c5b4:	e8 0a f3 ff ff       	call   c002b8c3 <msg>
c002c5b9:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c5bc:	83 ec 0c             	sub    $0xc,%esp
c002c5bf:	ff 75 f4             	pushl  -0xc(%ebp)
c002c5c2:	e8 09 66 ff ff       	call   c0022bd0 <lock_release>
c002c5c7:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002c5ca:	83 ec 0c             	sub    $0xc,%esp
c002c5cd:	68 ce 1c 03 c0       	push   $0xc0031cce
c002c5d2:	e8 ec f2 ff ff       	call   c002b8c3 <msg>
c002c5d7:	83 c4 10             	add    $0x10,%esp
}
c002c5da:	90                   	nop
c002c5db:	c9                   	leave  
c002c5dc:	c3                   	ret    

c002c5dd <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002c5dd:	55                   	push   %ebp
c002c5de:	89 e5                	mov    %esp,%ebp
c002c5e0:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c5e3:	8b 45 08             	mov    0x8(%ebp),%eax
c002c5e6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c5e9:	83 ec 0c             	sub    $0xc,%esp
c002c5ec:	ff 75 f4             	pushl  -0xc(%ebp)
c002c5ef:	e8 9c 64 ff ff       	call   c0022a90 <lock_acquire>
c002c5f4:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002c5f7:	83 ec 0c             	sub    $0xc,%esp
c002c5fa:	68 e1 1c 03 c0       	push   $0xc0031ce1
c002c5ff:	e8 bf f2 ff ff       	call   c002b8c3 <msg>
c002c604:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c607:	83 ec 0c             	sub    $0xc,%esp
c002c60a:	ff 75 f4             	pushl  -0xc(%ebp)
c002c60d:	e8 be 65 ff ff       	call   c0022bd0 <lock_release>
c002c612:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002c615:	83 ec 0c             	sub    $0xc,%esp
c002c618:	68 fb 1c 03 c0       	push   $0xc0031cfb
c002c61d:	e8 a1 f2 ff ff       	call   c002b8c3 <msg>
c002c622:	83 c4 10             	add    $0x10,%esp
}
c002c625:	90                   	nop
c002c626:	c9                   	leave  
c002c627:	c3                   	ret    

c002c628 <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002c628:	55                   	push   %ebp
c002c629:	89 e5                	mov    %esp,%ebp
c002c62b:	83 ec 38             	sub    $0x38,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c62e:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002c633:	83 f0 01             	xor    $0x1,%eax
c002c636:	84 c0                	test   %al,%al
c002c638:	75 1e                	jne    c002c658 <test_priority_donate_multiple2+0x30>
c002c63a:	83 ec 0c             	sub    $0xc,%esp
c002c63d:	68 30 1d 03 c0       	push   $0xc0031d30
c002c642:	68 3e 1d 03 c0       	push   $0xc0031d3e
c002c647:	68 98 1e 03 c0       	push   $0xc0031e98
c002c64c:	6a 21                	push   $0x21
c002c64e:	68 58 1d 03 c0       	push   $0xc0031d58
c002c653:	e8 d0 ce ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c658:	e8 1f 48 ff ff       	call   c0020e7c <thread_get_priority>
c002c65d:	83 f8 1f             	cmp    $0x1f,%eax
c002c660:	74 1e                	je     c002c680 <test_priority_donate_multiple2+0x58>
c002c662:	83 ec 0c             	sub    $0xc,%esp
c002c665:	68 88 1d 03 c0       	push   $0xc0031d88
c002c66a:	68 3e 1d 03 c0       	push   $0xc0031d3e
c002c66f:	68 98 1e 03 c0       	push   $0xc0031e98
c002c674:	6a 24                	push   $0x24
c002c676:	68 58 1d 03 c0       	push   $0xc0031d58
c002c67b:	e8 a8 ce ff ff       	call   c0029528 <debug_panic>

  lock_init (&a);
c002c680:	83 ec 0c             	sub    $0xc,%esp
c002c683:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c686:	50                   	push   %eax
c002c687:	e8 b7 63 ff ff       	call   c0022a43 <lock_init>
c002c68c:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c68f:	83 ec 0c             	sub    $0xc,%esp
c002c692:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c695:	50                   	push   %eax
c002c696:	e8 a8 63 ff ff       	call   c0022a43 <lock_init>
c002c69b:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c69e:	83 ec 0c             	sub    $0xc,%esp
c002c6a1:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c6a4:	50                   	push   %eax
c002c6a5:	e8 e6 63 ff ff       	call   c0022a90 <lock_acquire>
c002c6aa:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002c6ad:	83 ec 0c             	sub    $0xc,%esp
c002c6b0:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c6b3:	50                   	push   %eax
c002c6b4:	e8 d7 63 ff ff       	call   c0022a90 <lock_acquire>
c002c6b9:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002c6bc:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c6bf:	50                   	push   %eax
c002c6c0:	68 93 c7 02 c0       	push   $0xc002c793
c002c6c5:	6a 22                	push   $0x22
c002c6c7:	68 ae 1d 03 c0       	push   $0xc0031dae
c002c6cc:	e8 79 43 ff ff       	call   c0020a4a <thread_create>
c002c6d1:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c6d4:	e8 a3 47 ff ff       	call   c0020e7c <thread_get_priority>
c002c6d9:	83 ec 04             	sub    $0x4,%esp
c002c6dc:	50                   	push   %eax
c002c6dd:	6a 22                	push   $0x22
c002c6df:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c6e4:	e8 da f1 ff ff       	call   c002b8c3 <msg>
c002c6e9:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002c6ec:	6a 00                	push   $0x0
c002c6ee:	68 29 c8 02 c0       	push   $0xc002c829
c002c6f3:	6a 20                	push   $0x20
c002c6f5:	68 eb 1d 03 c0       	push   $0xc0031deb
c002c6fa:	e8 4b 43 ff ff       	call   c0020a4a <thread_create>
c002c6ff:	83 c4 10             	add    $0x10,%esp

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002c702:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c705:	50                   	push   %eax
c002c706:	68 de c7 02 c0       	push   $0xc002c7de
c002c70b:	6a 24                	push   $0x24
c002c70d:	68 ed 1d 03 c0       	push   $0xc0031ded
c002c712:	e8 33 43 ff ff       	call   c0020a4a <thread_create>
c002c717:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c71a:	e8 5d 47 ff ff       	call   c0020e7c <thread_get_priority>
c002c71f:	83 ec 04             	sub    $0x4,%esp
c002c722:	50                   	push   %eax
c002c723:	6a 24                	push   $0x24
c002c725:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c72a:	e8 94 f1 ff ff       	call   c002b8c3 <msg>
c002c72f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002c732:	83 ec 0c             	sub    $0xc,%esp
c002c735:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c738:	50                   	push   %eax
c002c739:	e8 92 64 ff ff       	call   c0022bd0 <lock_release>
c002c73e:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c741:	e8 36 47 ff ff       	call   c0020e7c <thread_get_priority>
c002c746:	83 ec 04             	sub    $0x4,%esp
c002c749:	50                   	push   %eax
c002c74a:	6a 24                	push   $0x24
c002c74c:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c751:	e8 6d f1 ff ff       	call   c002b8c3 <msg>
c002c756:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002c759:	83 ec 0c             	sub    $0xc,%esp
c002c75c:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c75f:	50                   	push   %eax
c002c760:	e8 6b 64 ff ff       	call   c0022bd0 <lock_release>
c002c765:	83 c4 10             	add    $0x10,%esp
  msg ("Threads b, a, c should have just finished, in that order.");
c002c768:	83 ec 0c             	sub    $0xc,%esp
c002c76b:	68 f0 1d 03 c0       	push   $0xc0031df0
c002c770:	e8 4e f1 ff ff       	call   c002b8c3 <msg>
c002c775:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002c778:	e8 ff 46 ff ff       	call   c0020e7c <thread_get_priority>
c002c77d:	83 ec 04             	sub    $0x4,%esp
c002c780:	50                   	push   %eax
c002c781:	6a 1f                	push   $0x1f
c002c783:	68 b0 1d 03 c0       	push   $0xc0031db0
c002c788:	e8 36 f1 ff ff       	call   c002b8c3 <msg>
c002c78d:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c790:	90                   	nop
c002c791:	c9                   	leave  
c002c792:	c3                   	ret    

c002c793 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002c793:	55                   	push   %ebp
c002c794:	89 e5                	mov    %esp,%ebp
c002c796:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c799:	8b 45 08             	mov    0x8(%ebp),%eax
c002c79c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c79f:	83 ec 0c             	sub    $0xc,%esp
c002c7a2:	ff 75 f4             	pushl  -0xc(%ebp)
c002c7a5:	e8 e6 62 ff ff       	call   c0022a90 <lock_acquire>
c002c7aa:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002c7ad:	83 ec 0c             	sub    $0xc,%esp
c002c7b0:	68 2a 1e 03 c0       	push   $0xc0031e2a
c002c7b5:	e8 09 f1 ff ff       	call   c002b8c3 <msg>
c002c7ba:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c7bd:	83 ec 0c             	sub    $0xc,%esp
c002c7c0:	ff 75 f4             	pushl  -0xc(%ebp)
c002c7c3:	e8 08 64 ff ff       	call   c0022bd0 <lock_release>
c002c7c8:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002c7cb:	83 ec 0c             	sub    $0xc,%esp
c002c7ce:	68 44 1e 03 c0       	push   $0xc0031e44
c002c7d3:	e8 eb f0 ff ff       	call   c002b8c3 <msg>
c002c7d8:	83 c4 10             	add    $0x10,%esp
}
c002c7db:	90                   	nop
c002c7dc:	c9                   	leave  
c002c7dd:	c3                   	ret    

c002c7de <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002c7de:	55                   	push   %ebp
c002c7df:	89 e5                	mov    %esp,%ebp
c002c7e1:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002c7e4:	8b 45 08             	mov    0x8(%ebp),%eax
c002c7e7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002c7ea:	83 ec 0c             	sub    $0xc,%esp
c002c7ed:	ff 75 f4             	pushl  -0xc(%ebp)
c002c7f0:	e8 9b 62 ff ff       	call   c0022a90 <lock_acquire>
c002c7f5:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002c7f8:	83 ec 0c             	sub    $0xc,%esp
c002c7fb:	68 57 1e 03 c0       	push   $0xc0031e57
c002c800:	e8 be f0 ff ff       	call   c002b8c3 <msg>
c002c805:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002c808:	83 ec 0c             	sub    $0xc,%esp
c002c80b:	ff 75 f4             	pushl  -0xc(%ebp)
c002c80e:	e8 bd 63 ff ff       	call   c0022bd0 <lock_release>
c002c813:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002c816:	83 ec 0c             	sub    $0xc,%esp
c002c819:	68 71 1e 03 c0       	push   $0xc0031e71
c002c81e:	e8 a0 f0 ff ff       	call   c002b8c3 <msg>
c002c823:	83 c4 10             	add    $0x10,%esp
}
c002c826:	90                   	nop
c002c827:	c9                   	leave  
c002c828:	c3                   	ret    

c002c829 <c_thread_func>:

static void
c_thread_func (void *a_ UNUSED) 
{
c002c829:	55                   	push   %ebp
c002c82a:	89 e5                	mov    %esp,%ebp
c002c82c:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread c finished.");
c002c82f:	83 ec 0c             	sub    $0xc,%esp
c002c832:	68 84 1e 03 c0       	push   $0xc0031e84
c002c837:	e8 87 f0 ff ff       	call   c002b8c3 <msg>
c002c83c:	83 c4 10             	add    $0x10,%esp
}
c002c83f:	90                   	nop
c002c840:	c9                   	leave  
c002c841:	c3                   	ret    

c002c842 <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002c842:	55                   	push   %ebp
c002c843:	89 e5                	mov    %esp,%ebp
c002c845:	83 ec 48             	sub    $0x48,%esp
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c848:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002c84d:	83 f0 01             	xor    $0x1,%eax
c002c850:	84 c0                	test   %al,%al
c002c852:	75 1e                	jne    c002c872 <test_priority_donate_nest+0x30>
c002c854:	83 ec 0c             	sub    $0xc,%esp
c002c857:	68 b8 1e 03 c0       	push   $0xc0031eb8
c002c85c:	68 c6 1e 03 c0       	push   $0xc0031ec6
c002c861:	68 74 20 03 c0       	push   $0xc0032074
c002c866:	6a 22                	push   $0x22
c002c868:	68 e0 1e 03 c0       	push   $0xc0031ee0
c002c86d:	e8 b6 cc ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c872:	e8 05 46 ff ff       	call   c0020e7c <thread_get_priority>
c002c877:	83 f8 1f             	cmp    $0x1f,%eax
c002c87a:	74 1e                	je     c002c89a <test_priority_donate_nest+0x58>
c002c87c:	83 ec 0c             	sub    $0xc,%esp
c002c87f:	68 0c 1f 03 c0       	push   $0xc0031f0c
c002c884:	68 c6 1e 03 c0       	push   $0xc0031ec6
c002c889:	68 74 20 03 c0       	push   $0xc0032074
c002c88e:	6a 25                	push   $0x25
c002c890:	68 e0 1e 03 c0       	push   $0xc0031ee0
c002c895:	e8 8e cc ff ff       	call   c0029528 <debug_panic>

  lock_init (&a);
c002c89a:	83 ec 0c             	sub    $0xc,%esp
c002c89d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c8a0:	50                   	push   %eax
c002c8a1:	e8 9d 61 ff ff       	call   c0022a43 <lock_init>
c002c8a6:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002c8a9:	83 ec 0c             	sub    $0xc,%esp
c002c8ac:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c8af:	50                   	push   %eax
c002c8b0:	e8 8e 61 ff ff       	call   c0022a43 <lock_init>
c002c8b5:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002c8b8:	83 ec 0c             	sub    $0xc,%esp
c002c8bb:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c8be:	50                   	push   %eax
c002c8bf:	e8 cc 61 ff ff       	call   c0022a90 <lock_acquire>
c002c8c4:	83 c4 10             	add    $0x10,%esp

  locks.a = &a;
c002c8c7:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c8ca:	89 45 c0             	mov    %eax,-0x40(%ebp)
  locks.b = &b;
c002c8cd:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c8d0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002c8d3:	8d 45 c0             	lea    -0x40(%ebp),%eax
c002c8d6:	50                   	push   %eax
c002c8d7:	68 7c c9 02 c0       	push   $0xc002c97c
c002c8dc:	6a 20                	push   $0x20
c002c8de:	68 32 1f 03 c0       	push   $0xc0031f32
c002c8e3:	e8 62 41 ff ff       	call   c0020a4a <thread_create>
c002c8e8:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c8eb:	e8 69 44 ff ff       	call   c0020d59 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c8f0:	e8 87 45 ff ff       	call   c0020e7c <thread_get_priority>
c002c8f5:	83 ec 04             	sub    $0x4,%esp
c002c8f8:	50                   	push   %eax
c002c8f9:	6a 20                	push   $0x20
c002c8fb:	68 3c 1f 03 c0       	push   $0xc0031f3c
c002c900:	e8 be ef ff ff       	call   c002b8c3 <msg>
c002c905:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002c908:	8d 45 c8             	lea    -0x38(%ebp),%eax
c002c90b:	50                   	push   %eax
c002c90c:	68 23 ca 02 c0       	push   $0xc002ca23
c002c911:	6a 21                	push   $0x21
c002c913:	68 76 1f 03 c0       	push   $0xc0031f76
c002c918:	e8 2d 41 ff ff       	call   c0020a4a <thread_create>
c002c91d:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c920:	e8 34 44 ff ff       	call   c0020d59 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c925:	e8 52 45 ff ff       	call   c0020e7c <thread_get_priority>
c002c92a:	83 ec 04             	sub    $0x4,%esp
c002c92d:	50                   	push   %eax
c002c92e:	6a 21                	push   $0x21
c002c930:	68 3c 1f 03 c0       	push   $0xc0031f3c
c002c935:	e8 89 ef ff ff       	call   c002b8c3 <msg>
c002c93a:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002c93d:	83 ec 0c             	sub    $0xc,%esp
c002c940:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c943:	50                   	push   %eax
c002c944:	e8 87 62 ff ff       	call   c0022bd0 <lock_release>
c002c949:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c94c:	e8 08 44 ff ff       	call   c0020d59 <thread_yield>
  msg ("Medium thread should just have finished.");
c002c951:	83 ec 0c             	sub    $0xc,%esp
c002c954:	68 7c 1f 03 c0       	push   $0xc0031f7c
c002c959:	e8 65 ef ff ff       	call   c002b8c3 <msg>
c002c95e:	83 c4 10             	add    $0x10,%esp
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002c961:	e8 16 45 ff ff       	call   c0020e7c <thread_get_priority>
c002c966:	83 ec 04             	sub    $0x4,%esp
c002c969:	50                   	push   %eax
c002c96a:	6a 1f                	push   $0x1f
c002c96c:	68 3c 1f 03 c0       	push   $0xc0031f3c
c002c971:	e8 4d ef ff ff       	call   c002b8c3 <msg>
c002c976:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002c979:	90                   	nop
c002c97a:	c9                   	leave  
c002c97b:	c3                   	ret    

c002c97c <medium_thread_func>:

static void
medium_thread_func (void *locks_) 
{
c002c97c:	55                   	push   %ebp
c002c97d:	89 e5                	mov    %esp,%ebp
c002c97f:	83 ec 18             	sub    $0x18,%esp
  struct locks *locks = locks_;
c002c982:	8b 45 08             	mov    0x8(%ebp),%eax
c002c985:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (locks->b);
c002c988:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c98b:	8b 40 04             	mov    0x4(%eax),%eax
c002c98e:	83 ec 0c             	sub    $0xc,%esp
c002c991:	50                   	push   %eax
c002c992:	e8 f9 60 ff ff       	call   c0022a90 <lock_acquire>
c002c997:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->a);
c002c99a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c99d:	8b 00                	mov    (%eax),%eax
c002c99f:	83 ec 0c             	sub    $0xc,%esp
c002c9a2:	50                   	push   %eax
c002c9a3:	e8 e8 60 ff ff       	call   c0022a90 <lock_acquire>
c002c9a8:	83 c4 10             	add    $0x10,%esp

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002c9ab:	e8 cc 44 ff ff       	call   c0020e7c <thread_get_priority>
c002c9b0:	83 ec 04             	sub    $0x4,%esp
c002c9b3:	50                   	push   %eax
c002c9b4:	6a 21                	push   $0x21
c002c9b6:	68 a8 1f 03 c0       	push   $0xc0031fa8
c002c9bb:	e8 03 ef ff ff       	call   c002b8c3 <msg>
c002c9c0:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002c9c3:	83 ec 0c             	sub    $0xc,%esp
c002c9c6:	68 e5 1f 03 c0       	push   $0xc0031fe5
c002c9cb:	e8 f3 ee ff ff       	call   c002b8c3 <msg>
c002c9d0:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->a);
c002c9d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c9d6:	8b 00                	mov    (%eax),%eax
c002c9d8:	83 ec 0c             	sub    $0xc,%esp
c002c9db:	50                   	push   %eax
c002c9dc:	e8 ef 61 ff ff       	call   c0022bd0 <lock_release>
c002c9e1:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c9e4:	e8 70 43 ff ff       	call   c0020d59 <thread_yield>

  lock_release (locks->b);
c002c9e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c9ec:	8b 40 04             	mov    0x4(%eax),%eax
c002c9ef:	83 ec 0c             	sub    $0xc,%esp
c002c9f2:	50                   	push   %eax
c002c9f3:	e8 d8 61 ff ff       	call   c0022bd0 <lock_release>
c002c9f8:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002c9fb:	e8 59 43 ff ff       	call   c0020d59 <thread_yield>

  msg ("High thread should have just finished.");
c002ca00:	83 ec 0c             	sub    $0xc,%esp
c002ca03:	68 04 20 03 c0       	push   $0xc0032004
c002ca08:	e8 b6 ee ff ff       	call   c002b8c3 <msg>
c002ca0d:	83 c4 10             	add    $0x10,%esp
  msg ("Middle thread finished.");
c002ca10:	83 ec 0c             	sub    $0xc,%esp
c002ca13:	68 2b 20 03 c0       	push   $0xc003202b
c002ca18:	e8 a6 ee ff ff       	call   c002b8c3 <msg>
c002ca1d:	83 c4 10             	add    $0x10,%esp
}
c002ca20:	90                   	nop
c002ca21:	c9                   	leave  
c002ca22:	c3                   	ret    

c002ca23 <high_thread_func>:

static void
high_thread_func (void *lock_) 
{
c002ca23:	55                   	push   %ebp
c002ca24:	89 e5                	mov    %esp,%ebp
c002ca26:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ca29:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca2c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ca2f:	83 ec 0c             	sub    $0xc,%esp
c002ca32:	ff 75 f4             	pushl  -0xc(%ebp)
c002ca35:	e8 56 60 ff ff       	call   c0022a90 <lock_acquire>
c002ca3a:	83 c4 10             	add    $0x10,%esp
  msg ("High thread got the lock.");
c002ca3d:	83 ec 0c             	sub    $0xc,%esp
c002ca40:	68 43 20 03 c0       	push   $0xc0032043
c002ca45:	e8 79 ee ff ff       	call   c002b8c3 <msg>
c002ca4a:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ca4d:	83 ec 0c             	sub    $0xc,%esp
c002ca50:	ff 75 f4             	pushl  -0xc(%ebp)
c002ca53:	e8 78 61 ff ff       	call   c0022bd0 <lock_release>
c002ca58:	83 c4 10             	add    $0x10,%esp
  msg ("High thread finished.");
c002ca5b:	83 ec 0c             	sub    $0xc,%esp
c002ca5e:	68 5d 20 03 c0       	push   $0xc003205d
c002ca63:	e8 5b ee ff ff       	call   c002b8c3 <msg>
c002ca68:	83 c4 10             	add    $0x10,%esp
}
c002ca6b:	90                   	nop
c002ca6c:	c9                   	leave  
c002ca6d:	c3                   	ret    

c002ca6e <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002ca6e:	55                   	push   %ebp
c002ca6f:	89 e5                	mov    %esp,%ebp
c002ca71:	83 ec 38             	sub    $0x38,%esp
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002ca74:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002ca79:	83 f0 01             	xor    $0x1,%eax
c002ca7c:	84 c0                	test   %al,%al
c002ca7e:	75 1e                	jne    c002ca9e <test_priority_donate_sema+0x30>
c002ca80:	83 ec 0c             	sub    $0xc,%esp
c002ca83:	68 90 20 03 c0       	push   $0xc0032090
c002ca88:	68 9e 20 03 c0       	push   $0xc003209e
c002ca8d:	68 b4 21 03 c0       	push   $0xc00321b4
c002ca92:	6a 23                	push   $0x23
c002ca94:	68 b8 20 03 c0       	push   $0xc00320b8
c002ca99:	e8 8a ca ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002ca9e:	e8 d9 43 ff ff       	call   c0020e7c <thread_get_priority>
c002caa3:	83 f8 1f             	cmp    $0x1f,%eax
c002caa6:	74 1e                	je     c002cac6 <test_priority_donate_sema+0x58>
c002caa8:	83 ec 0c             	sub    $0xc,%esp
c002caab:	68 e4 20 03 c0       	push   $0xc00320e4
c002cab0:	68 9e 20 03 c0       	push   $0xc003209e
c002cab5:	68 b4 21 03 c0       	push   $0xc00321b4
c002caba:	6a 26                	push   $0x26
c002cabc:	68 b8 20 03 c0       	push   $0xc00320b8
c002cac1:	e8 62 ca ff ff       	call   c0029528 <debug_panic>

  lock_init (&ls.lock);
c002cac6:	83 ec 0c             	sub    $0xc,%esp
c002cac9:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cacc:	50                   	push   %eax
c002cacd:	e8 71 5f ff ff       	call   c0022a43 <lock_init>
c002cad2:	83 c4 10             	add    $0x10,%esp
  sema_init (&ls.sema, 0);
c002cad5:	83 ec 08             	sub    $0x8,%esp
c002cad8:	6a 00                	push   $0x0
c002cada:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cadd:	83 c0 18             	add    $0x18,%eax
c002cae0:	50                   	push   %eax
c002cae1:	e8 a5 5c ff ff       	call   c002278b <sema_init>
c002cae6:	83 c4 10             	add    $0x10,%esp
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002cae9:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002caec:	50                   	push   %eax
c002caed:	68 56 cb 02 c0       	push   $0xc002cb56
c002caf2:	6a 20                	push   $0x20
c002caf4:	68 0a 21 03 c0       	push   $0xc003210a
c002caf9:	e8 4c 3f ff ff       	call   c0020a4a <thread_create>
c002cafe:	83 c4 10             	add    $0x10,%esp
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002cb01:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cb04:	50                   	push   %eax
c002cb05:	68 c5 cb 02 c0       	push   $0xc002cbc5
c002cb0a:	6a 22                	push   $0x22
c002cb0c:	68 0e 21 03 c0       	push   $0xc003210e
c002cb11:	e8 34 3f ff ff       	call   c0020a4a <thread_create>
c002cb16:	83 c4 10             	add    $0x10,%esp
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002cb19:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cb1c:	50                   	push   %eax
c002cb1d:	68 f6 cb 02 c0       	push   $0xc002cbf6
c002cb22:	6a 24                	push   $0x24
c002cb24:	68 12 21 03 c0       	push   $0xc0032112
c002cb29:	e8 1c 3f ff ff       	call   c0020a4a <thread_create>
c002cb2e:	83 c4 10             	add    $0x10,%esp
  sema_up (&ls.sema);
c002cb31:	83 ec 0c             	sub    $0xc,%esp
c002cb34:	8d 45 cc             	lea    -0x34(%ebp),%eax
c002cb37:	83 c0 18             	add    $0x18,%eax
c002cb3a:	50                   	push   %eax
c002cb3b:	e8 9c 5d ff ff       	call   c00228dc <sema_up>
c002cb40:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread finished.");
c002cb43:	83 ec 0c             	sub    $0xc,%esp
c002cb46:	68 17 21 03 c0       	push   $0xc0032117
c002cb4b:	e8 73 ed ff ff       	call   c002b8c3 <msg>
c002cb50:	83 c4 10             	add    $0x10,%esp
}
c002cb53:	90                   	nop
c002cb54:	c9                   	leave  
c002cb55:	c3                   	ret    

c002cb56 <l_thread_func>:

static void
l_thread_func (void *ls_) 
{
c002cb56:	55                   	push   %ebp
c002cb57:	89 e5                	mov    %esp,%ebp
c002cb59:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cb5c:	8b 45 08             	mov    0x8(%ebp),%eax
c002cb5f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002cb62:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb65:	83 ec 0c             	sub    $0xc,%esp
c002cb68:	50                   	push   %eax
c002cb69:	e8 22 5f ff ff       	call   c0022a90 <lock_acquire>
c002cb6e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L acquired lock.");
c002cb71:	83 ec 0c             	sub    $0xc,%esp
c002cb74:	68 2d 21 03 c0       	push   $0xc003212d
c002cb79:	e8 45 ed ff ff       	call   c002b8c3 <msg>
c002cb7e:	83 c4 10             	add    $0x10,%esp
  sema_down (&ls->sema);
c002cb81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cb84:	83 c0 18             	add    $0x18,%eax
c002cb87:	83 ec 0c             	sub    $0xc,%esp
c002cb8a:	50                   	push   %eax
c002cb8b:	e8 42 5c ff ff       	call   c00227d2 <sema_down>
c002cb90:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L downed semaphore.");
c002cb93:	83 ec 0c             	sub    $0xc,%esp
c002cb96:	68 45 21 03 c0       	push   $0xc0032145
c002cb9b:	e8 23 ed ff ff       	call   c002b8c3 <msg>
c002cba0:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002cba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cba6:	83 ec 0c             	sub    $0xc,%esp
c002cba9:	50                   	push   %eax
c002cbaa:	e8 21 60 ff ff       	call   c0022bd0 <lock_release>
c002cbaf:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L finished.");
c002cbb2:	83 ec 0c             	sub    $0xc,%esp
c002cbb5:	68 60 21 03 c0       	push   $0xc0032160
c002cbba:	e8 04 ed ff ff       	call   c002b8c3 <msg>
c002cbbf:	83 c4 10             	add    $0x10,%esp
}
c002cbc2:	90                   	nop
c002cbc3:	c9                   	leave  
c002cbc4:	c3                   	ret    

c002cbc5 <m_thread_func>:

static void
m_thread_func (void *ls_) 
{
c002cbc5:	55                   	push   %ebp
c002cbc6:	89 e5                	mov    %esp,%ebp
c002cbc8:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cbcb:	8b 45 08             	mov    0x8(%ebp),%eax
c002cbce:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema_down (&ls->sema);
c002cbd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cbd4:	83 c0 18             	add    $0x18,%eax
c002cbd7:	83 ec 0c             	sub    $0xc,%esp
c002cbda:	50                   	push   %eax
c002cbdb:	e8 f2 5b ff ff       	call   c00227d2 <sema_down>
c002cbe0:	83 c4 10             	add    $0x10,%esp
  msg ("Thread M finished.");
c002cbe3:	83 ec 0c             	sub    $0xc,%esp
c002cbe6:	68 73 21 03 c0       	push   $0xc0032173
c002cbeb:	e8 d3 ec ff ff       	call   c002b8c3 <msg>
c002cbf0:	83 c4 10             	add    $0x10,%esp
}
c002cbf3:	90                   	nop
c002cbf4:	c9                   	leave  
c002cbf5:	c3                   	ret    

c002cbf6 <h_thread_func>:

static void
h_thread_func (void *ls_) 
{
c002cbf6:	55                   	push   %ebp
c002cbf7:	89 e5                	mov    %esp,%ebp
c002cbf9:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002cbfc:	8b 45 08             	mov    0x8(%ebp),%eax
c002cbff:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002cc02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc05:	83 ec 0c             	sub    $0xc,%esp
c002cc08:	50                   	push   %eax
c002cc09:	e8 82 5e ff ff       	call   c0022a90 <lock_acquire>
c002cc0e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H acquired lock.");
c002cc11:	83 ec 0c             	sub    $0xc,%esp
c002cc14:	68 86 21 03 c0       	push   $0xc0032186
c002cc19:	e8 a5 ec ff ff       	call   c002b8c3 <msg>
c002cc1e:	83 c4 10             	add    $0x10,%esp

  sema_up (&ls->sema);
c002cc21:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc24:	83 c0 18             	add    $0x18,%eax
c002cc27:	83 ec 0c             	sub    $0xc,%esp
c002cc2a:	50                   	push   %eax
c002cc2b:	e8 ac 5c ff ff       	call   c00228dc <sema_up>
c002cc30:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002cc33:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cc36:	83 ec 0c             	sub    $0xc,%esp
c002cc39:	50                   	push   %eax
c002cc3a:	e8 91 5f ff ff       	call   c0022bd0 <lock_release>
c002cc3f:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H finished.");
c002cc42:	83 ec 0c             	sub    $0xc,%esp
c002cc45:	68 9e 21 03 c0       	push   $0xc003219e
c002cc4a:	e8 74 ec ff ff       	call   c002b8c3 <msg>
c002cc4f:	83 c4 10             	add    $0x10,%esp
}
c002cc52:	90                   	nop
c002cc53:	c9                   	leave  
c002cc54:	c3                   	ret    

c002cc55 <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002cc55:	55                   	push   %ebp
c002cc56:	89 e5                	mov    %esp,%ebp
c002cc58:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cc5b:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002cc60:	83 f0 01             	xor    $0x1,%eax
c002cc63:	84 c0                	test   %al,%al
c002cc65:	75 1e                	jne    c002cc85 <test_priority_donate_lower+0x30>
c002cc67:	83 ec 0c             	sub    $0xc,%esp
c002cc6a:	68 d0 21 03 c0       	push   $0xc00321d0
c002cc6f:	68 de 21 03 c0       	push   $0xc00321de
c002cc74:	68 f4 22 03 c0       	push   $0xc00322f4
c002cc79:	6a 15                	push   $0x15
c002cc7b:	68 f8 21 03 c0       	push   $0xc00321f8
c002cc80:	e8 a3 c8 ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cc85:	e8 f2 41 ff ff       	call   c0020e7c <thread_get_priority>
c002cc8a:	83 f8 1f             	cmp    $0x1f,%eax
c002cc8d:	74 1e                	je     c002ccad <test_priority_donate_lower+0x58>
c002cc8f:	83 ec 0c             	sub    $0xc,%esp
c002cc92:	68 24 22 03 c0       	push   $0xc0032224
c002cc97:	68 de 21 03 c0       	push   $0xc00321de
c002cc9c:	68 f4 22 03 c0       	push   $0xc00322f4
c002cca1:	6a 18                	push   $0x18
c002cca3:	68 f8 21 03 c0       	push   $0xc00321f8
c002cca8:	e8 7b c8 ff ff       	call   c0029528 <debug_panic>

  lock_init (&lock);
c002ccad:	83 ec 0c             	sub    $0xc,%esp
c002ccb0:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ccb3:	50                   	push   %eax
c002ccb4:	e8 8a 5d ff ff       	call   c0022a43 <lock_init>
c002ccb9:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002ccbc:	83 ec 0c             	sub    $0xc,%esp
c002ccbf:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ccc2:	50                   	push   %eax
c002ccc3:	e8 c8 5d ff ff       	call   c0022a90 <lock_acquire>
c002ccc8:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002cccb:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002ccce:	50                   	push   %eax
c002cccf:	68 6a cd 02 c0       	push   $0xc002cd6a
c002ccd4:	6a 29                	push   $0x29
c002ccd6:	68 4a 22 03 c0       	push   $0xc003224a
c002ccdb:	e8 6a 3d ff ff       	call   c0020a4a <thread_create>
c002cce0:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cce3:	e8 94 41 ff ff       	call   c0020e7c <thread_get_priority>
c002cce8:	83 ec 04             	sub    $0x4,%esp
c002cceb:	50                   	push   %eax
c002ccec:	6a 29                	push   $0x29
c002ccee:	68 54 22 03 c0       	push   $0xc0032254
c002ccf3:	e8 cb eb ff ff       	call   c002b8c3 <msg>
c002ccf8:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002ccfb:	83 ec 0c             	sub    $0xc,%esp
c002ccfe:	68 8f 22 03 c0       	push   $0xc003228f
c002cd03:	e8 bb eb ff ff       	call   c002b8c3 <msg>
c002cd08:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 10);
c002cd0b:	83 ec 0c             	sub    $0xc,%esp
c002cd0e:	6a 15                	push   $0x15
c002cd10:	e8 53 41 ff ff       	call   c0020e68 <thread_set_priority>
c002cd15:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cd18:	e8 5f 41 ff ff       	call   c0020e7c <thread_get_priority>
c002cd1d:	83 ec 04             	sub    $0x4,%esp
c002cd20:	50                   	push   %eax
c002cd21:	6a 29                	push   $0x29
c002cd23:	68 54 22 03 c0       	push   $0xc0032254
c002cd28:	e8 96 eb ff ff       	call   c002b8c3 <msg>
c002cd2d:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002cd30:	83 ec 0c             	sub    $0xc,%esp
c002cd33:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002cd36:	50                   	push   %eax
c002cd37:	e8 94 5e ff ff       	call   c0022bd0 <lock_release>
c002cd3c:	83 c4 10             	add    $0x10,%esp
  msg ("acquire must already have finished.");
c002cd3f:	83 ec 0c             	sub    $0xc,%esp
c002cd42:	68 ac 22 03 c0       	push   $0xc00322ac
c002cd47:	e8 77 eb ff ff       	call   c002b8c3 <msg>
c002cd4c:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cd4f:	e8 28 41 ff ff       	call   c0020e7c <thread_get_priority>
c002cd54:	83 ec 04             	sub    $0x4,%esp
c002cd57:	50                   	push   %eax
c002cd58:	6a 15                	push   $0x15
c002cd5a:	68 54 22 03 c0       	push   $0xc0032254
c002cd5f:	e8 5f eb ff ff       	call   c002b8c3 <msg>
c002cd64:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002cd67:	90                   	nop
c002cd68:	c9                   	leave  
c002cd69:	c3                   	ret    

c002cd6a <acquire_thread_func>:

static void
acquire_thread_func (void *lock_) 
{
c002cd6a:	55                   	push   %ebp
c002cd6b:	89 e5                	mov    %esp,%ebp
c002cd6d:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cd70:	8b 45 08             	mov    0x8(%ebp),%eax
c002cd73:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cd76:	83 ec 0c             	sub    $0xc,%esp
c002cd79:	ff 75 f4             	pushl  -0xc(%ebp)
c002cd7c:	e8 0f 5d ff ff       	call   c0022a90 <lock_acquire>
c002cd81:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: got the lock");
c002cd84:	83 ec 0c             	sub    $0xc,%esp
c002cd87:	68 d0 22 03 c0       	push   $0xc00322d0
c002cd8c:	e8 32 eb ff ff       	call   c002b8c3 <msg>
c002cd91:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cd94:	83 ec 0c             	sub    $0xc,%esp
c002cd97:	ff 75 f4             	pushl  -0xc(%ebp)
c002cd9a:	e8 31 5e ff ff       	call   c0022bd0 <lock_release>
c002cd9f:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: done");
c002cda2:	83 ec 0c             	sub    $0xc,%esp
c002cda5:	68 e6 22 03 c0       	push   $0xc00322e6
c002cdaa:	e8 14 eb ff ff       	call   c002b8c3 <msg>
c002cdaf:	83 c4 10             	add    $0x10,%esp
}
c002cdb2:	90                   	nop
c002cdb3:	c9                   	leave  
c002cdb4:	c3                   	ret    

c002cdb5 <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002cdb5:	55                   	push   %ebp
c002cdb6:	89 e5                	mov    %esp,%ebp
c002cdb8:	81 ec 48 01 00 00    	sub    $0x148,%esp
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cdbe:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002cdc3:	83 f0 01             	xor    $0x1,%eax
c002cdc6:	84 c0                	test   %al,%al
c002cdc8:	75 1e                	jne    c002cde8 <test_priority_fifo+0x33>
c002cdca:	83 ec 0c             	sub    $0xc,%esp
c002cdcd:	68 10 23 03 c0       	push   $0xc0032310
c002cdd2:	68 1e 23 03 c0       	push   $0xc003231e
c002cdd7:	68 58 24 03 c0       	push   $0xc0032458
c002cddc:	6a 28                	push   $0x28
c002cdde:	68 38 23 03 c0       	push   $0xc0032338
c002cde3:	e8 40 c7 ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cde8:	e8 8f 40 ff ff       	call   c0020e7c <thread_get_priority>
c002cded:	83 f8 1f             	cmp    $0x1f,%eax
c002cdf0:	74 1e                	je     c002ce10 <test_priority_fifo+0x5b>
c002cdf2:	83 ec 0c             	sub    $0xc,%esp
c002cdf5:	68 5c 23 03 c0       	push   $0xc003235c
c002cdfa:	68 1e 23 03 c0       	push   $0xc003231e
c002cdff:	68 58 24 03 c0       	push   $0xc0032458
c002ce04:	6a 2b                	push   $0x2b
c002ce06:	68 38 23 03 c0       	push   $0xc0032338
c002ce0b:	e8 18 c7 ff ff       	call   c0029528 <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002ce10:	83 ec 04             	sub    $0x4,%esp
c002ce13:	6a 10                	push   $0x10
c002ce15:	6a 10                	push   $0x10
c002ce17:	68 84 23 03 c0       	push   $0xc0032384
c002ce1c:	e8 a2 ea ff ff       	call   c002b8c3 <msg>
c002ce21:	83 c4 10             	add    $0x10,%esp
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002ce24:	83 ec 0c             	sub    $0xc,%esp
c002ce27:	68 c4 23 03 c0       	push   $0xc00323c4
c002ce2c:	e8 92 ea ff ff       	call   c002b8c3 <msg>
c002ce31:	83 c4 10             	add    $0x10,%esp

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002ce34:	83 ec 0c             	sub    $0xc,%esp
c002ce37:	68 00 08 00 00       	push   $0x800
c002ce3c:	e8 1a 66 ff ff       	call   c002345b <malloc>
c002ce41:	83 c4 10             	add    $0x10,%esp
c002ce44:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
c002ce4a:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002ce50:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (output != NULL);
c002ce53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ce57:	75 1e                	jne    c002ce77 <test_priority_fifo+0xc2>
c002ce59:	83 ec 0c             	sub    $0xc,%esp
c002ce5c:	68 ed 23 03 c0       	push   $0xc00323ed
c002ce61:	68 1e 23 03 c0       	push   $0xc003231e
c002ce66:	68 58 24 03 c0       	push   $0xc0032458
c002ce6b:	6a 32                	push   $0x32
c002ce6d:	68 38 23 03 c0       	push   $0xc0032338
c002ce72:	e8 b1 c6 ff ff       	call   c0029528 <debug_panic>
  lock_init (&lock);
c002ce77:	83 ec 0c             	sub    $0xc,%esp
c002ce7a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
c002ce80:	50                   	push   %eax
c002ce81:	e8 bd 5b ff ff       	call   c0022a43 <lock_init>
c002ce86:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_DEFAULT + 2);
c002ce89:	83 ec 0c             	sub    $0xc,%esp
c002ce8c:	6a 21                	push   $0x21
c002ce8e:	e8 d5 3f ff ff       	call   c0020e68 <thread_set_priority>
c002ce93:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002ce96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002ce9d:	eb 72                	jmp    c002cf11 <test_priority_fifo+0x15c>
    {
      char name[16];
      struct simple_thread_data *d = data + i;
c002ce9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002cea2:	c1 e0 04             	shl    $0x4,%eax
c002cea5:	89 c2                	mov    %eax,%edx
c002cea7:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002cead:	01 d0                	add    %edx,%eax
c002ceaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
      snprintf (name, sizeof name, "%d", i);
c002ceb2:	ff 75 f0             	pushl  -0x10(%ebp)
c002ceb5:	68 fc 23 03 c0       	push   $0xc00323fc
c002ceba:	6a 10                	push   $0x10
c002cebc:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002cec2:	50                   	push   %eax
c002cec3:	e8 78 a2 ff ff       	call   c0027140 <snprintf>
c002cec8:	83 c4 10             	add    $0x10,%esp
      d->id = i;
c002cecb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002cece:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002ced1:	89 10                	mov    %edx,(%eax)
      d->iterations = 0;
c002ced3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002ced6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      d->lock = &lock;
c002cedd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002cee0:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
c002cee6:	89 50 08             	mov    %edx,0x8(%eax)
      d->op = &op;
c002cee9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002ceec:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
c002cef2:	89 50 0c             	mov    %edx,0xc(%eax)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002cef5:	ff 75 e8             	pushl  -0x18(%ebp)
c002cef8:	68 0d d0 02 c0       	push   $0xc002d00d
c002cefd:	6a 20                	push   $0x20
c002ceff:	8d 85 b8 fe ff ff    	lea    -0x148(%ebp),%eax
c002cf05:	50                   	push   %eax
c002cf06:	e8 3f 3b ff ff       	call   c0020a4a <thread_create>
c002cf0b:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002cf0e:	ff 45 f0             	incl   -0x10(%ebp)
c002cf11:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c002cf15:	7e 88                	jle    c002ce9f <test_priority_fifo+0xea>
    }

  thread_set_priority (PRI_DEFAULT);
c002cf17:	83 ec 0c             	sub    $0xc,%esp
c002cf1a:	6a 1f                	push   $0x1f
c002cf1c:	e8 47 3f ff ff       	call   c0020e68 <thread_set_priority>
c002cf21:	83 c4 10             	add    $0x10,%esp
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002cf24:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
c002cf2a:	85 c0                	test   %eax,%eax
c002cf2c:	74 1e                	je     c002cf4c <test_priority_fifo+0x197>
c002cf2e:	83 ec 0c             	sub    $0xc,%esp
c002cf31:	68 ff 23 03 c0       	push   $0xc00323ff
c002cf36:	68 1e 23 03 c0       	push   $0xc003231e
c002cf3b:	68 58 24 03 c0       	push   $0xc0032458
c002cf40:	6a 44                	push   $0x44
c002cf42:	68 38 23 03 c0       	push   $0xc0032338
c002cf47:	e8 dc c5 ff ff       	call   c0029528 <debug_panic>

  cnt = 0;
c002cf4c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  for (; output < op; output++) 
c002cf53:	e9 a3 00 00 00       	jmp    c002cffb <test_priority_fifo+0x246>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002cf58:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cf5b:	8b 00                	mov    (%eax),%eax
c002cf5d:	85 c0                	test   %eax,%eax
c002cf5f:	78 0a                	js     c002cf6b <test_priority_fifo+0x1b6>
c002cf61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cf64:	8b 00                	mov    (%eax),%eax
c002cf66:	83 f8 0f             	cmp    $0xf,%eax
c002cf69:	7e 1e                	jle    c002cf89 <test_priority_fifo+0x1d4>
c002cf6b:	83 ec 0c             	sub    $0xc,%esp
c002cf6e:	68 14 24 03 c0       	push   $0xc0032414
c002cf73:	68 1e 23 03 c0       	push   $0xc003231e
c002cf78:	68 58 24 03 c0       	push   $0xc0032458
c002cf7d:	6a 4b                	push   $0x4b
c002cf7f:	68 38 23 03 c0       	push   $0xc0032338
c002cf84:	e8 9f c5 ff ff       	call   c0029528 <debug_panic>
      d = data + *output;
c002cf89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002cf8c:	8b 00                	mov    (%eax),%eax
c002cf8e:	c1 e0 04             	shl    $0x4,%eax
c002cf91:	89 c2                	mov    %eax,%edx
c002cf93:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002cf99:	01 d0                	add    %edx,%eax
c002cf9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (cnt % THREAD_CNT == 0)
c002cf9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002cfa1:	83 e0 0f             	and    $0xf,%eax
c002cfa4:	85 c0                	test   %eax,%eax
c002cfa6:	75 10                	jne    c002cfb8 <test_priority_fifo+0x203>
        printf ("(priority-fifo) iteration:");
c002cfa8:	83 ec 0c             	sub    $0xc,%esp
c002cfab:	68 39 24 03 c0       	push   $0xc0032439
c002cfb0:	e8 b4 a1 ff ff       	call   c0027169 <printf>
c002cfb5:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002cfb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002cfbb:	8b 00                	mov    (%eax),%eax
c002cfbd:	83 ec 08             	sub    $0x8,%esp
c002cfc0:	50                   	push   %eax
c002cfc1:	68 54 24 03 c0       	push   $0xc0032454
c002cfc6:	e8 9e a1 ff ff       	call   c0027169 <printf>
c002cfcb:	83 c4 10             	add    $0x10,%esp
      if (++cnt % THREAD_CNT == 0)
c002cfce:	ff 45 ec             	incl   -0x14(%ebp)
c002cfd1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002cfd4:	83 e0 0f             	and    $0xf,%eax
c002cfd7:	85 c0                	test   %eax,%eax
c002cfd9:	75 0d                	jne    c002cfe8 <test_priority_fifo+0x233>
        printf ("\n");
c002cfdb:	83 ec 0c             	sub    $0xc,%esp
c002cfde:	6a 0a                	push   $0xa
c002cfe0:	e8 89 e7 ff ff       	call   c002b76e <putchar>
c002cfe5:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002cfe8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002cfeb:	8b 40 04             	mov    0x4(%eax),%eax
c002cfee:	8d 50 01             	lea    0x1(%eax),%edx
c002cff1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002cff4:	89 50 04             	mov    %edx,0x4(%eax)
  for (; output < op; output++) 
c002cff7:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002cffb:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
c002d001:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002d004:	0f 82 4e ff ff ff    	jb     c002cf58 <test_priority_fifo+0x1a3>
    }
}
c002d00a:	90                   	nop
c002d00b:	c9                   	leave  
c002d00c:	c3                   	ret    

c002d00d <simple_thread_func>:

static void 
simple_thread_func (void *data_) 
{
c002d00d:	55                   	push   %ebp
c002d00e:	89 e5                	mov    %esp,%ebp
c002d010:	83 ec 18             	sub    $0x18,%esp
  struct simple_thread_data *data = data_;
c002d013:	8b 45 08             	mov    0x8(%ebp),%eax
c002d016:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d019:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d020:	eb 40                	jmp    c002d062 <simple_thread_func+0x55>
    {
      lock_acquire (data->lock);
c002d022:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d025:	8b 40 08             	mov    0x8(%eax),%eax
c002d028:	83 ec 0c             	sub    $0xc,%esp
c002d02b:	50                   	push   %eax
c002d02c:	e8 5f 5a ff ff       	call   c0022a90 <lock_acquire>
c002d031:	83 c4 10             	add    $0x10,%esp
      *(*data->op)++ = data->id;
c002d034:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d037:	8b 50 0c             	mov    0xc(%eax),%edx
c002d03a:	8b 02                	mov    (%edx),%eax
c002d03c:	8d 48 04             	lea    0x4(%eax),%ecx
c002d03f:	89 0a                	mov    %ecx,(%edx)
c002d041:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d044:	8b 12                	mov    (%edx),%edx
c002d046:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002d048:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d04b:	8b 40 08             	mov    0x8(%eax),%eax
c002d04e:	83 ec 0c             	sub    $0xc,%esp
c002d051:	50                   	push   %eax
c002d052:	e8 79 5b ff ff       	call   c0022bd0 <lock_release>
c002d057:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d05a:	e8 fa 3c ff ff       	call   c0020d59 <thread_yield>
  for (i = 0; i < ITER_CNT; i++) 
c002d05f:	ff 45 f4             	incl   -0xc(%ebp)
c002d062:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c002d066:	7e ba                	jle    c002d022 <simple_thread_func+0x15>
    }
}
c002d068:	90                   	nop
c002d069:	c9                   	leave  
c002d06a:	c3                   	ret    

c002d06b <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002d06b:	55                   	push   %ebp
c002d06c:	89 e5                	mov    %esp,%ebp
c002d06e:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d071:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002d076:	83 f0 01             	xor    $0x1,%eax
c002d079:	84 c0                	test   %al,%al
c002d07b:	75 1e                	jne    c002d09b <test_priority_preempt+0x30>
c002d07d:	83 ec 0c             	sub    $0xc,%esp
c002d080:	68 6c 24 03 c0       	push   $0xc003246c
c002d085:	68 7a 24 03 c0       	push   $0xc003247a
c002d08a:	68 50 25 03 c0       	push   $0xc0032550
c002d08f:	6a 15                	push   $0x15
c002d091:	68 94 24 03 c0       	push   $0xc0032494
c002d096:	e8 8d c4 ff ff       	call   c0029528 <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d09b:	e8 dc 3d ff ff       	call   c0020e7c <thread_get_priority>
c002d0a0:	83 f8 1f             	cmp    $0x1f,%eax
c002d0a3:	74 1e                	je     c002d0c3 <test_priority_preempt+0x58>
c002d0a5:	83 ec 0c             	sub    $0xc,%esp
c002d0a8:	68 bc 24 03 c0       	push   $0xc00324bc
c002d0ad:	68 7a 24 03 c0       	push   $0xc003247a
c002d0b2:	68 50 25 03 c0       	push   $0xc0032550
c002d0b7:	6a 18                	push   $0x18
c002d0b9:	68 94 24 03 c0       	push   $0xc0032494
c002d0be:	e8 65 c4 ff ff       	call   c0029528 <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002d0c3:	6a 00                	push   $0x0
c002d0c5:	68 ec d0 02 c0       	push   $0xc002d0ec
c002d0ca:	6a 20                	push   $0x20
c002d0cc:	68 e2 24 03 c0       	push   $0xc00324e2
c002d0d1:	e8 74 39 ff ff       	call   c0020a4a <thread_create>
c002d0d6:	83 c4 10             	add    $0x10,%esp
  msg ("The high-priority thread should have already completed.");
c002d0d9:	83 ec 0c             	sub    $0xc,%esp
c002d0dc:	68 f0 24 03 c0       	push   $0xc00324f0
c002d0e1:	e8 dd e7 ff ff       	call   c002b8c3 <msg>
c002d0e6:	83 c4 10             	add    $0x10,%esp
}
c002d0e9:	90                   	nop
c002d0ea:	c9                   	leave  
c002d0eb:	c3                   	ret    

c002d0ec <simple_thread_func>:

static void 
simple_thread_func (void *aux UNUSED) 
{
c002d0ec:	55                   	push   %ebp
c002d0ed:	89 e5                	mov    %esp,%ebp
c002d0ef:	83 ec 18             	sub    $0x18,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002d0f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d0f9:	eb 21                	jmp    c002d11c <simple_thread_func+0x30>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002d0fb:	e8 53 3b ff ff       	call   c0020c53 <thread_name>
c002d100:	83 ec 04             	sub    $0x4,%esp
c002d103:	ff 75 f4             	pushl  -0xc(%ebp)
c002d106:	50                   	push   %eax
c002d107:	68 28 25 03 c0       	push   $0xc0032528
c002d10c:	e8 b2 e7 ff ff       	call   c002b8c3 <msg>
c002d111:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d114:	e8 40 3c ff ff       	call   c0020d59 <thread_yield>
  for (i = 0; i < 5; i++) 
c002d119:	ff 45 f4             	incl   -0xc(%ebp)
c002d11c:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c002d120:	7e d9                	jle    c002d0fb <simple_thread_func+0xf>
    }
  msg ("Thread %s done!", thread_name ());
c002d122:	e8 2c 3b ff ff       	call   c0020c53 <thread_name>
c002d127:	83 ec 08             	sub    $0x8,%esp
c002d12a:	50                   	push   %eax
c002d12b:	68 3f 25 03 c0       	push   $0xc003253f
c002d130:	e8 8e e7 ff ff       	call   c002b8c3 <msg>
c002d135:	83 c4 10             	add    $0x10,%esp
}
c002d138:	90                   	nop
c002d139:	c9                   	leave  
c002d13a:	c3                   	ret    

c002d13b <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002d13b:	55                   	push   %ebp
c002d13c:	89 e5                	mov    %esp,%ebp
c002d13e:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d141:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002d146:	83 f0 01             	xor    $0x1,%eax
c002d149:	84 c0                	test   %al,%al
c002d14b:	75 1e                	jne    c002d16b <test_priority_sema+0x30>
c002d14d:	83 ec 0c             	sub    $0xc,%esp
c002d150:	68 68 25 03 c0       	push   $0xc0032568
c002d155:	68 76 25 03 c0       	push   $0xc0032576
c002d15a:	68 e8 25 03 c0       	push   $0xc00325e8
c002d15f:	6a 15                	push   $0x15
c002d161:	68 90 25 03 c0       	push   $0xc0032590
c002d166:	e8 bd c3 ff ff       	call   c0029528 <debug_panic>

  sema_init (&sema, 0);
c002d16b:	83 ec 08             	sub    $0x8,%esp
c002d16e:	6a 00                	push   $0x0
c002d170:	68 34 8c 03 c0       	push   $0xc0038c34
c002d175:	e8 11 56 ff ff       	call   c002278b <sema_init>
c002d17a:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_MIN);
c002d17d:	83 ec 0c             	sub    $0xc,%esp
c002d180:	6a 00                	push   $0x0
c002d182:	e8 e1 3c ff ff       	call   c0020e68 <thread_set_priority>
c002d187:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d18a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d191:	eb 4b                	jmp    c002d1de <test_priority_sema+0xa3>
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002d193:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d196:	83 c0 03             	add    $0x3,%eax
c002d199:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002d19e:	99                   	cltd   
c002d19f:	f7 f9                	idiv   %ecx
c002d1a1:	89 d0                	mov    %edx,%eax
c002d1a3:	ba 1e 00 00 00       	mov    $0x1e,%edx
c002d1a8:	29 c2                	sub    %eax,%edx
c002d1aa:	89 d0                	mov    %edx,%eax
c002d1ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d1af:	ff 75 f0             	pushl  -0x10(%ebp)
c002d1b2:	68 b4 25 03 c0       	push   $0xc00325b4
c002d1b7:	6a 10                	push   $0x10
c002d1b9:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d1bc:	50                   	push   %eax
c002d1bd:	e8 7e 9f ff ff       	call   c0027140 <snprintf>
c002d1c2:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_sema_thread, NULL);
c002d1c5:	6a 00                	push   $0x0
c002d1c7:	68 19 d2 02 c0       	push   $0xc002d219
c002d1cc:	ff 75 f0             	pushl  -0x10(%ebp)
c002d1cf:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d1d2:	50                   	push   %eax
c002d1d3:	e8 72 38 ff ff       	call   c0020a4a <thread_create>
c002d1d8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d1db:	ff 45 f4             	incl   -0xc(%ebp)
c002d1de:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d1e2:	7e af                	jle    c002d193 <test_priority_sema+0x58>
    }

  for (i = 0; i < 10; i++) 
c002d1e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d1eb:	eb 23                	jmp    c002d210 <test_priority_sema+0xd5>
    {
      sema_up (&sema);
c002d1ed:	83 ec 0c             	sub    $0xc,%esp
c002d1f0:	68 34 8c 03 c0       	push   $0xc0038c34
c002d1f5:	e8 e2 56 ff ff       	call   c00228dc <sema_up>
c002d1fa:	83 c4 10             	add    $0x10,%esp
      msg ("Back in main thread."); 
c002d1fd:	83 ec 0c             	sub    $0xc,%esp
c002d200:	68 c0 25 03 c0       	push   $0xc00325c0
c002d205:	e8 b9 e6 ff ff       	call   c002b8c3 <msg>
c002d20a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d20d:	ff 45 f4             	incl   -0xc(%ebp)
c002d210:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d214:	7e d7                	jle    c002d1ed <test_priority_sema+0xb2>
    }
}
c002d216:	90                   	nop
c002d217:	c9                   	leave  
c002d218:	c3                   	ret    

c002d219 <priority_sema_thread>:

static void
priority_sema_thread (void *aux UNUSED) 
{
c002d219:	55                   	push   %ebp
c002d21a:	89 e5                	mov    %esp,%ebp
c002d21c:	83 ec 08             	sub    $0x8,%esp
  sema_down (&sema);
c002d21f:	83 ec 0c             	sub    $0xc,%esp
c002d222:	68 34 8c 03 c0       	push   $0xc0038c34
c002d227:	e8 a6 55 ff ff       	call   c00227d2 <sema_down>
c002d22c:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d22f:	e8 1f 3a ff ff       	call   c0020c53 <thread_name>
c002d234:	83 ec 08             	sub    $0x8,%esp
c002d237:	50                   	push   %eax
c002d238:	68 d5 25 03 c0       	push   $0xc00325d5
c002d23d:	e8 81 e6 ff ff       	call   c002b8c3 <msg>
c002d242:	83 c4 10             	add    $0x10,%esp
}
c002d245:	90                   	nop
c002d246:	c9                   	leave  
c002d247:	c3                   	ret    

c002d248 <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c002d248:	55                   	push   %ebp
c002d249:	89 e5                	mov    %esp,%ebp
c002d24b:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d24e:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002d253:	83 f0 01             	xor    $0x1,%eax
c002d256:	84 c0                	test   %al,%al
c002d258:	75 1e                	jne    c002d278 <test_priority_condvar+0x30>
c002d25a:	83 ec 0c             	sub    $0xc,%esp
c002d25d:	68 fc 25 03 c0       	push   $0xc00325fc
c002d262:	68 0a 26 03 c0       	push   $0xc003260a
c002d267:	68 8c 26 03 c0       	push   $0xc003268c
c002d26c:	6a 16                	push   $0x16
c002d26e:	68 24 26 03 c0       	push   $0xc0032624
c002d273:	e8 b0 c2 ff ff       	call   c0029528 <debug_panic>

  lock_init (&lock);
c002d278:	83 ec 0c             	sub    $0xc,%esp
c002d27b:	68 48 8c 03 c0       	push   $0xc0038c48
c002d280:	e8 be 57 ff ff       	call   c0022a43 <lock_init>
c002d285:	83 c4 10             	add    $0x10,%esp
  cond_init (&condition);
c002d288:	83 ec 0c             	sub    $0xc,%esp
c002d28b:	68 60 8c 03 c0       	push   $0xc0038c60
c002d290:	e8 fb 59 ff ff       	call   c0022c90 <cond_init>
c002d295:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_MIN);
c002d298:	83 ec 0c             	sub    $0xc,%esp
c002d29b:	6a 00                	push   $0x0
c002d29d:	e8 c6 3b ff ff       	call   c0020e68 <thread_set_priority>
c002d2a2:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d2a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d2ac:	eb 4b                	jmp    c002d2f9 <test_priority_condvar+0xb1>
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002d2ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d2b1:	83 c0 07             	add    $0x7,%eax
c002d2b4:	b9 0a 00 00 00       	mov    $0xa,%ecx
c002d2b9:	99                   	cltd   
c002d2ba:	f7 f9                	idiv   %ecx
c002d2bc:	89 d0                	mov    %edx,%eax
c002d2be:	ba 1e 00 00 00       	mov    $0x1e,%edx
c002d2c3:	29 c2                	sub    %eax,%edx
c002d2c5:	89 d0                	mov    %edx,%eax
c002d2c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d2ca:	ff 75 f0             	pushl  -0x10(%ebp)
c002d2cd:	68 4b 26 03 c0       	push   $0xc003264b
c002d2d2:	6a 10                	push   $0x10
c002d2d4:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d2d7:	50                   	push   %eax
c002d2d8:	e8 63 9e ff ff       	call   c0027140 <snprintf>
c002d2dd:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_condvar_thread, NULL);
c002d2e0:	6a 00                	push   $0x0
c002d2e2:	68 59 d3 02 c0       	push   $0xc002d359
c002d2e7:	ff 75 f0             	pushl  -0x10(%ebp)
c002d2ea:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d2ed:	50                   	push   %eax
c002d2ee:	e8 57 37 ff ff       	call   c0020a4a <thread_create>
c002d2f3:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d2f6:	ff 45 f4             	incl   -0xc(%ebp)
c002d2f9:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d2fd:	7e af                	jle    c002d2ae <test_priority_condvar+0x66>
    }

  for (i = 0; i < 10; i++) 
c002d2ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d306:	eb 48                	jmp    c002d350 <test_priority_condvar+0x108>
    {
      lock_acquire (&lock);
c002d308:	83 ec 0c             	sub    $0xc,%esp
c002d30b:	68 48 8c 03 c0       	push   $0xc0038c48
c002d310:	e8 7b 57 ff ff       	call   c0022a90 <lock_acquire>
c002d315:	83 c4 10             	add    $0x10,%esp
      msg ("Signaling...");
c002d318:	83 ec 0c             	sub    $0xc,%esp
c002d31b:	68 57 26 03 c0       	push   $0xc0032657
c002d320:	e8 9e e5 ff ff       	call   c002b8c3 <msg>
c002d325:	83 c4 10             	add    $0x10,%esp
      cond_signal (&condition, &lock);
c002d328:	83 ec 08             	sub    $0x8,%esp
c002d32b:	68 48 8c 03 c0       	push   $0xc0038c48
c002d330:	68 60 8c 03 c0       	push   $0xc0038c60
c002d335:	e8 a1 5a ff ff       	call   c0022ddb <cond_signal>
c002d33a:	83 c4 10             	add    $0x10,%esp
      lock_release (&lock);
c002d33d:	83 ec 0c             	sub    $0xc,%esp
c002d340:	68 48 8c 03 c0       	push   $0xc0038c48
c002d345:	e8 86 58 ff ff       	call   c0022bd0 <lock_release>
c002d34a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d34d:	ff 45 f4             	incl   -0xc(%ebp)
c002d350:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d354:	7e b2                	jle    c002d308 <test_priority_condvar+0xc0>
    }
}
c002d356:	90                   	nop
c002d357:	c9                   	leave  
c002d358:	c3                   	ret    

c002d359 <priority_condvar_thread>:

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002d359:	55                   	push   %ebp
c002d35a:	89 e5                	mov    %esp,%ebp
c002d35c:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread %s starting.", thread_name ());
c002d35f:	e8 ef 38 ff ff       	call   c0020c53 <thread_name>
c002d364:	83 ec 08             	sub    $0x8,%esp
c002d367:	50                   	push   %eax
c002d368:	68 64 26 03 c0       	push   $0xc0032664
c002d36d:	e8 51 e5 ff ff       	call   c002b8c3 <msg>
c002d372:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002d375:	83 ec 0c             	sub    $0xc,%esp
c002d378:	68 48 8c 03 c0       	push   $0xc0038c48
c002d37d:	e8 0e 57 ff ff       	call   c0022a90 <lock_acquire>
c002d382:	83 c4 10             	add    $0x10,%esp
  cond_wait (&condition, &lock);
c002d385:	83 ec 08             	sub    $0x8,%esp
c002d388:	68 48 8c 03 c0       	push   $0xc0038c48
c002d38d:	68 60 8c 03 c0       	push   $0xc0038c60
c002d392:	e8 38 59 ff ff       	call   c0022ccf <cond_wait>
c002d397:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d39a:	e8 b4 38 ff ff       	call   c0020c53 <thread_name>
c002d39f:	83 ec 08             	sub    $0x8,%esp
c002d3a2:	50                   	push   %eax
c002d3a3:	68 78 26 03 c0       	push   $0xc0032678
c002d3a8:	e8 16 e5 ff ff       	call   c002b8c3 <msg>
c002d3ad:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002d3b0:	83 ec 0c             	sub    $0xc,%esp
c002d3b3:	68 48 8c 03 c0       	push   $0xc0038c48
c002d3b8:	e8 13 58 ff ff       	call   c0022bd0 <lock_release>
c002d3bd:	83 c4 10             	add    $0x10,%esp
}
c002d3c0:	90                   	nop
c002d3c1:	c9                   	leave  
c002d3c2:	c3                   	ret    

c002d3c3 <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c002d3c3:	55                   	push   %ebp
c002d3c4:	89 e5                	mov    %esp,%ebp
c002d3c6:	53                   	push   %ebx
c002d3c7:	81 ec 04 01 00 00    	sub    $0x104,%esp
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d3cd:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002d3d2:	83 f0 01             	xor    $0x1,%eax
c002d3d5:	84 c0                	test   %al,%al
c002d3d7:	75 1e                	jne    c002d3f7 <test_priority_donate_chain+0x34>
c002d3d9:	83 ec 0c             	sub    $0xc,%esp
c002d3dc:	68 a4 26 03 c0       	push   $0xc00326a4
c002d3e1:	68 b2 26 03 c0       	push   $0xc00326b2
c002d3e6:	68 bc 27 03 c0       	push   $0xc00327bc
c002d3eb:	6a 34                	push   $0x34
c002d3ed:	68 cc 26 03 c0       	push   $0xc00326cc
c002d3f2:	e8 31 c1 ff ff       	call   c0029528 <debug_panic>

  thread_set_priority (PRI_MIN);
c002d3f7:	83 ec 0c             	sub    $0xc,%esp
c002d3fa:	6a 00                	push   $0x0
c002d3fc:	e8 67 3a ff ff       	call   c0020e68 <thread_set_priority>
c002d401:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d404:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d40b:	eb 23                	jmp    c002d430 <test_priority_donate_chain+0x6d>
    lock_init (&locks[i]);
c002d40d:	8d 8d 48 ff ff ff    	lea    -0xb8(%ebp),%ecx
c002d413:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d416:	89 d0                	mov    %edx,%eax
c002d418:	01 c0                	add    %eax,%eax
c002d41a:	01 d0                	add    %edx,%eax
c002d41c:	c1 e0 03             	shl    $0x3,%eax
c002d41f:	01 c8                	add    %ecx,%eax
c002d421:	83 ec 0c             	sub    $0xc,%esp
c002d424:	50                   	push   %eax
c002d425:	e8 19 56 ff ff       	call   c0022a43 <lock_init>
c002d42a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002d42d:	ff 45 f4             	incl   -0xc(%ebp)
c002d430:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d434:	7e d7                	jle    c002d40d <test_priority_donate_chain+0x4a>

  lock_acquire (&locks[0]);
c002d436:	83 ec 0c             	sub    $0xc,%esp
c002d439:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d43f:	50                   	push   %eax
c002d440:	e8 4b 56 ff ff       	call   c0022a90 <lock_acquire>
c002d445:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock.", thread_name ());
c002d448:	e8 06 38 ff ff       	call   c0020c53 <thread_name>
c002d44d:	83 ec 08             	sub    $0x8,%esp
c002d450:	50                   	push   %eax
c002d451:	68 f8 26 03 c0       	push   $0xc00326f8
c002d456:	e8 68 e4 ff ff       	call   c002b8c3 <msg>
c002d45b:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i < NESTING_DEPTH; i++)
c002d45e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002d465:	e9 f2 00 00 00       	jmp    c002d55c <test_priority_donate_chain+0x199>
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c002d46a:	ff 75 f4             	pushl  -0xc(%ebp)
c002d46d:	68 05 27 03 c0       	push   $0xc0032705
c002d472:	6a 10                	push   $0x10
c002d474:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d47a:	50                   	push   %eax
c002d47b:	e8 c0 9c ff ff       	call   c0027140 <snprintf>
c002d480:	83 c4 10             	add    $0x10,%esp
      thread_priority = PRI_MIN + i * 3;
c002d483:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d486:	89 c2                	mov    %eax,%edx
c002d488:	01 d2                	add    %edx,%edx
c002d48a:	01 d0                	add    %edx,%eax
c002d48c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002d48f:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002d493:	7f 18                	jg     c002d4ad <test_priority_donate_chain+0xea>
c002d495:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d498:	89 d0                	mov    %edx,%eax
c002d49a:	01 c0                	add    %eax,%eax
c002d49c:	01 d0                	add    %edx,%eax
c002d49e:	c1 e0 03             	shl    $0x3,%eax
c002d4a1:	89 c2                	mov    %eax,%edx
c002d4a3:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d4a9:	01 c2                	add    %eax,%edx
c002d4ab:	eb 05                	jmp    c002d4b2 <test_priority_donate_chain+0xef>
c002d4ad:	ba 00 00 00 00       	mov    $0x0,%edx
c002d4b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4b5:	89 94 c5 0c ff ff ff 	mov    %edx,-0xf4(%ebp,%eax,8)
      lock_pairs[i].second = locks + i - 1;
c002d4bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002d4bf:	89 d0                	mov    %edx,%eax
c002d4c1:	01 c0                	add    %eax,%eax
c002d4c3:	01 d0                	add    %edx,%eax
c002d4c5:	c1 e0 03             	shl    $0x3,%eax
c002d4c8:	8d 50 e8             	lea    -0x18(%eax),%edx
c002d4cb:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d4d1:	01 c2                	add    %eax,%edx
c002d4d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4d6:	89 94 c5 08 ff ff ff 	mov    %edx,-0xf8(%ebp,%eax,8)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002d4dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d4e0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c002d4e7:	8d 85 08 ff ff ff    	lea    -0xf8(%ebp),%eax
c002d4ed:	01 d0                	add    %edx,%eax
c002d4ef:	50                   	push   %eax
c002d4f0:	68 9c d5 02 c0       	push   $0xc002d59c
c002d4f5:	ff 75 f0             	pushl  -0x10(%ebp)
c002d4f8:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d4fe:	50                   	push   %eax
c002d4ff:	e8 46 35 ff ff       	call   c0020a4a <thread_create>
c002d504:	83 c4 10             	add    $0x10,%esp
      msg ("%s should have priority %d.  Actual priority: %d.",
c002d507:	e8 70 39 ff ff       	call   c0020e7c <thread_get_priority>
c002d50c:	89 c3                	mov    %eax,%ebx
c002d50e:	e8 40 37 ff ff       	call   c0020c53 <thread_name>
c002d513:	53                   	push   %ebx
c002d514:	ff 75 f0             	pushl  -0x10(%ebp)
c002d517:	50                   	push   %eax
c002d518:	68 10 27 03 c0       	push   $0xc0032710
c002d51d:	e8 a1 e3 ff ff       	call   c002b8c3 <msg>
c002d522:	83 c4 10             	add    $0x10,%esp
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c002d525:	ff 75 f4             	pushl  -0xc(%ebp)
c002d528:	68 42 27 03 c0       	push   $0xc0032742
c002d52d:	6a 10                	push   $0x10
c002d52f:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d535:	50                   	push   %eax
c002d536:	e8 05 9c ff ff       	call   c0027140 <snprintf>
c002d53b:	83 c4 10             	add    $0x10,%esp
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002d53e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d541:	48                   	dec    %eax
c002d542:	6a 00                	push   $0x0
c002d544:	68 5a d6 02 c0       	push   $0xc002d65a
c002d549:	50                   	push   %eax
c002d54a:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
c002d550:	50                   	push   %eax
c002d551:	e8 f4 34 ff ff       	call   c0020a4a <thread_create>
c002d556:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < NESTING_DEPTH; i++)
c002d559:	ff 45 f4             	incl   -0xc(%ebp)
c002d55c:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c002d560:	0f 8e 04 ff ff ff    	jle    c002d46a <test_priority_donate_chain+0xa7>
    }

  lock_release (&locks[0]);
c002d566:	83 ec 0c             	sub    $0xc,%esp
c002d569:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
c002d56f:	50                   	push   %eax
c002d570:	e8 5b 56 ff ff       	call   c0022bd0 <lock_release>
c002d575:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002d578:	e8 ff 38 ff ff       	call   c0020e7c <thread_get_priority>
c002d57d:	89 c3                	mov    %eax,%ebx
c002d57f:	e8 cf 36 ff ff       	call   c0020c53 <thread_name>
c002d584:	83 ec 04             	sub    $0x4,%esp
c002d587:	53                   	push   %ebx
c002d588:	50                   	push   %eax
c002d589:	68 50 27 03 c0       	push   $0xc0032750
c002d58e:	e8 30 e3 ff ff       	call   c002b8c3 <msg>
c002d593:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d596:	90                   	nop
c002d597:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d59a:	c9                   	leave  
c002d59b:	c3                   	ret    

c002d59c <donor_thread_func>:

static void
donor_thread_func (void *locks_) 
{
c002d59c:	55                   	push   %ebp
c002d59d:	89 e5                	mov    %esp,%ebp
c002d59f:	53                   	push   %ebx
c002d5a0:	83 ec 14             	sub    $0x14,%esp
  struct lock_pair *locks = locks_;
c002d5a3:	8b 45 08             	mov    0x8(%ebp),%eax
c002d5a6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (locks->first)
c002d5a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5ac:	8b 40 04             	mov    0x4(%eax),%eax
c002d5af:	85 c0                	test   %eax,%eax
c002d5b1:	74 12                	je     c002d5c5 <donor_thread_func+0x29>
    lock_acquire (locks->first);
c002d5b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5b6:	8b 40 04             	mov    0x4(%eax),%eax
c002d5b9:	83 ec 0c             	sub    $0xc,%esp
c002d5bc:	50                   	push   %eax
c002d5bd:	e8 ce 54 ff ff       	call   c0022a90 <lock_acquire>
c002d5c2:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c002d5c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5c8:	8b 00                	mov    (%eax),%eax
c002d5ca:	83 ec 0c             	sub    $0xc,%esp
c002d5cd:	50                   	push   %eax
c002d5ce:	e8 bd 54 ff ff       	call   c0022a90 <lock_acquire>
c002d5d3:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock", thread_name ());
c002d5d6:	e8 78 36 ff ff       	call   c0020c53 <thread_name>
c002d5db:	83 ec 08             	sub    $0x8,%esp
c002d5de:	50                   	push   %eax
c002d5df:	68 6f 27 03 c0       	push   $0xc003276f
c002d5e4:	e8 da e2 ff ff       	call   c002b8c3 <msg>
c002d5e9:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->second);
c002d5ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d5ef:	8b 00                	mov    (%eax),%eax
c002d5f1:	83 ec 0c             	sub    $0xc,%esp
c002d5f4:	50                   	push   %eax
c002d5f5:	e8 d6 55 ff ff       	call   c0022bd0 <lock_release>
c002d5fa:	83 c4 10             	add    $0x10,%esp
  msg ("%s should have priority %d. Actual priority: %d", 
c002d5fd:	e8 7a 38 ff ff       	call   c0020e7c <thread_get_priority>
c002d602:	89 c3                	mov    %eax,%ebx
c002d604:	e8 4a 36 ff ff       	call   c0020c53 <thread_name>
c002d609:	53                   	push   %ebx
c002d60a:	6a 15                	push   $0x15
c002d60c:	50                   	push   %eax
c002d60d:	68 7c 27 03 c0       	push   $0xc003277c
c002d612:	e8 ac e2 ff ff       	call   c002b8c3 <msg>
c002d617:	83 c4 10             	add    $0x10,%esp
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c002d61a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d61d:	8b 40 04             	mov    0x4(%eax),%eax
c002d620:	85 c0                	test   %eax,%eax
c002d622:	74 12                	je     c002d636 <donor_thread_func+0x9a>
    lock_release (locks->first);
c002d624:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d627:	8b 40 04             	mov    0x4(%eax),%eax
c002d62a:	83 ec 0c             	sub    $0xc,%esp
c002d62d:	50                   	push   %eax
c002d62e:	e8 9d 55 ff ff       	call   c0022bd0 <lock_release>
c002d633:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c002d636:	e8 41 38 ff ff       	call   c0020e7c <thread_get_priority>
c002d63b:	89 c3                	mov    %eax,%ebx
c002d63d:	e8 11 36 ff ff       	call   c0020c53 <thread_name>
c002d642:	83 ec 04             	sub    $0x4,%esp
c002d645:	53                   	push   %ebx
c002d646:	50                   	push   %eax
c002d647:	68 50 27 03 c0       	push   $0xc0032750
c002d64c:	e8 72 e2 ff ff       	call   c002b8c3 <msg>
c002d651:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002d654:	90                   	nop
c002d655:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d658:	c9                   	leave  
c002d659:	c3                   	ret    

c002d65a <interloper_thread_func>:

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002d65a:	55                   	push   %ebp
c002d65b:	89 e5                	mov    %esp,%ebp
c002d65d:	83 ec 08             	sub    $0x8,%esp
  msg ("%s finished.", thread_name ());
c002d660:	e8 ee 35 ff ff       	call   c0020c53 <thread_name>
c002d665:	83 ec 08             	sub    $0x8,%esp
c002d668:	50                   	push   %eax
c002d669:	68 ac 27 03 c0       	push   $0xc00327ac
c002d66e:	e8 50 e2 ff ff       	call   c002b8c3 <msg>
c002d673:	83 c4 10             	add    $0x10,%esp
}
c002d676:	90                   	nop
c002d677:	c9                   	leave  
c002d678:	c3                   	ret    

c002d679 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002d679:	55                   	push   %ebp
c002d67a:	89 e5                	mov    %esp,%ebp
c002d67c:	53                   	push   %ebx
c002d67d:	83 ec 14             	sub    $0x14,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002d680:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002d685:	84 c0                	test   %al,%al
c002d687:	75 1e                	jne    c002d6a7 <test_mlfqs_load_1+0x2e>
c002d689:	83 ec 0c             	sub    $0xc,%esp
c002d68c:	68 d8 27 03 c0       	push   $0xc00327d8
c002d691:	68 e5 27 03 c0       	push   $0xc00327e5
c002d696:	68 f4 29 03 c0       	push   $0xc00329f4
c002d69b:	6a 18                	push   $0x18
c002d69d:	68 fc 27 03 c0       	push   $0xc00327fc
c002d6a2:	e8 81 be ff ff       	call   c0029528 <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c002d6a7:	83 ec 0c             	sub    $0xc,%esp
c002d6aa:	68 20 28 03 c0       	push   $0xc0032820
c002d6af:	e8 0f e2 ff ff       	call   c002b8c3 <msg>
c002d6b4:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002d6b7:	e8 e2 65 ff ff       	call   c0023c9e <timer_ticks>
c002d6bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002d6bf:	89 55 f4             	mov    %edx,-0xc(%ebp)
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c002d6c2:	e8 d5 37 ff ff       	call   c0020e9c <thread_get_load_avg>
c002d6c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
      ASSERT (load_avg >= 0);
c002d6ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002d6ce:	79 1e                	jns    c002d6ee <test_mlfqs_load_1+0x75>
c002d6d0:	83 ec 0c             	sub    $0xc,%esp
c002d6d3:	68 4e 28 03 c0       	push   $0xc003284e
c002d6d8:	68 e5 27 03 c0       	push   $0xc00327e5
c002d6dd:	68 f4 29 03 c0       	push   $0xc00329f4
c002d6e2:	6a 20                	push   $0x20
c002d6e4:	68 fc 27 03 c0       	push   $0xc00327fc
c002d6e9:	e8 3a be ff ff       	call   c0029528 <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002d6ee:	83 ec 08             	sub    $0x8,%esp
c002d6f1:	ff 75 f4             	pushl  -0xc(%ebp)
c002d6f4:	ff 75 f0             	pushl  -0x10(%ebp)
c002d6f7:	e8 d7 65 ff ff       	call   c0023cd3 <timer_elapsed>
c002d6fc:	83 c4 10             	add    $0x10,%esp
c002d6ff:	6a 00                	push   $0x0
c002d701:	6a 64                	push   $0x64
c002d703:	52                   	push   %edx
c002d704:	50                   	push   %eax
c002d705:	e8 24 b8 ff ff       	call   c0028f2e <__divdi3>
c002d70a:	83 c4 10             	add    $0x10,%esp
c002d70d:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (load_avg > 100)
c002d710:	83 7d ec 64          	cmpl   $0x64,-0x14(%ebp)
c002d714:	7e 5a                	jle    c002d770 <test_mlfqs_load_1+0xf7>
        fail ("load average is %d.%02d "
c002d716:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d719:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d71e:	f7 eb                	imul   %ebx
c002d720:	c1 fa 05             	sar    $0x5,%edx
c002d723:	89 d8                	mov    %ebx,%eax
c002d725:	c1 f8 1f             	sar    $0x1f,%eax
c002d728:	89 d1                	mov    %edx,%ecx
c002d72a:	29 c1                	sub    %eax,%ecx
c002d72c:	89 c8                	mov    %ecx,%eax
c002d72e:	c1 e0 02             	shl    $0x2,%eax
c002d731:	01 c8                	add    %ecx,%eax
c002d733:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d73a:	01 d0                	add    %edx,%eax
c002d73c:	c1 e0 02             	shl    $0x2,%eax
c002d73f:	89 d9                	mov    %ebx,%ecx
c002d741:	29 c1                	sub    %eax,%ecx
c002d743:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d746:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d74b:	f7 eb                	imul   %ebx
c002d74d:	c1 fa 05             	sar    $0x5,%edx
c002d750:	89 d8                	mov    %ebx,%eax
c002d752:	c1 f8 1f             	sar    $0x1f,%eax
c002d755:	29 c2                	sub    %eax,%edx
c002d757:	89 d0                	mov    %edx,%eax
c002d759:	ff 75 e8             	pushl  -0x18(%ebp)
c002d75c:	51                   	push   %ecx
c002d75d:	50                   	push   %eax
c002d75e:	68 5c 28 03 c0       	push   $0xc003285c
c002d763:	e8 9f e1 ff ff       	call   c002b907 <fail>
c002d768:	83 c4 10             	add    $0x10,%esp
c002d76b:	e9 52 ff ff ff       	jmp    c002d6c2 <test_mlfqs_load_1+0x49>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002d770:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002d774:	7f 1f                	jg     c002d795 <test_mlfqs_load_1+0x11c>
        break;
      else if (elapsed > 45)
c002d776:	83 7d e8 2d          	cmpl   $0x2d,-0x18(%ebp)
c002d77a:	0f 8e 42 ff ff ff    	jle    c002d6c2 <test_mlfqs_load_1+0x49>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002d780:	83 ec 0c             	sub    $0xc,%esp
c002d783:	68 a8 28 03 c0       	push   $0xc00328a8
c002d788:	e8 7a e1 ff ff       	call   c002b907 <fail>
c002d78d:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002d790:	e9 2d ff ff ff       	jmp    c002d6c2 <test_mlfqs_load_1+0x49>
        break;
c002d795:	90                   	nop
    }

  if (elapsed < 38)
c002d796:	83 7d e8 25          	cmpl   $0x25,-0x18(%ebp)
c002d79a:	7f 13                	jg     c002d7af <test_mlfqs_load_1+0x136>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002d79c:	83 ec 08             	sub    $0x8,%esp
c002d79f:	ff 75 e8             	pushl  -0x18(%ebp)
c002d7a2:	68 e0 28 03 c0       	push   $0xc00328e0
c002d7a7:	e8 5b e1 ff ff       	call   c002b907 <fail>
c002d7ac:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002d7af:	83 ec 08             	sub    $0x8,%esp
c002d7b2:	ff 75 e8             	pushl  -0x18(%ebp)
c002d7b5:	68 14 29 03 c0       	push   $0xc0032914
c002d7ba:	e8 04 e1 ff ff       	call   c002b8c3 <msg>
c002d7bf:	83 c4 10             	add    $0x10,%esp

  msg ("sleeping for another 10 seconds, please wait...");
c002d7c2:	83 ec 0c             	sub    $0xc,%esp
c002d7c5:	68 40 29 03 c0       	push   $0xc0032940
c002d7ca:	e8 f4 e0 ff ff       	call   c002b8c3 <msg>
c002d7cf:	83 c4 10             	add    $0x10,%esp
  timer_sleep (TIMER_FREQ * 10);
c002d7d2:	83 ec 08             	sub    $0x8,%esp
c002d7d5:	6a 00                	push   $0x0
c002d7d7:	68 e8 03 00 00       	push   $0x3e8
c002d7dc:	e8 11 65 ff ff       	call   c0023cf2 <timer_sleep>
c002d7e1:	83 c4 10             	add    $0x10,%esp

  load_avg = thread_get_load_avg ();
c002d7e4:	e8 b3 36 ff ff       	call   c0020e9c <thread_get_load_avg>
c002d7e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (load_avg < 0)
c002d7ec:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002d7f0:	79 10                	jns    c002d802 <test_mlfqs_load_1+0x189>
    fail ("load average fell below 0");
c002d7f2:	83 ec 0c             	sub    $0xc,%esp
c002d7f5:	68 70 29 03 c0       	push   $0xc0032970
c002d7fa:	e8 08 e1 ff ff       	call   c002b907 <fail>
c002d7ff:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c002d802:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002d806:	7e 10                	jle    c002d818 <test_mlfqs_load_1+0x19f>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002d808:	83 ec 0c             	sub    $0xc,%esp
c002d80b:	68 8c 29 03 c0       	push   $0xc003298c
c002d810:	e8 f2 e0 ff ff       	call   c002b907 <fail>
c002d815:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002d818:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d81b:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d820:	f7 eb                	imul   %ebx
c002d822:	c1 fa 05             	sar    $0x5,%edx
c002d825:	89 d8                	mov    %ebx,%eax
c002d827:	c1 f8 1f             	sar    $0x1f,%eax
c002d82a:	29 c2                	sub    %eax,%edx
c002d82c:	89 d1                	mov    %edx,%ecx
c002d82e:	89 c8                	mov    %ecx,%eax
c002d830:	c1 e0 02             	shl    $0x2,%eax
c002d833:	01 c8                	add    %ecx,%eax
c002d835:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d83c:	01 d0                	add    %edx,%eax
c002d83e:	c1 e0 02             	shl    $0x2,%eax
c002d841:	29 c3                	sub    %eax,%ebx
c002d843:	89 d9                	mov    %ebx,%ecx
c002d845:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d848:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d84d:	f7 eb                	imul   %ebx
c002d84f:	c1 fa 05             	sar    $0x5,%edx
c002d852:	89 d8                	mov    %ebx,%eax
c002d854:	c1 f8 1f             	sar    $0x1f,%eax
c002d857:	29 c2                	sub    %eax,%edx
c002d859:	89 d0                	mov    %edx,%eax
c002d85b:	83 ec 04             	sub    $0x4,%esp
c002d85e:	51                   	push   %ecx
c002d85f:	50                   	push   %eax
c002d860:	68 c4 29 03 c0       	push   $0xc00329c4
c002d865:	e8 59 e0 ff ff       	call   c002b8c3 <msg>
c002d86a:	83 c4 10             	add    $0x10,%esp
       load_avg / 100, load_avg % 100);

  pass ();
c002d86d:	e8 ec e0 ff ff       	call   c002b95e <pass>
}
c002d872:	90                   	nop
c002d873:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002d876:	c9                   	leave  
c002d877:	c3                   	ret    

c002d878 <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c002d878:	55                   	push   %ebp
c002d879:	89 e5                	mov    %esp,%ebp
c002d87b:	53                   	push   %ebx
c002d87c:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002d87f:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002d884:	84 c0                	test   %al,%al
c002d886:	75 1e                	jne    c002d8a6 <test_mlfqs_load_60+0x2e>
c002d888:	83 ec 0c             	sub    $0xc,%esp
c002d88b:	68 08 2a 03 c0       	push   $0xc0032a08
c002d890:	68 15 2a 03 c0       	push   $0xc0032a15
c002d895:	68 c8 2a 03 c0       	push   $0xc0032ac8
c002d89a:	6a 77                	push   $0x77
c002d89c:	68 2c 2a 03 c0       	push   $0xc0032a2c
c002d8a1:	e8 82 bc ff ff       	call   c0029528 <debug_panic>

  start_time = timer_ticks ();
c002d8a6:	e8 f3 63 ff ff       	call   c0023c9e <timer_ticks>
c002d8ab:	a3 70 8c 03 c0       	mov    %eax,0xc0038c70
c002d8b0:	89 15 74 8c 03 c0    	mov    %edx,0xc0038c74
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002d8b6:	83 ec 08             	sub    $0x8,%esp
c002d8b9:	6a 3c                	push   $0x3c
c002d8bb:	68 50 2a 03 c0       	push   $0xc0032a50
c002d8c0:	e8 fe df ff ff       	call   c002b8c3 <msg>
c002d8c5:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d8c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d8cf:	eb 2e                	jmp    c002d8ff <test_mlfqs_load_60+0x87>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002d8d1:	ff 75 f4             	pushl  -0xc(%ebp)
c002d8d4:	68 72 2a 03 c0       	push   $0xc0032a72
c002d8d9:	6a 10                	push   $0x10
c002d8db:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d8de:	50                   	push   %eax
c002d8df:	e8 5c 98 ff ff       	call   c0027140 <snprintf>
c002d8e4:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002d8e7:	6a 00                	push   $0x0
c002d8e9:	68 0f da 02 c0       	push   $0xc002da0f
c002d8ee:	6a 1f                	push   $0x1f
c002d8f0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002d8f3:	50                   	push   %eax
c002d8f4:	e8 51 31 ff ff       	call   c0020a4a <thread_create>
c002d8f9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d8fc:	ff 45 f4             	incl   -0xc(%ebp)
c002d8ff:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002d903:	7e cc                	jle    c002d8d1 <test_mlfqs_load_60+0x59>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002d905:	a1 70 8c 03 c0       	mov    0xc0038c70,%eax
c002d90a:	8b 15 74 8c 03 c0    	mov    0xc0038c74,%edx
c002d910:	83 ec 08             	sub    $0x8,%esp
c002d913:	52                   	push   %edx
c002d914:	50                   	push   %eax
c002d915:	e8 b9 63 ff ff       	call   c0023cd3 <timer_elapsed>
c002d91a:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c002d91d:	6a 00                	push   $0x0
c002d91f:	6a 64                	push   $0x64
c002d921:	52                   	push   %edx
c002d922:	50                   	push   %eax
c002d923:	e8 06 b6 ff ff       	call   c0028f2e <__divdi3>
c002d928:	83 c4 10             	add    $0x10,%esp
c002d92b:	83 ec 04             	sub    $0x4,%esp
c002d92e:	52                   	push   %edx
c002d92f:	50                   	push   %eax
c002d930:	68 7c 2a 03 c0       	push   $0xc0032a7c
c002d935:	e8 89 df ff ff       	call   c002b8c3 <msg>
c002d93a:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 90; i++) 
c002d93d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d944:	e9 b6 00 00 00       	jmp    c002d9ff <test_mlfqs_load_60+0x187>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002d949:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d94c:	8d 50 05             	lea    0x5(%eax),%edx
c002d94f:	89 d0                	mov    %edx,%eax
c002d951:	c1 e0 02             	shl    $0x2,%eax
c002d954:	01 d0                	add    %edx,%eax
c002d956:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d95d:	01 d0                	add    %edx,%eax
c002d95f:	c1 e0 03             	shl    $0x3,%eax
c002d962:	89 c1                	mov    %eax,%ecx
c002d964:	89 c3                	mov    %eax,%ebx
c002d966:	c1 fb 1f             	sar    $0x1f,%ebx
c002d969:	a1 70 8c 03 c0       	mov    0xc0038c70,%eax
c002d96e:	8b 15 74 8c 03 c0    	mov    0xc0038c74,%edx
c002d974:	01 c8                	add    %ecx,%eax
c002d976:	11 da                	adc    %ebx,%edx
c002d978:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002d97b:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002d97e:	e8 1b 63 ff ff       	call   c0023c9e <timer_ticks>
c002d983:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002d986:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002d989:	29 c1                	sub    %eax,%ecx
c002d98b:	19 d3                	sbb    %edx,%ebx
c002d98d:	89 c8                	mov    %ecx,%eax
c002d98f:	89 da                	mov    %ebx,%edx
c002d991:	83 ec 08             	sub    $0x8,%esp
c002d994:	52                   	push   %edx
c002d995:	50                   	push   %eax
c002d996:	e8 57 63 ff ff       	call   c0023cf2 <timer_sleep>
c002d99b:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002d99e:	e8 f9 34 ff ff       	call   c0020e9c <thread_get_load_avg>
c002d9a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002d9a6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002d9a9:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d9ae:	f7 eb                	imul   %ebx
c002d9b0:	c1 fa 05             	sar    $0x5,%edx
c002d9b3:	89 d8                	mov    %ebx,%eax
c002d9b5:	c1 f8 1f             	sar    $0x1f,%eax
c002d9b8:	89 d1                	mov    %edx,%ecx
c002d9ba:	29 c1                	sub    %eax,%ecx
c002d9bc:	89 c8                	mov    %ecx,%eax
c002d9be:	c1 e0 02             	shl    $0x2,%eax
c002d9c1:	01 c8                	add    %ecx,%eax
c002d9c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002d9ca:	01 d0                	add    %edx,%eax
c002d9cc:	c1 e0 02             	shl    $0x2,%eax
c002d9cf:	29 c3                	sub    %eax,%ebx
c002d9d1:	89 d9                	mov    %ebx,%ecx
c002d9d3:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002d9d6:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002d9db:	f7 eb                	imul   %ebx
c002d9dd:	c1 fa 05             	sar    $0x5,%edx
c002d9e0:	89 d8                	mov    %ebx,%eax
c002d9e2:	c1 f8 1f             	sar    $0x1f,%eax
c002d9e5:	29 c2                	sub    %eax,%edx
c002d9e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d9ea:	01 c0                	add    %eax,%eax
c002d9ec:	51                   	push   %ecx
c002d9ed:	52                   	push   %edx
c002d9ee:	50                   	push   %eax
c002d9ef:	68 a0 2a 03 c0       	push   $0xc0032aa0
c002d9f4:	e8 ca de ff ff       	call   c002b8c3 <msg>
c002d9f9:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c002d9fc:	ff 45 f4             	incl   -0xc(%ebp)
c002d9ff:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002da03:	0f 8e 40 ff ff ff    	jle    c002d949 <test_mlfqs_load_60+0xd1>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002da09:	90                   	nop
c002da0a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002da0d:	c9                   	leave  
c002da0e:	c3                   	ret    

c002da0f <load_thread>:

static void
load_thread (void *aux UNUSED) 
{
c002da0f:	55                   	push   %ebp
c002da10:	89 e5                	mov    %esp,%ebp
c002da12:	53                   	push   %ebx
c002da13:	83 ec 24             	sub    $0x24,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
c002da16:	c7 45 f0 e8 03 00 00 	movl   $0x3e8,-0x10(%ebp)
c002da1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
c002da24:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002da27:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002da2a:	05 70 17 00 00       	add    $0x1770,%eax
c002da2f:	83 d2 00             	adc    $0x0,%edx
c002da32:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002da35:	89 55 ec             	mov    %edx,-0x14(%ebp)
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;
c002da38:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002da3b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002da3e:	05 70 17 00 00       	add    $0x1770,%eax
c002da43:	83 d2 00             	adc    $0x0,%edx
c002da46:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002da49:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  thread_set_nice (20);
c002da4c:	83 ec 0c             	sub    $0xc,%esp
c002da4f:	6a 14                	push   $0x14
c002da51:	e8 36 34 ff ff       	call   c0020e8c <thread_set_nice>
c002da56:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002da59:	a1 70 8c 03 c0       	mov    0xc0038c70,%eax
c002da5e:	8b 15 74 8c 03 c0    	mov    0xc0038c74,%edx
c002da64:	83 ec 08             	sub    $0x8,%esp
c002da67:	52                   	push   %edx
c002da68:	50                   	push   %eax
c002da69:	e8 65 62 ff ff       	call   c0023cd3 <timer_elapsed>
c002da6e:	83 c4 10             	add    $0x10,%esp
c002da71:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c002da74:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c002da77:	29 c1                	sub    %eax,%ecx
c002da79:	19 d3                	sbb    %edx,%ebx
c002da7b:	89 c8                	mov    %ecx,%eax
c002da7d:	89 da                	mov    %ebx,%edx
c002da7f:	83 ec 08             	sub    $0x8,%esp
c002da82:	52                   	push   %edx
c002da83:	50                   	push   %eax
c002da84:	e8 69 62 ff ff       	call   c0023cf2 <timer_sleep>
c002da89:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002da8c:	eb 01                	jmp    c002da8f <load_thread+0x80>
    continue;
c002da8e:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c002da8f:	a1 70 8c 03 c0       	mov    0xc0038c70,%eax
c002da94:	8b 15 74 8c 03 c0    	mov    0xc0038c74,%edx
c002da9a:	83 ec 08             	sub    $0x8,%esp
c002da9d:	52                   	push   %edx
c002da9e:	50                   	push   %eax
c002da9f:	e8 2f 62 ff ff       	call   c0023cd3 <timer_elapsed>
c002daa4:	83 c4 10             	add    $0x10,%esp
c002daa7:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002daaa:	7c e2                	jl     c002da8e <load_thread+0x7f>
c002daac:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002daaf:	7f 05                	jg     c002dab6 <load_thread+0xa7>
c002dab1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002dab4:	72 d8                	jb     c002da8e <load_thread+0x7f>
  timer_sleep (exit_time - timer_elapsed (start_time));
c002dab6:	a1 70 8c 03 c0       	mov    0xc0038c70,%eax
c002dabb:	8b 15 74 8c 03 c0    	mov    0xc0038c74,%edx
c002dac1:	83 ec 08             	sub    $0x8,%esp
c002dac4:	52                   	push   %edx
c002dac5:	50                   	push   %eax
c002dac6:	e8 08 62 ff ff       	call   c0023cd3 <timer_elapsed>
c002dacb:	83 c4 10             	add    $0x10,%esp
c002dace:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002dad1:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dad4:	29 c1                	sub    %eax,%ecx
c002dad6:	19 d3                	sbb    %edx,%ebx
c002dad8:	89 c8                	mov    %ecx,%eax
c002dada:	89 da                	mov    %ebx,%edx
c002dadc:	83 ec 08             	sub    $0x8,%esp
c002dadf:	52                   	push   %edx
c002dae0:	50                   	push   %eax
c002dae1:	e8 0c 62 ff ff       	call   c0023cf2 <timer_sleep>
c002dae6:	83 c4 10             	add    $0x10,%esp
}
c002dae9:	90                   	nop
c002daea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002daed:	c9                   	leave  
c002daee:	c3                   	ret    

c002daef <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c002daef:	55                   	push   %ebp
c002daf0:	89 e5                	mov    %esp,%ebp
c002daf2:	53                   	push   %ebx
c002daf3:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002daf6:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002dafb:	84 c0                	test   %al,%al
c002dafd:	75 21                	jne    c002db20 <test_mlfqs_load_avg+0x31>
c002daff:	83 ec 0c             	sub    $0xc,%esp
c002db02:	68 dc 2a 03 c0       	push   $0xc0032adc
c002db07:	68 e9 2a 03 c0       	push   $0xc0032ae9
c002db0c:	68 98 2b 03 c0       	push   $0xc0032b98
c002db11:	68 82 00 00 00       	push   $0x82
c002db16:	68 00 2b 03 c0       	push   $0xc0032b00
c002db1b:	e8 08 ba ff ff       	call   c0029528 <debug_panic>

  start_time = timer_ticks ();
c002db20:	e8 79 61 ff ff       	call   c0023c9e <timer_ticks>
c002db25:	a3 78 8c 03 c0       	mov    %eax,0xc0038c78
c002db2a:	89 15 7c 8c 03 c0    	mov    %edx,0xc0038c7c
  msg ("Starting %d load threads...", THREAD_CNT);
c002db30:	83 ec 08             	sub    $0x8,%esp
c002db33:	6a 3c                	push   $0x3c
c002db35:	68 25 2b 03 c0       	push   $0xc0032b25
c002db3a:	e8 84 dd ff ff       	call   c002b8c3 <msg>
c002db3f:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002db42:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002db49:	eb 30                	jmp    c002db7b <test_mlfqs_load_avg+0x8c>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002db4b:	ff 75 f4             	pushl  -0xc(%ebp)
c002db4e:	68 41 2b 03 c0       	push   $0xc0032b41
c002db53:	6a 10                	push   $0x10
c002db55:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002db58:	50                   	push   %eax
c002db59:	e8 e2 95 ff ff       	call   c0027140 <snprintf>
c002db5e:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002db61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002db64:	50                   	push   %eax
c002db65:	68 98 dc 02 c0       	push   $0xc002dc98
c002db6a:	6a 1f                	push   $0x1f
c002db6c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002db6f:	50                   	push   %eax
c002db70:	e8 d5 2e ff ff       	call   c0020a4a <thread_create>
c002db75:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002db78:	ff 45 f4             	incl   -0xc(%ebp)
c002db7b:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002db7f:	7e ca                	jle    c002db4b <test_mlfqs_load_avg+0x5c>
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002db81:	a1 78 8c 03 c0       	mov    0xc0038c78,%eax
c002db86:	8b 15 7c 8c 03 c0    	mov    0xc0038c7c,%edx
c002db8c:	83 ec 08             	sub    $0x8,%esp
c002db8f:	52                   	push   %edx
c002db90:	50                   	push   %eax
c002db91:	e8 3d 61 ff ff       	call   c0023cd3 <timer_elapsed>
c002db96:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %d seconds.",
c002db99:	6a 00                	push   $0x0
c002db9b:	6a 64                	push   $0x64
c002db9d:	52                   	push   %edx
c002db9e:	50                   	push   %eax
c002db9f:	e8 8a b3 ff ff       	call   c0028f2e <__divdi3>
c002dba4:	83 c4 10             	add    $0x10,%esp
c002dba7:	83 ec 04             	sub    $0x4,%esp
c002dbaa:	52                   	push   %edx
c002dbab:	50                   	push   %eax
c002dbac:	68 4c 2b 03 c0       	push   $0xc0032b4c
c002dbb1:	e8 0d dd ff ff       	call   c002b8c3 <msg>
c002dbb6:	83 c4 10             	add    $0x10,%esp
  thread_set_nice (-20);
c002dbb9:	83 ec 0c             	sub    $0xc,%esp
c002dbbc:	6a ec                	push   $0xffffffec
c002dbbe:	e8 c9 32 ff ff       	call   c0020e8c <thread_set_nice>
c002dbc3:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 90; i++) 
c002dbc6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dbcd:	e9 b6 00 00 00       	jmp    c002dc88 <test_mlfqs_load_avg+0x199>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002dbd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dbd5:	8d 50 05             	lea    0x5(%eax),%edx
c002dbd8:	89 d0                	mov    %edx,%eax
c002dbda:	c1 e0 02             	shl    $0x2,%eax
c002dbdd:	01 d0                	add    %edx,%eax
c002dbdf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002dbe6:	01 d0                	add    %edx,%eax
c002dbe8:	c1 e0 03             	shl    $0x3,%eax
c002dbeb:	89 c1                	mov    %eax,%ecx
c002dbed:	89 c3                	mov    %eax,%ebx
c002dbef:	c1 fb 1f             	sar    $0x1f,%ebx
c002dbf2:	a1 78 8c 03 c0       	mov    0xc0038c78,%eax
c002dbf7:	8b 15 7c 8c 03 c0    	mov    0xc0038c7c,%edx
c002dbfd:	01 c8                	add    %ecx,%eax
c002dbff:	11 da                	adc    %ebx,%edx
c002dc01:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002dc04:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002dc07:	e8 92 60 ff ff       	call   c0023c9e <timer_ticks>
c002dc0c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002dc0f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002dc12:	29 c1                	sub    %eax,%ecx
c002dc14:	19 d3                	sbb    %edx,%ebx
c002dc16:	89 c8                	mov    %ecx,%eax
c002dc18:	89 da                	mov    %ebx,%edx
c002dc1a:	83 ec 08             	sub    $0x8,%esp
c002dc1d:	52                   	push   %edx
c002dc1e:	50                   	push   %eax
c002dc1f:	e8 ce 60 ff ff       	call   c0023cf2 <timer_sleep>
c002dc24:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002dc27:	e8 70 32 ff ff       	call   c0020e9c <thread_get_load_avg>
c002dc2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002dc2f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dc32:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002dc37:	f7 eb                	imul   %ebx
c002dc39:	c1 fa 05             	sar    $0x5,%edx
c002dc3c:	89 d8                	mov    %ebx,%eax
c002dc3e:	c1 f8 1f             	sar    $0x1f,%eax
c002dc41:	89 d1                	mov    %edx,%ecx
c002dc43:	29 c1                	sub    %eax,%ecx
c002dc45:	89 c8                	mov    %ecx,%eax
c002dc47:	c1 e0 02             	shl    $0x2,%eax
c002dc4a:	01 c8                	add    %ecx,%eax
c002dc4c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002dc53:	01 d0                	add    %edx,%eax
c002dc55:	c1 e0 02             	shl    $0x2,%eax
c002dc58:	29 c3                	sub    %eax,%ebx
c002dc5a:	89 d9                	mov    %ebx,%ecx
c002dc5c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002dc5f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002dc64:	f7 eb                	imul   %ebx
c002dc66:	c1 fa 05             	sar    $0x5,%edx
c002dc69:	89 d8                	mov    %ebx,%eax
c002dc6b:	c1 f8 1f             	sar    $0x1f,%eax
c002dc6e:	29 c2                	sub    %eax,%edx
c002dc70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc73:	01 c0                	add    %eax,%eax
c002dc75:	51                   	push   %ecx
c002dc76:	52                   	push   %edx
c002dc77:	50                   	push   %eax
c002dc78:	68 70 2b 03 c0       	push   $0xc0032b70
c002dc7d:	e8 41 dc ff ff       	call   c002b8c3 <msg>
c002dc82:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 90; i++) 
c002dc85:	ff 45 f4             	incl   -0xc(%ebp)
c002dc88:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002dc8c:	0f 8e 40 ff ff ff    	jle    c002dbd2 <test_mlfqs_load_avg+0xe3>
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002dc92:	90                   	nop
c002dc93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dc96:	c9                   	leave  
c002dc97:	c3                   	ret    

c002dc98 <load_thread>:

static void
load_thread (void *seq_no_) 
{
c002dc98:	55                   	push   %ebp
c002dc99:	89 e5                	mov    %esp,%ebp
c002dc9b:	56                   	push   %esi
c002dc9c:	53                   	push   %ebx
c002dc9d:	83 ec 10             	sub    $0x10,%esp
  int seq_no = (int) seq_no_;
c002dca0:	8b 45 08             	mov    0x8(%ebp),%eax
c002dca3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002dca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dca9:	8d 50 0a             	lea    0xa(%eax),%edx
c002dcac:	89 d0                	mov    %edx,%eax
c002dcae:	c1 e0 02             	shl    $0x2,%eax
c002dcb1:	01 d0                	add    %edx,%eax
c002dcb3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002dcba:	01 d0                	add    %edx,%eax
c002dcbc:	c1 e0 02             	shl    $0x2,%eax
c002dcbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002dcc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dcc5:	05 70 17 00 00       	add    $0x1770,%eax
c002dcca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);
c002dccd:	c7 45 e8 e0 2e 00 00 	movl   $0x2ee0,-0x18(%ebp)

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002dcd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dcd7:	89 c3                	mov    %eax,%ebx
c002dcd9:	89 c6                	mov    %eax,%esi
c002dcdb:	c1 fe 1f             	sar    $0x1f,%esi
c002dcde:	a1 78 8c 03 c0       	mov    0xc0038c78,%eax
c002dce3:	8b 15 7c 8c 03 c0    	mov    0xc0038c7c,%edx
c002dce9:	83 ec 08             	sub    $0x8,%esp
c002dcec:	52                   	push   %edx
c002dced:	50                   	push   %eax
c002dcee:	e8 e0 5f ff ff       	call   c0023cd3 <timer_elapsed>
c002dcf3:	83 c4 10             	add    $0x10,%esp
c002dcf6:	29 c3                	sub    %eax,%ebx
c002dcf8:	19 d6                	sbb    %edx,%esi
c002dcfa:	89 d8                	mov    %ebx,%eax
c002dcfc:	89 f2                	mov    %esi,%edx
c002dcfe:	83 ec 08             	sub    $0x8,%esp
c002dd01:	52                   	push   %edx
c002dd02:	50                   	push   %eax
c002dd03:	e8 ea 5f ff ff       	call   c0023cf2 <timer_sleep>
c002dd08:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002dd0b:	eb 01                	jmp    c002dd0e <load_thread+0x76>
    continue;
c002dd0d:	90                   	nop
  while (timer_elapsed (start_time) < spin_time)
c002dd0e:	a1 78 8c 03 c0       	mov    0xc0038c78,%eax
c002dd13:	8b 15 7c 8c 03 c0    	mov    0xc0038c7c,%edx
c002dd19:	83 ec 08             	sub    $0x8,%esp
c002dd1c:	52                   	push   %edx
c002dd1d:	50                   	push   %eax
c002dd1e:	e8 b0 5f ff ff       	call   c0023cd3 <timer_elapsed>
c002dd23:	83 c4 10             	add    $0x10,%esp
c002dd26:	89 c1                	mov    %eax,%ecx
c002dd28:	89 d3                	mov    %edx,%ebx
c002dd2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002dd2d:	99                   	cltd   
c002dd2e:	39 d3                	cmp    %edx,%ebx
c002dd30:	7c db                	jl     c002dd0d <load_thread+0x75>
c002dd32:	39 d3                	cmp    %edx,%ebx
c002dd34:	7f 04                	jg     c002dd3a <load_thread+0xa2>
c002dd36:	39 c1                	cmp    %eax,%ecx
c002dd38:	72 d3                	jb     c002dd0d <load_thread+0x75>
  timer_sleep (exit_time - timer_elapsed (start_time));
c002dd3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002dd3d:	89 c3                	mov    %eax,%ebx
c002dd3f:	89 c6                	mov    %eax,%esi
c002dd41:	c1 fe 1f             	sar    $0x1f,%esi
c002dd44:	a1 78 8c 03 c0       	mov    0xc0038c78,%eax
c002dd49:	8b 15 7c 8c 03 c0    	mov    0xc0038c7c,%edx
c002dd4f:	83 ec 08             	sub    $0x8,%esp
c002dd52:	52                   	push   %edx
c002dd53:	50                   	push   %eax
c002dd54:	e8 7a 5f ff ff       	call   c0023cd3 <timer_elapsed>
c002dd59:	83 c4 10             	add    $0x10,%esp
c002dd5c:	29 c3                	sub    %eax,%ebx
c002dd5e:	19 d6                	sbb    %edx,%esi
c002dd60:	89 d8                	mov    %ebx,%eax
c002dd62:	89 f2                	mov    %esi,%edx
c002dd64:	83 ec 08             	sub    $0x8,%esp
c002dd67:	52                   	push   %edx
c002dd68:	50                   	push   %eax
c002dd69:	e8 84 5f ff ff       	call   c0023cf2 <timer_sleep>
c002dd6e:	83 c4 10             	add    $0x10,%esp
}
c002dd71:	90                   	nop
c002dd72:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002dd75:	5b                   	pop    %ebx
c002dd76:	5e                   	pop    %esi
c002dd77:	5d                   	pop    %ebp
c002dd78:	c3                   	ret    

c002dd79 <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002dd79:	55                   	push   %ebp
c002dd7a:	89 e5                	mov    %esp,%ebp
c002dd7c:	57                   	push   %edi
c002dd7d:	56                   	push   %esi
c002dd7e:	53                   	push   %ebx
c002dd7f:	83 ec 2c             	sub    $0x2c,%esp
  int64_t start_time;
  int last_elapsed = 0;
c002dd82:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  
  ASSERT (thread_mlfqs);
c002dd89:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002dd8e:	84 c0                	test   %al,%al
c002dd90:	75 1e                	jne    c002ddb0 <test_mlfqs_recent_1+0x37>
c002dd92:	83 ec 0c             	sub    $0xc,%esp
c002dd95:	68 ac 2b 03 c0       	push   $0xc0032bac
c002dd9a:	68 b9 2b 03 c0       	push   $0xc0032bb9
c002dd9f:	68 7c 2c 03 c0       	push   $0xc0032c7c
c002dda4:	6a 73                	push   $0x73
c002dda6:	68 d0 2b 03 c0       	push   $0xc0032bd0
c002ddab:	e8 78 b7 ff ff       	call   c0029528 <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002ddb0:	83 ec 0c             	sub    $0xc,%esp
c002ddb3:	68 f8 2b 03 c0       	push   $0xc0032bf8
c002ddb8:	e8 06 db ff ff       	call   c002b8c3 <msg>
c002ddbd:	83 c4 10             	add    $0x10,%esp
      start_time = timer_ticks ();
c002ddc0:	e8 d9 5e ff ff       	call   c0023c9e <timer_ticks>
c002ddc5:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002ddc8:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002ddcb:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002ddce:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002ddd1:	83 c0 63             	add    $0x63,%eax
c002ddd4:	83 d2 00             	adc    $0x0,%edx
c002ddd7:	6a 00                	push   $0x0
c002ddd9:	6a 64                	push   $0x64
c002dddb:	52                   	push   %edx
c002dddc:	50                   	push   %eax
c002dddd:	e8 4c b1 ff ff       	call   c0028f2e <__divdi3>
c002dde2:	83 c4 10             	add    $0x10,%esp
c002dde5:	2b 45 d8             	sub    -0x28(%ebp),%eax
c002dde8:	1b 55 dc             	sbb    -0x24(%ebp),%edx
c002ddeb:	05 e8 03 00 00       	add    $0x3e8,%eax
c002ddf0:	83 d2 00             	adc    $0x0,%edx
c002ddf3:	83 ec 08             	sub    $0x8,%esp
c002ddf6:	52                   	push   %edx
c002ddf7:	50                   	push   %eax
c002ddf8:	e8 f5 5e ff ff       	call   c0023cf2 <timer_sleep>
c002ddfd:	83 c4 10             	add    $0x10,%esp
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002de00:	e8 a1 30 ff ff       	call   c0020ea6 <thread_get_recent_cpu>
c002de05:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002de0a:	7f a4                	jg     c002ddb0 <test_mlfqs_recent_1+0x37>

  start_time = timer_ticks ();
c002de0c:	e8 8d 5e ff ff       	call   c0023c9e <timer_ticks>
c002de11:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002de14:	89 55 dc             	mov    %edx,-0x24(%ebp)
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002de17:	83 ec 08             	sub    $0x8,%esp
c002de1a:	ff 75 dc             	pushl  -0x24(%ebp)
c002de1d:	ff 75 d8             	pushl  -0x28(%ebp)
c002de20:	e8 ae 5e ff ff       	call   c0023cd3 <timer_elapsed>
c002de25:	83 c4 10             	add    $0x10,%esp
c002de28:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002de2b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002de2e:	b9 c8 00 00 00       	mov    $0xc8,%ecx
c002de33:	99                   	cltd   
c002de34:	f7 f9                	idiv   %ecx
c002de36:	89 d0                	mov    %edx,%eax
c002de38:	85 c0                	test   %eax,%eax
c002de3a:	0f 85 db 00 00 00    	jne    c002df1b <test_mlfqs_recent_1+0x1a2>
c002de40:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002de43:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002de46:	0f 8e cf 00 00 00    	jle    c002df1b <test_mlfqs_recent_1+0x1a2>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002de4c:	e8 55 30 ff ff       	call   c0020ea6 <thread_get_recent_cpu>
c002de51:	89 45 d0             	mov    %eax,-0x30(%ebp)
          int load_avg = thread_get_load_avg ();
c002de54:	e8 43 30 ff ff       	call   c0020e9c <thread_get_load_avg>
c002de59:	89 45 cc             	mov    %eax,-0x34(%ebp)
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002de5c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002de5f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002de64:	f7 e9                	imul   %ecx
c002de66:	c1 fa 05             	sar    $0x5,%edx
c002de69:	89 c8                	mov    %ecx,%eax
c002de6b:	c1 f8 1f             	sar    $0x1f,%eax
c002de6e:	29 c2                	sub    %eax,%edx
c002de70:	89 d0                	mov    %edx,%eax
c002de72:	89 45 c8             	mov    %eax,-0x38(%ebp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002de75:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002de78:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002de7d:	f7 e9                	imul   %ecx
c002de7f:	c1 fa 05             	sar    $0x5,%edx
c002de82:	89 c8                	mov    %ecx,%eax
c002de84:	c1 f8 1f             	sar    $0x1f,%eax
c002de87:	89 d3                	mov    %edx,%ebx
c002de89:	29 c3                	sub    %eax,%ebx
c002de8b:	89 d8                	mov    %ebx,%eax
c002de8d:	c1 e0 02             	shl    $0x2,%eax
c002de90:	01 d8                	add    %ebx,%eax
c002de92:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002de99:	01 d0                	add    %edx,%eax
c002de9b:	c1 e0 02             	shl    $0x2,%eax
c002de9e:	89 cb                	mov    %ecx,%ebx
c002dea0:	29 c3                	sub    %eax,%ebx
c002dea2:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002dea5:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002deaa:	f7 e9                	imul   %ecx
c002deac:	c1 fa 05             	sar    $0x5,%edx
c002deaf:	89 c8                	mov    %ecx,%eax
c002deb1:	c1 f8 1f             	sar    $0x1f,%eax
c002deb4:	89 d7                	mov    %edx,%edi
c002deb6:	29 c7                	sub    %eax,%edi
c002deb8:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002debb:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002dec0:	f7 ee                	imul   %esi
c002dec2:	c1 fa 05             	sar    $0x5,%edx
c002dec5:	89 f0                	mov    %esi,%eax
c002dec7:	c1 f8 1f             	sar    $0x1f,%eax
c002deca:	89 d1                	mov    %edx,%ecx
c002decc:	29 c1                	sub    %eax,%ecx
c002dece:	89 c8                	mov    %ecx,%eax
c002ded0:	c1 e0 02             	shl    $0x2,%eax
c002ded3:	01 c8                	add    %ecx,%eax
c002ded5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002dedc:	01 d0                	add    %edx,%eax
c002dede:	c1 e0 02             	shl    $0x2,%eax
c002dee1:	29 c6                	sub    %eax,%esi
c002dee3:	89 f1                	mov    %esi,%ecx
c002dee5:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002dee8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c002deed:	f7 ee                	imul   %esi
c002deef:	c1 fa 05             	sar    $0x5,%edx
c002def2:	89 f0                	mov    %esi,%eax
c002def4:	c1 f8 1f             	sar    $0x1f,%eax
c002def7:	29 c2                	sub    %eax,%edx
c002def9:	89 d0                	mov    %edx,%eax
c002defb:	83 ec 08             	sub    $0x8,%esp
c002defe:	53                   	push   %ebx
c002deff:	57                   	push   %edi
c002df00:	51                   	push   %ecx
c002df01:	50                   	push   %eax
c002df02:	ff 75 c8             	pushl  -0x38(%ebp)
c002df05:	68 3c 2c 03 c0       	push   $0xc0032c3c
c002df0a:	e8 b4 d9 ff ff       	call   c002b8c3 <msg>
c002df0f:	83 c4 20             	add    $0x20,%esp
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002df12:	81 7d c8 b3 00 00 00 	cmpl   $0xb3,-0x38(%ebp)
c002df19:	7f 0b                	jg     c002df26 <test_mlfqs_recent_1+0x1ad>
            break;
        } 
      last_elapsed = elapsed;
c002df1b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002df1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    {
c002df21:	e9 f1 fe ff ff       	jmp    c002de17 <test_mlfqs_recent_1+0x9e>
            break;
c002df26:	90                   	nop
    }
}
c002df27:	90                   	nop
c002df28:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002df2b:	5b                   	pop    %ebx
c002df2c:	5e                   	pop    %esi
c002df2d:	5f                   	pop    %edi
c002df2e:	5d                   	pop    %ebp
c002df2f:	c3                   	ret    

c002df30 <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c002df30:	55                   	push   %ebp
c002df31:	89 e5                	mov    %esp,%ebp
c002df33:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 0);
c002df36:	83 ec 04             	sub    $0x4,%esp
c002df39:	6a 00                	push   $0x0
c002df3b:	6a 00                	push   $0x0
c002df3d:	6a 02                	push   $0x2
c002df3f:	e8 54 00 00 00       	call   c002df98 <test_mlfqs_fair>
c002df44:	83 c4 10             	add    $0x10,%esp
}
c002df47:	90                   	nop
c002df48:	c9                   	leave  
c002df49:	c3                   	ret    

c002df4a <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c002df4a:	55                   	push   %ebp
c002df4b:	89 e5                	mov    %esp,%ebp
c002df4d:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (20, 0, 0);
c002df50:	83 ec 04             	sub    $0x4,%esp
c002df53:	6a 00                	push   $0x0
c002df55:	6a 00                	push   $0x0
c002df57:	6a 14                	push   $0x14
c002df59:	e8 3a 00 00 00       	call   c002df98 <test_mlfqs_fair>
c002df5e:	83 c4 10             	add    $0x10,%esp
}
c002df61:	90                   	nop
c002df62:	c9                   	leave  
c002df63:	c3                   	ret    

c002df64 <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c002df64:	55                   	push   %ebp
c002df65:	89 e5                	mov    %esp,%ebp
c002df67:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 5);
c002df6a:	83 ec 04             	sub    $0x4,%esp
c002df6d:	6a 05                	push   $0x5
c002df6f:	6a 00                	push   $0x0
c002df71:	6a 02                	push   $0x2
c002df73:	e8 20 00 00 00       	call   c002df98 <test_mlfqs_fair>
c002df78:	83 c4 10             	add    $0x10,%esp
}
c002df7b:	90                   	nop
c002df7c:	c9                   	leave  
c002df7d:	c3                   	ret    

c002df7e <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c002df7e:	55                   	push   %ebp
c002df7f:	89 e5                	mov    %esp,%ebp
c002df81:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (10, 0, 1);
c002df84:	83 ec 04             	sub    $0x4,%esp
c002df87:	6a 01                	push   $0x1
c002df89:	6a 00                	push   $0x0
c002df8b:	6a 0a                	push   $0xa
c002df8d:	e8 06 00 00 00       	call   c002df98 <test_mlfqs_fair>
c002df92:	83 c4 10             	add    $0x10,%esp
}
c002df95:	90                   	nop
c002df96:	c9                   	leave  
c002df97:	c3                   	ret    

c002df98 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002df98:	55                   	push   %ebp
c002df99:	89 e5                	mov    %esp,%ebp
c002df9b:	81 ec 78 01 00 00    	sub    $0x178,%esp
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002dfa1:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002dfa6:	84 c0                	test   %al,%al
c002dfa8:	75 1e                	jne    c002dfc8 <test_mlfqs_fair+0x30>
c002dfaa:	83 ec 0c             	sub    $0xc,%esp
c002dfad:	68 90 2c 03 c0       	push   $0xc0032c90
c002dfb2:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002dfb7:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002dfbc:	6a 49                	push   $0x49
c002dfbe:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002dfc3:	e8 60 b5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002dfc8:	83 7d 08 14          	cmpl   $0x14,0x8(%ebp)
c002dfcc:	7e 1e                	jle    c002dfec <test_mlfqs_fair+0x54>
c002dfce:	83 ec 0c             	sub    $0xc,%esp
c002dfd1:	68 d5 2c 03 c0       	push   $0xc0032cd5
c002dfd6:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002dfdb:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002dfe0:	6a 4a                	push   $0x4a
c002dfe2:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002dfe7:	e8 3c b5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (nice_min >= -10);
c002dfec:	83 7d 0c f6          	cmpl   $0xfffffff6,0xc(%ebp)
c002dff0:	7d 1e                	jge    c002e010 <test_mlfqs_fair+0x78>
c002dff2:	83 ec 0c             	sub    $0xc,%esp
c002dff5:	68 f2 2c 03 c0       	push   $0xc0032cf2
c002dffa:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002dfff:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002e004:	6a 4b                	push   $0x4b
c002e006:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002e00b:	e8 18 b5 ff ff       	call   c0029528 <debug_panic>
  ASSERT (nice_step >= 0);
c002e010:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e014:	79 1e                	jns    c002e034 <test_mlfqs_fair+0x9c>
c002e016:	83 ec 0c             	sub    $0xc,%esp
c002e019:	68 02 2d 03 c0       	push   $0xc0032d02
c002e01e:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002e023:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002e028:	6a 4c                	push   $0x4c
c002e02a:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002e02f:	e8 f4 b4 ff ff       	call   c0029528 <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002e034:	8b 45 08             	mov    0x8(%ebp),%eax
c002e037:	48                   	dec    %eax
c002e038:	0f af 45 10          	imul   0x10(%ebp),%eax
c002e03c:	89 c2                	mov    %eax,%edx
c002e03e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e041:	01 d0                	add    %edx,%eax
c002e043:	83 f8 14             	cmp    $0x14,%eax
c002e046:	7e 1e                	jle    c002e066 <test_mlfqs_fair+0xce>
c002e048:	83 ec 0c             	sub    $0xc,%esp
c002e04b:	68 14 2d 03 c0       	push   $0xc0032d14
c002e050:	68 9d 2c 03 c0       	push   $0xc0032c9d
c002e055:	68 dc 2d 03 c0       	push   $0xc0032ddc
c002e05a:	6a 4d                	push   $0x4d
c002e05c:	68 b4 2c 03 c0       	push   $0xc0032cb4
c002e061:	e8 c2 b4 ff ff       	call   c0029528 <debug_panic>

  thread_set_nice (-20);
c002e066:	83 ec 0c             	sub    $0xc,%esp
c002e069:	6a ec                	push   $0xffffffec
c002e06b:	e8 1c 2e ff ff       	call   c0020e8c <thread_set_nice>
c002e070:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002e073:	e8 26 5c ff ff       	call   c0023c9e <timer_ticks>
c002e078:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e07b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg ("Starting %d threads...", thread_cnt);
c002e07e:	83 ec 08             	sub    $0x8,%esp
c002e081:	ff 75 08             	pushl  0x8(%ebp)
c002e084:	68 42 2d 03 c0       	push   $0xc0032d42
c002e089:	e8 35 d8 ff ff       	call   c002b8c3 <msg>
c002e08e:	83 c4 10             	add    $0x10,%esp
  nice = nice_min;
c002e091:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e094:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002e097:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e09e:	eb 6d                	jmp    c002e10d <test_mlfqs_fair+0x175>
    {
      struct thread_info *ti = &info[i];
c002e0a0:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002e0a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002e0a9:	c1 e2 04             	shl    $0x4,%edx
c002e0ac:	01 d0                	add    %edx,%eax
c002e0ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      char name[16];

      ti->start_time = start_time;
c002e0b1:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002e0b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e0b7:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e0ba:	89 01                	mov    %eax,(%ecx)
c002e0bc:	89 51 04             	mov    %edx,0x4(%ecx)
      ti->tick_count = 0;
c002e0bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e0c2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      ti->nice = nice;
c002e0c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e0cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e0cf:	89 50 0c             	mov    %edx,0xc(%eax)

      snprintf(name, sizeof name, "load %d", i);
c002e0d2:	ff 75 f0             	pushl  -0x10(%ebp)
c002e0d5:	68 59 2d 03 c0       	push   $0xc0032d59
c002e0da:	6a 10                	push   $0x10
c002e0dc:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e0e2:	50                   	push   %eax
c002e0e3:	e8 58 90 ff ff       	call   c0027140 <snprintf>
c002e0e8:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002e0eb:	ff 75 e4             	pushl  -0x1c(%ebp)
c002e0ee:	68 97 e1 02 c0       	push   $0xc002e197
c002e0f3:	6a 1f                	push   $0x1f
c002e0f5:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e0fb:	50                   	push   %eax
c002e0fc:	e8 49 29 ff ff       	call   c0020a4a <thread_create>
c002e101:	83 c4 10             	add    $0x10,%esp

      nice += nice_step;
c002e104:	8b 45 10             	mov    0x10(%ebp),%eax
c002e107:	01 45 f4             	add    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002e10a:	ff 45 f0             	incl   -0x10(%ebp)
c002e10d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e110:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e113:	7c 8b                	jl     c002e0a0 <test_mlfqs_fair+0x108>
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002e115:	83 ec 08             	sub    $0x8,%esp
c002e118:	ff 75 ec             	pushl  -0x14(%ebp)
c002e11b:	ff 75 e8             	pushl  -0x18(%ebp)
c002e11e:	e8 b0 5b ff ff       	call   c0023cd3 <timer_elapsed>
c002e123:	83 c4 10             	add    $0x10,%esp
c002e126:	83 ec 04             	sub    $0x4,%esp
c002e129:	52                   	push   %edx
c002e12a:	50                   	push   %eax
c002e12b:	68 64 2d 03 c0       	push   $0xc0032d64
c002e130:	e8 8e d7 ff ff       	call   c002b8c3 <msg>
c002e135:	83 c4 10             	add    $0x10,%esp

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002e138:	83 ec 0c             	sub    $0xc,%esp
c002e13b:	68 88 2d 03 c0       	push   $0xc0032d88
c002e140:	e8 7e d7 ff ff       	call   c002b8c3 <msg>
c002e145:	83 c4 10             	add    $0x10,%esp
  timer_sleep (40 * TIMER_FREQ);
c002e148:	83 ec 08             	sub    $0x8,%esp
c002e14b:	6a 00                	push   $0x0
c002e14d:	68 a0 0f 00 00       	push   $0xfa0
c002e152:	e8 9b 5b ff ff       	call   c0023cf2 <timer_sleep>
c002e157:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002e15a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e161:	eb 29                	jmp    c002e18c <test_mlfqs_fair+0x1f4>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002e163:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e166:	c1 e0 04             	shl    $0x4,%eax
c002e169:	8d 4d f8             	lea    -0x8(%ebp),%ecx
c002e16c:	01 c8                	add    %ecx,%eax
c002e16e:	2d 4c 01 00 00       	sub    $0x14c,%eax
c002e173:	8b 00                	mov    (%eax),%eax
c002e175:	83 ec 04             	sub    $0x4,%esp
c002e178:	50                   	push   %eax
c002e179:	ff 75 f0             	pushl  -0x10(%ebp)
c002e17c:	68 bf 2d 03 c0       	push   $0xc0032dbf
c002e181:	e8 3d d7 ff ff       	call   c002b8c3 <msg>
c002e186:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < thread_cnt; i++)
c002e189:	ff 45 f0             	incl   -0x10(%ebp)
c002e18c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e18f:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e192:	7c cf                	jl     c002e163 <test_mlfqs_fair+0x1cb>
}
c002e194:	90                   	nop
c002e195:	c9                   	leave  
c002e196:	c3                   	ret    

c002e197 <load_thread>:

static void
load_thread (void *ti_) 
{
c002e197:	55                   	push   %ebp
c002e198:	89 e5                	mov    %esp,%ebp
c002e19a:	56                   	push   %esi
c002e19b:	53                   	push   %ebx
c002e19c:	83 ec 40             	sub    $0x40,%esp
  struct thread_info *ti = ti_;
c002e19f:	8b 45 08             	mov    0x8(%ebp),%eax
c002e1a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int64_t sleep_time = 5 * TIMER_FREQ;
c002e1a5:	c7 45 e0 f4 01 00 00 	movl   $0x1f4,-0x20(%ebp)
c002e1ac:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
c002e1b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e1b6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e1b9:	05 b8 0b 00 00       	add    $0xbb8,%eax
c002e1be:	83 d2 00             	adc    $0x0,%edx
c002e1c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e1c4:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int64_t last_time = 0;
c002e1c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e1ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  thread_set_nice (ti->nice);
c002e1d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e1d8:	8b 40 0c             	mov    0xc(%eax),%eax
c002e1db:	83 ec 0c             	sub    $0xc,%esp
c002e1de:	50                   	push   %eax
c002e1df:	e8 a8 2c ff ff       	call   c0020e8c <thread_set_nice>
c002e1e4:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002e1e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e1ea:	8b 50 04             	mov    0x4(%eax),%edx
c002e1ed:	8b 00                	mov    (%eax),%eax
c002e1ef:	83 ec 08             	sub    $0x8,%esp
c002e1f2:	52                   	push   %edx
c002e1f3:	50                   	push   %eax
c002e1f4:	e8 da 5a ff ff       	call   c0023cd3 <timer_elapsed>
c002e1f9:	83 c4 10             	add    $0x10,%esp
c002e1fc:	89 45 c0             	mov    %eax,-0x40(%ebp)
c002e1ff:	89 55 c4             	mov    %edx,-0x3c(%ebp)
c002e202:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e205:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e208:	2b 45 c0             	sub    -0x40(%ebp),%eax
c002e20b:	1b 55 c4             	sbb    -0x3c(%ebp),%edx
c002e20e:	83 ec 08             	sub    $0x8,%esp
c002e211:	52                   	push   %edx
c002e212:	50                   	push   %eax
c002e213:	e8 da 5a ff ff       	call   c0023cf2 <timer_sleep>
c002e218:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e21b:	eb 42                	jmp    c002e25f <load_thread+0xc8>
    {
      int64_t cur_time = timer_ticks ();
c002e21d:	e8 7c 5a ff ff       	call   c0023c9e <timer_ticks>
c002e222:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002e225:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (cur_time != last_time)
c002e228:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e22b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e22e:	89 c1                	mov    %eax,%ecx
c002e230:	33 4d f0             	xor    -0x10(%ebp),%ecx
c002e233:	89 cb                	mov    %ecx,%ebx
c002e235:	89 d0                	mov    %edx,%eax
c002e237:	33 45 f4             	xor    -0xc(%ebp),%eax
c002e23a:	89 c6                	mov    %eax,%esi
c002e23c:	89 f0                	mov    %esi,%eax
c002e23e:	09 d8                	or     %ebx,%eax
c002e240:	85 c0                	test   %eax,%eax
c002e242:	74 0f                	je     c002e253 <load_thread+0xbc>
        ti->tick_count++;
c002e244:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e247:	8b 40 08             	mov    0x8(%eax),%eax
c002e24a:	8d 50 01             	lea    0x1(%eax),%edx
c002e24d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e250:	89 50 08             	mov    %edx,0x8(%eax)
      last_time = cur_time;
c002e253:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e256:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e259:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e25c:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e25f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e262:	8b 50 04             	mov    0x4(%eax),%edx
c002e265:	8b 00                	mov    (%eax),%eax
c002e267:	83 ec 08             	sub    $0x8,%esp
c002e26a:	52                   	push   %edx
c002e26b:	50                   	push   %eax
c002e26c:	e8 62 5a ff ff       	call   c0023cd3 <timer_elapsed>
c002e271:	83 c4 10             	add    $0x10,%esp
c002e274:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e277:	7c a4                	jl     c002e21d <load_thread+0x86>
c002e279:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e27c:	7f 05                	jg     c002e283 <load_thread+0xec>
c002e27e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c002e281:	72 9a                	jb     c002e21d <load_thread+0x86>
    }
}
c002e283:	90                   	nop
c002e284:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002e287:	5b                   	pop    %ebx
c002e288:	5e                   	pop    %esi
c002e289:	5d                   	pop    %ebp
c002e28a:	c3                   	ret    

c002e28b <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c002e28b:	55                   	push   %ebp
c002e28c:	89 e5                	mov    %esp,%ebp
c002e28e:	83 ec 28             	sub    $0x28,%esp
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c002e291:	a0 84 8c 03 c0       	mov    0xc0038c84,%al
c002e296:	84 c0                	test   %al,%al
c002e298:	75 1e                	jne    c002e2b8 <test_mlfqs_block+0x2d>
c002e29a:	83 ec 0c             	sub    $0xc,%esp
c002e29d:	68 ec 2d 03 c0       	push   $0xc0032dec
c002e2a2:	68 f9 2d 03 c0       	push   $0xc0032df9
c002e2a7:	68 58 2f 03 c0       	push   $0xc0032f58
c002e2ac:	6a 1c                	push   $0x1c
c002e2ae:	68 10 2e 03 c0       	push   $0xc0032e10
c002e2b3:	e8 70 b2 ff ff       	call   c0029528 <debug_panic>

  msg ("Main thread acquiring lock.");
c002e2b8:	83 ec 0c             	sub    $0xc,%esp
c002e2bb:	68 32 2e 03 c0       	push   $0xc0032e32
c002e2c0:	e8 fe d5 ff ff       	call   c002b8c3 <msg>
c002e2c5:	83 c4 10             	add    $0x10,%esp
  lock_init (&lock);
c002e2c8:	83 ec 0c             	sub    $0xc,%esp
c002e2cb:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e2ce:	50                   	push   %eax
c002e2cf:	e8 6f 47 ff ff       	call   c0022a43 <lock_init>
c002e2d4:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002e2d7:	83 ec 0c             	sub    $0xc,%esp
c002e2da:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e2dd:	50                   	push   %eax
c002e2de:	e8 ad 47 ff ff       	call   c0022a90 <lock_acquire>
c002e2e3:	83 c4 10             	add    $0x10,%esp
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002e2e6:	83 ec 0c             	sub    $0xc,%esp
c002e2e9:	68 50 2e 03 c0       	push   $0xc0032e50
c002e2ee:	e8 d0 d5 ff ff       	call   c002b8c3 <msg>
c002e2f3:	83 c4 10             	add    $0x10,%esp
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002e2f6:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e2f9:	50                   	push   %eax
c002e2fa:	68 90 e3 02 c0       	push   $0xc002e390
c002e2ff:	6a 1f                	push   $0x1f
c002e301:	68 8a 2e 03 c0       	push   $0xc0032e8a
c002e306:	e8 3f 27 ff ff       	call   c0020a4a <thread_create>
c002e30b:	83 c4 10             	add    $0x10,%esp
  timer_sleep (25 * TIMER_FREQ);
c002e30e:	83 ec 08             	sub    $0x8,%esp
c002e311:	6a 00                	push   $0x0
c002e313:	68 c4 09 00 00       	push   $0x9c4
c002e318:	e8 d5 59 ff ff       	call   c0023cf2 <timer_sleep>
c002e31d:	83 c4 10             	add    $0x10,%esp

  msg ("Main thread spinning for 5 seconds...");
c002e320:	83 ec 0c             	sub    $0xc,%esp
c002e323:	68 90 2e 03 c0       	push   $0xc0032e90
c002e328:	e8 96 d5 ff ff       	call   c002b8c3 <msg>
c002e32d:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e330:	e8 69 59 ff ff       	call   c0023c9e <timer_ticks>
c002e335:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e338:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e33b:	eb 01                	jmp    c002e33e <test_mlfqs_block+0xb3>
    continue;
c002e33d:	90                   	nop
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002e33e:	83 ec 08             	sub    $0x8,%esp
c002e341:	ff 75 f4             	pushl  -0xc(%ebp)
c002e344:	ff 75 f0             	pushl  -0x10(%ebp)
c002e347:	e8 87 59 ff ff       	call   c0023cd3 <timer_elapsed>
c002e34c:	83 c4 10             	add    $0x10,%esp
c002e34f:	85 d2                	test   %edx,%edx
c002e351:	78 ea                	js     c002e33d <test_mlfqs_block+0xb2>
c002e353:	85 d2                	test   %edx,%edx
c002e355:	7f 07                	jg     c002e35e <test_mlfqs_block+0xd3>
c002e357:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002e35c:	76 df                	jbe    c002e33d <test_mlfqs_block+0xb2>

  msg ("Main thread releasing lock.");
c002e35e:	83 ec 0c             	sub    $0xc,%esp
c002e361:	68 b6 2e 03 c0       	push   $0xc0032eb6
c002e366:	e8 58 d5 ff ff       	call   c002b8c3 <msg>
c002e36b:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002e36e:	83 ec 0c             	sub    $0xc,%esp
c002e371:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002e374:	50                   	push   %eax
c002e375:	e8 56 48 ff ff       	call   c0022bd0 <lock_release>
c002e37a:	83 c4 10             	add    $0x10,%esp

  msg ("Block thread should have already acquired lock.");
c002e37d:	83 ec 0c             	sub    $0xc,%esp
c002e380:	68 d4 2e 03 c0       	push   $0xc0032ed4
c002e385:	e8 39 d5 ff ff       	call   c002b8c3 <msg>
c002e38a:	83 c4 10             	add    $0x10,%esp
}
c002e38d:	90                   	nop
c002e38e:	c9                   	leave  
c002e38f:	c3                   	ret    

c002e390 <block_thread>:

static void
block_thread (void *lock_) 
{
c002e390:	55                   	push   %ebp
c002e391:	89 e5                	mov    %esp,%ebp
c002e393:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002e396:	8b 45 08             	mov    0x8(%ebp),%eax
c002e399:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002e39c:	83 ec 0c             	sub    $0xc,%esp
c002e39f:	68 04 2f 03 c0       	push   $0xc0032f04
c002e3a4:	e8 1a d5 ff ff       	call   c002b8c3 <msg>
c002e3a9:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002e3ac:	e8 ed 58 ff ff       	call   c0023c9e <timer_ticks>
c002e3b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e3b4:	89 55 ec             	mov    %edx,-0x14(%ebp)
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e3b7:	eb 01                	jmp    c002e3ba <block_thread+0x2a>
    continue;
c002e3b9:	90                   	nop
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002e3ba:	83 ec 08             	sub    $0x8,%esp
c002e3bd:	ff 75 ec             	pushl  -0x14(%ebp)
c002e3c0:	ff 75 e8             	pushl  -0x18(%ebp)
c002e3c3:	e8 0b 59 ff ff       	call   c0023cd3 <timer_elapsed>
c002e3c8:	83 c4 10             	add    $0x10,%esp
c002e3cb:	85 d2                	test   %edx,%edx
c002e3cd:	78 ea                	js     c002e3b9 <block_thread+0x29>
c002e3cf:	85 d2                	test   %edx,%edx
c002e3d1:	7f 07                	jg     c002e3da <block_thread+0x4a>
c002e3d3:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002e3d8:	76 df                	jbe    c002e3b9 <block_thread+0x29>

  msg ("Block thread acquiring lock...");
c002e3da:	83 ec 0c             	sub    $0xc,%esp
c002e3dd:	68 2c 2f 03 c0       	push   $0xc0032f2c
c002e3e2:	e8 dc d4 ff ff       	call   c002b8c3 <msg>
c002e3e7:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c002e3ea:	83 ec 0c             	sub    $0xc,%esp
c002e3ed:	ff 75 f4             	pushl  -0xc(%ebp)
c002e3f0:	e8 9b 46 ff ff       	call   c0022a90 <lock_acquire>
c002e3f5:	83 c4 10             	add    $0x10,%esp

  msg ("...got it.");
c002e3f8:	83 ec 0c             	sub    $0xc,%esp
c002e3fb:	68 4b 2f 03 c0       	push   $0xc0032f4b
c002e400:	e8 be d4 ff ff       	call   c002b8c3 <msg>
c002e405:	83 c4 10             	add    $0x10,%esp
}
c002e408:	90                   	nop
c002e409:	c9                   	leave  
c002e40a:	c3                   	ret    
